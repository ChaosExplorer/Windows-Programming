*** File /home/chaos/git_reposity/zlib/inffast.c:
                /* inffast.c -- fast decoding
                 * Copyright (C) 1995-2017 Mark Adler
                 * For conditions of distribution and use, see copyright notice in zlib.h
                 */
                
                #include "zutil.h"
                #include "inftrees.h"
                #include "inflate.h"
                #include "inffast.h"
                
                #ifdef ASMINF
                #  pragma message("Assembler code may have bugs -- use at your own risk")
                #else
                
                /*
                   Decode literal, length, and distance codes and write out the resulting
                   literal and match bytes until either not enough input or output is
                   available, an end-of-block is encountered, or a data error is encountered.
                   When large enough input and output buffers are supplied to inflate(), for
                   example, a 16K input buffer and a 64K output buffer, more than 95% of the
                   inflate execution time is spent in this routine.
                
                   Entry assumptions:
                
                        state->mode == LEN
                        strm->avail_in >= 6
                        strm->avail_out >= 258
                        start >= strm->avail_out
                        state->bits < 8
                
                   On return, state->mode is one of:
                
                        LEN -- ran out of enough output space or enough available input
                        TYPE -- reached end of block code, inflate() to interpret next block
                        BAD -- error in block data
                
                   Notes:
                
                    - The maximum input bits used by a length/distance pair is 15 bits for the
                      length code, 5 bits for the length extra, 15 bits for the distance code,
                      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
                      Therefore if strm->avail_in >= 6, then there is enough input to avoid
                      checking for available input while decoding.
                
                    - The maximum bytes that a single length/distance pair can output is 258
                      bytes, which is the maximum length that can be coded.  inflate_fast()
                      requires strm->avail_out >= 258 for each loop to avoid checking for
                      output space.
                 */
                void ZLIB_INTERNAL inflate_fast(strm, start)
                z_streamp strm;
                unsigned start;         /* inflate()'s starting value for strm->avail_out */
      113993 -> {
                    struct inflate_state FAR *state;
                    z_const unsigned char FAR *in;      /* local strm->next_in */
                    z_const unsigned char FAR *last;    /* have enough input while in < last */
                    unsigned char FAR *out;     /* local strm->next_out */
                    unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */
                    unsigned char FAR *end;     /* while out < end, enough space available */
                #ifdef INFLATE_STRICT
                    unsigned dmax;              /* maximum distance from zlib header */
                #endif
                    unsigned wsize;             /* window size or zero if not using window */
                    unsigned whave;             /* valid bytes in the window */
                    unsigned wnext;             /* window write index */
                    unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */
                    unsigned long hold;         /* local strm->hold */
                    unsigned bits;              /* local strm->bits */
                    code const FAR *lcode;      /* local strm->lencode */
                    code const FAR *dcode;      /* local strm->distcode */
                    unsigned lmask;             /* mask for first level of length codes */
                    unsigned dmask;             /* mask for first level of distance codes */
                    code here;                  /* retrieved table entry */
                    unsigned op;                /* code bits, operation, extra bits, or */
                                                /*  window position, window bytes to copy */
                    unsigned len;               /* match length, unused bytes */
                    unsigned dist;              /* match distance */
                    unsigned char FAR *from;    /* where to copy match from */
                
                    /* copy state to local variables */
                    state = (struct inflate_state FAR *)strm->state;
                    in = strm->next_in;
                    last = in + (strm->avail_in - 5);
                    out = strm->next_out;
                    beg = out - (start - strm->avail_out);
                    end = out + (strm->avail_out - 257);
                #ifdef INFLATE_STRICT
                    dmax = state->dmax;
                #endif
                    wsize = state->wsize;
                    whave = state->whave;
                    wnext = state->wnext;
                    window = state->window;
                    hold = state->hold;
                    bits = state->bits;
                    lcode = state->lencode;
                    dcode = state->distcode;
                    lmask = (1U << state->lenbits) - 1;
                    dmask = (1U << state->distbits) - 1;
                
                    /* decode literals and length/distances until end-of-block or not enough
                       input data or output space */
                    do {
                        if (bits < 15) {
                            hold += (unsigned long)(*in++) << bits;
                            bits += 8;
                            hold += (unsigned long)(*in++) << bits;
                            bits += 8;
                        }
                        here = lcode[hold & lmask];
                      dolen:
                        op = (unsigned)(here.bits);
                        hold >>= op;
                        bits -= op;
                        op = (unsigned)(here.op);
                        if (op == 0) {                          /* literal */
                            Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                                    "inflate:         literal '%c'\n" :
                                    "inflate:         literal 0x%02x\n", here.val));
                            *out++ = (unsigned char)(here.val);
                        }
                        else if (op & 16) {                     /* length base */
                            len = (unsigned)(here.val);
                            op &= 15;                           /* number of extra bits */
                            if (op) {
                                if (bits < op) {
                                    hold += (unsigned long)(*in++) << bits;
                                    bits += 8;
                                }
                                len += (unsigned)hold & ((1U << op) - 1);
                                hold >>= op;
                                bits -= op;
                            }
                            Tracevv((stderr, "inflate:         length %u\n", len));
                            if (bits < 15) {
                                hold += (unsigned long)(*in++) << bits;
                                bits += 8;
                                hold += (unsigned long)(*in++) << bits;
                                bits += 8;
                            }
                            here = dcode[hold & dmask];
                          dodist:
                            op = (unsigned)(here.bits);
                            hold >>= op;
                            bits -= op;
                            op = (unsigned)(here.op);
                            if (op & 16) {                      /* distance base */
                                dist = (unsigned)(here.val);
                                op &= 15;                       /* number of extra bits */
                                if (bits < op) {
                                    hold += (unsigned long)(*in++) << bits;
                                    bits += 8;
                                    if (bits < op) {
                                        hold += (unsigned long)(*in++) << bits;
                                        bits += 8;
                                    }
                                }
                                dist += (unsigned)hold & ((1U << op) - 1);
                #ifdef INFLATE_STRICT
                                if (dist > dmax) {
                                    strm->msg = (char *)"invalid distance too far back";
                                    state->mode = BAD;
                                    break;
                                }
                #endif
                                hold >>= op;
                                bits -= op;
                                Tracevv((stderr, "inflate:         distance %u\n", dist));
                                op = (unsigned)(out - beg);     /* max distance in output */
                                if (dist > op) {                /* see if copy from window */
                                    op = dist - op;             /* distance back in window */
                                    if (op > whave) {
                                        if (state->sane) {
                                            strm->msg =
                                                (char *)"invalid distance too far back";
                                            state->mode = BAD;
                                            break;
                                        }
                #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                                        if (len <= op - whave) {
                                            do {
                                                *out++ = 0;
                                            } while (--len);
                                            continue;
                                        }
                                        len -= op - whave;
                                        do {
                                            *out++ = 0;
                                        } while (--op > whave);
                                        if (op == 0) {
                                            from = out - dist;
                                            do {
                                                *out++ = *from++;
                                            } while (--len);
                                            continue;
                                        }
                #endif
                                    }
                                    from = window;
                                    if (wnext == 0) {           /* very common case */
                                        from += wsize - op;
                                        if (op < len) {         /* some from window */
                                            len -= op;
                                            do {
                                                *out++ = *from++;
                                            } while (--op);
                                            from = out - dist;  /* rest from output */
                                        }
                                    }
                                    else if (wnext < op) {      /* wrap around window */
                                        from += wsize + wnext - op;
                                        op -= wnext;
                                        if (op < len) {         /* some from end of window */
                                            len -= op;
                                            do {
                                                *out++ = *from++;
                                            } while (--op);
                                            from = window;
                                            if (wnext < len) {  /* some from start of window */
                                                op = wnext;
                                                len -= op;
                                                do {
                                                    *out++ = *from++;
                                                } while (--op);
                                                from = out - dist;      /* rest from output */
                                            }
                                        }
                                    }
                                    else {                      /* contiguous in window */
                                        from += wnext - op;
                                        if (op < len) {         /* some from window */
                                            len -= op;
                                            do {
                                                *out++ = *from++;
                                            } while (--op);
                                            from = out - dist;  /* rest from output */
                                        }
                                    }
                                    while (len > 2) {
                                        *out++ = *from++;
                                        *out++ = *from++;
                                        *out++ = *from++;
                                        len -= 3;
                                    }
                                    if (len) {
                                        *out++ = *from++;
                                        if (len > 1)
                                            *out++ = *from++;
                                    }
                                }
                                else {
                                    from = out - dist;          /* copy direct from output */
                                    do {                        /* minimum length is three */
                                        *out++ = *from++;
                                        *out++ = *from++;
                                        *out++ = *from++;
                                        len -= 3;
                                    } while (len > 2);
                                    if (len) {
                                        *out++ = *from++;
                                        if (len > 1)
                                            *out++ = *from++;
                                    }
                                }
                            }
                            else if ((op & 64) == 0) {          /* 2nd level distance code */
                                here = dcode[here.val + (hold & ((1U << op) - 1))];
                                goto dodist;
                            }
                            else {
                                strm->msg = (char *)"invalid distance code";
                                state->mode = BAD;
                                break;
                            }
                        }
                        else if ((op & 64) == 0) {              /* 2nd level length code */
                            here = lcode[here.val + (hold & ((1U << op) - 1))];
                            goto dolen;
                        }
                        else if (op & 32) {                     /* end-of-block */
                            Tracevv((stderr, "inflate:         end of block\n"));
                            state->mode = TYPE;
                            break;
                        }
                        else {
                            strm->msg = (char *)"invalid literal/length code";
                            state->mode = BAD;
                            break;
                        }
                    } while (in < last && out < end);
                
                    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
                    len = bits >> 3;
                    in -= len;
                    bits -= len << 3;
                    hold &= (1U << bits) - 1;
                
                    /* update state and return */
                    strm->next_in = in;
                    strm->next_out = out;
                    strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
                    strm->avail_out = (unsigned)(out < end ?
                                                 257 + (end - out) : 257 - (out - end));
                    state->hold = hold;
                    state->bits = bits;
                    return;
                }
                
                /*
                   inflate_fast() speedups that turned out slower (on a PowerPC G3 750CXe):
                   - Using bit fields for code structure
                   - Different op definition to avoid & for extra bits (do & for table bits)
                   - Three separate decoding do-loops for direct, window, and wnext == 0
                   - Special case for distance > 1 copies to do overlapped load and store copy
                   - Explicit branch predictions (based on measured branch probabilities)
                   - Deferring match copy and interspersed it with decoding subsequent codes
                   - Swapping literal/length else
                   - Swapping window/direct else
                   - Larger unrolled copy loops (three is about right)
                   - Moving len -= 3 statement into middle of loop
                 */
                
                #endif /* !ASMINF */


Top 10 Lines:

     Line      Count

       53     113993

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

   113993   Total number of line executions
113993.00   Average executions per line


*** File /usr/include/c++/5/bits/basic_string.h:
                // Components for manipulating sequences of characters -*- C++ -*-
                
                // Copyright (C) 1997-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/basic_string.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{string}
                 */
                
                //
                // ISO C++ 14882: 21 Strings library
                //
                
                #ifndef _BASIC_STRING_H
                #define _BASIC_STRING_H 1
                
                #pragma GCC system_header
                
                #include <ext/atomicity.h>
                #include <ext/alloc_traits.h>
                #include <debug/debug.h>
                #if __cplusplus >= 201103L
                #include <initializer_list>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                #if _GLIBCXX_USE_CXX11_ABI
                _GLIBCXX_BEGIN_NAMESPACE_CXX11
                  /**
                   *  @class basic_string basic_string.h <string>
                   *  @brief  Managing sequences of characters and character-like objects.
                   *
                   *  @ingroup strings
                   *  @ingroup sequences
                   *
                   *  @tparam _CharT  Type of character
                   *  @tparam _Traits  Traits for character type, defaults to
                   *                   char_traits<_CharT>.
                   *  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.
                   *
                   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
                   *  <a href="tables.html#66">reversible container</a>, and a
                   *  <a href="tables.html#67">sequence</a>.  Of the
                   *  <a href="tables.html#68">optional sequence requirements</a>, only
                   *  @c push_back, @c at, and @c %array access are supported.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    class basic_string
                    {
                      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
                	rebind<_CharT>::other _Char_alloc_type;
                      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
                
                      // Types:
                    public:
                      typedef _Traits					traits_type;
                      typedef typename _Traits::char_type		value_type;
                      typedef _Char_alloc_type				allocator_type;
                      typedef typename _Alloc_traits::size_type		size_type;
                      typedef typename _Alloc_traits::difference_type	difference_type;
                      typedef typename _Alloc_traits::reference		reference;
                      typedef typename _Alloc_traits::const_reference	const_reference;
                      typedef typename _Alloc_traits::pointer		pointer;
                      typedef typename _Alloc_traits::const_pointer	const_pointer;
                      typedef __gnu_cxx::__normal_iterator<pointer, basic_string>  iterator;
                      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                							const_iterator;
                      typedef std::reverse_iterator<const_iterator>	const_reverse_iterator;
                      typedef std::reverse_iterator<iterator>		reverse_iterator;
                
                      ///  Value returned by various member functions when they fail.
                      static const size_type	npos = static_cast<size_type>(-1);
                
                    private:
                      // type used for positions in insert, erase etc.
                #if __cplusplus < 201103L
                      typedef iterator __const_iterator;
                #else
                      typedef const_iterator __const_iterator;
                #endif
                
                      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
                      struct _Alloc_hider : allocator_type // TODO check __is_final
                      {
                	_Alloc_hider(pointer __dat, const _Alloc& __a = _Alloc())
                	: allocator_type(__a), _M_p(__dat) { }
                
                	pointer _M_p; // The actual data.
                      };
                
                      _Alloc_hider	_M_dataplus;
                      size_type		_M_string_length;
                
                      enum { _S_local_capacity = 15 / sizeof(_CharT) };
                
                      union
                      {
                	_CharT           _M_local_buf[_S_local_capacity + 1];
                	size_type        _M_allocated_capacity;
                      };
                
                      void
                      _M_data(pointer __p)
                      { _M_dataplus._M_p = __p; }
                
                      void
                      _M_length(size_type __length)
                      { _M_string_length = __length; }
                
                      pointer
                      _M_data() const
                      { return _M_dataplus._M_p; }
                
                      pointer
                      _M_local_data()
                      {
                #if __cplusplus >= 201103L
                	return std::pointer_traits<pointer>::pointer_to(*_M_local_buf);
                #else
                	return pointer(_M_local_buf);
                #endif
                      }
                
                      const_pointer
                      _M_local_data() const
                      {
                #if __cplusplus >= 201103L
                	return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);
                #else
                	return const_pointer(_M_local_buf);
                #endif
                      }
                
                      void
                      _M_capacity(size_type __capacity)
                      { _M_allocated_capacity = __capacity; }
                
                      void
                      _M_set_length(size_type __n)
                      {
                	_M_length(__n);
                	traits_type::assign(_M_data()[__n], _CharT());
                      }
                
                      bool
                      _M_is_local() const
                      { return _M_data() == _M_local_data(); }
                
                      // Create & Destroy
                      pointer
                      _M_create(size_type&, size_type);
                
                      void
                      _M_dispose()
                      {
                	if (!_M_is_local())
                	  _M_destroy(_M_allocated_capacity);
                      }
                
                      void
                      _M_destroy(size_type __size) throw()
                      { _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1); }
                
                      // _M_construct_aux is used to implement the 21.3.1 para 15 which
                      // requires special behaviour if _InIterator is an integral type
                      template<typename _InIterator>
                        void
                        _M_construct_aux(_InIterator __beg, _InIterator __end,
                			 std::__false_type)
                	{
                          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
                          _M_construct(__beg, __end, _Tag());
                	}
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                        void
                        _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type)
                	{ _M_construct_aux_2(static_cast<size_type>(__beg), __end); }
                
                      void
                      _M_construct_aux_2(size_type __req, _CharT __c)
                      { _M_construct(__req, __c); }
                
                      template<typename _InIterator>
                        void
                        _M_construct(_InIterator __beg, _InIterator __end)
                	{
                	  typedef typename std::__is_integer<_InIterator>::__type _Integral;
                	  _M_construct_aux(__beg, __end, _Integral());
                        }
                
                      // For Input Iterators, used in istreambuf_iterators, etc.
                      template<typename _InIterator>
                        void
                        _M_construct(_InIterator __beg, _InIterator __end,
                		     std::input_iterator_tag);
                
                      // For forward_iterators up to random_access_iterators, used for
                      // string::iterator, _CharT*, etc.
                      template<typename _FwdIterator>
                        void
                        _M_construct(_FwdIterator __beg, _FwdIterator __end,
                		     std::forward_iterator_tag);
                
                      void
                      _M_construct(size_type __req, _CharT __c);
                
                      allocator_type&
                      _M_get_allocator()
                      { return _M_dataplus; }
                
                      const allocator_type&
                      _M_get_allocator() const
                      { return _M_dataplus; }
                
                    private:
                
                #ifdef _GLIBCXX_DISAMBIGUATE_REPLACE_INST
                      // The explicit instantiations in misc-inst.cc require this due to
                      // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=64063
                      template<typename _Tp, bool _Requires =
                	       !__are_same<_Tp, _CharT*>::__value
                	       && !__are_same<_Tp, const _CharT*>::__value
                	       && !__are_same<_Tp, iterator>::__value
                	       && !__are_same<_Tp, const_iterator>::__value>
                	struct __enable_if_not_native_iterator
                	{ typedef basic_string& __type; };
                      template<typename _Tp>
                	struct __enable_if_not_native_iterator<_Tp, false> { };
                #endif
                
                      size_type
                      _M_check(size_type __pos, const char* __s) const
                      {
                	if (__pos > this->size())
                	  __throw_out_of_range_fmt(__N("%s: __pos (which is %zu) > "
                				       "this->size() (which is %zu)"),
                				   __s, __pos, this->size());
                	return __pos;
                      }
                
                      void
                      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
                      {
                	if (this->max_size() - (this->size() - __n1) < __n2)
                	  __throw_length_error(__N(__s));
                      }
                
                
                      // NB: _M_limit doesn't check for a bad __pos value.
                      size_type
                      _M_limit(size_type __pos, size_type __off) const _GLIBCXX_NOEXCEPT
                      {
                	const bool __testoff =  __off < this->size() - __pos;
                	return __testoff ? __off : this->size() - __pos;
                      }
                
                      // True if _Rep and source do not overlap.
                      bool
                      _M_disjunct(const _CharT* __s) const _GLIBCXX_NOEXCEPT
                      {
                	return (less<const _CharT*>()(__s, _M_data())
                		|| less<const _CharT*>()(_M_data() + this->size(), __s));
                      }
                
                      // When __n = 1 way faster than the general multichar
                      // traits_type::copy/move/assign.
                      static void
                      _S_copy(_CharT* __d, const _CharT* __s, size_type __n)
                      {
                	if (__n == 1)
                	  traits_type::assign(*__d, *__s);
                	else
                	  traits_type::copy(__d, __s, __n);
                      }
                
                      static void
                      _S_move(_CharT* __d, const _CharT* __s, size_type __n)
                      {
                	if (__n == 1)
                	  traits_type::assign(*__d, *__s);
                	else
                	  traits_type::move(__d, __s, __n);
                      }
                
                      static void
                      _S_assign(_CharT* __d, size_type __n, _CharT __c)
                      {
                	if (__n == 1)
                	  traits_type::assign(*__d, __c);
                	else
                	  traits_type::assign(__d, __n, __c);
                      }
                
                      // _S_copy_chars is a separate template to permit specialization
                      // to optimize for the common case of pointers as iterators.
                      template<class _Iterator>
                        static void
                        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
                        {
                	  for (; __k1 != __k2; ++__k1, ++__p)
                	    traits_type::assign(*__p, *__k1); // These types are off.
                	}
                
                      static void
                      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) _GLIBCXX_NOEXCEPT
                      { _S_copy_chars(__p, __k1.base(), __k2.base()); }
                
                      static void
                      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
                      _GLIBCXX_NOEXCEPT
                      { _S_copy_chars(__p, __k1.base(), __k2.base()); }
                
                      static void
                      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) _GLIBCXX_NOEXCEPT
                      { _S_copy(__p, __k1, __k2 - __k1); }
                
                      static void
                      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
                      _GLIBCXX_NOEXCEPT
                      { _S_copy(__p, __k1, __k2 - __k1); }
                
                      static int
                      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
                      {
                	const difference_type __d = difference_type(__n1 - __n2);
                
                	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
                	  return __gnu_cxx::__numeric_traits<int>::__max;
                	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
                	  return __gnu_cxx::__numeric_traits<int>::__min;
                	else
                	  return int(__d);
                      }
                
                      void
                      _M_assign(const basic_string& __rcs);
                
                      void
                      _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
                		size_type __len2);
                
                      void
                      _M_erase(size_type __pos, size_type __n);
                
                    public:
                      // Construct/copy/destroy:
                      // NB: We overload ctors in some cases instead of using default
                      // arguments, per 17.4.4.4 para. 2 item 2.
                
                      /**
                       *  @brief  Default constructor creates an empty string.
                       */
                      basic_string()
                #if __cplusplus >= 201103L
                      noexcept(is_nothrow_default_constructible<_Alloc>::value)
                #endif
                      : _M_dataplus(_M_local_data())
                      { _M_set_length(0); }
                
                      /**
                       *  @brief  Construct an empty string using allocator @a a.
                       */
                      explicit
                      basic_string(const _Alloc& __a)
                      : _M_dataplus(_M_local_data(), __a)
                      { _M_set_length(0); }
                
                      /**
                       *  @brief  Construct string with copy of value of @a __str.
                       *  @param  __str  Source string.
                       */
                      basic_string(const basic_string& __str)
                      : _M_dataplus(_M_local_data(), __str._M_get_allocator()) // TODO A traits
                      { _M_construct(__str._M_data(), __str._M_data() + __str.length()); }
                
                      /**
                       *  @brief  Construct string as copy of a substring.
                       *  @param  __str  Source string.
                       *  @param  __pos  Index of first character to copy from.
                       *  @param  __n  Number of characters to copy (default remainder).
                       */
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2402. [this constructor] shouldn't use Allocator()
                      basic_string(const basic_string& __str, size_type __pos,
                		   size_type __n = npos)
                      : _M_dataplus(_M_local_data())
                      {
                	const _CharT* __start = __str._M_data()
                	  + __str._M_check(__pos, "basic_string::basic_string");
                	_M_construct(__start, __start + __str._M_limit(__pos, __n));
                      }
                
                      /**
                       *  @brief  Construct string as copy of a substring.
                       *  @param  __str  Source string.
                       *  @param  __pos  Index of first character to copy from.
                       *  @param  __n  Number of characters to copy (default remainder).
                       *  @param  __a  Allocator to use.
                       */
                      basic_string(const basic_string& __str, size_type __pos,
                		   size_type __n, const _Alloc& __a)
                      : _M_dataplus(_M_local_data(), __a)
                      {
                	const _CharT* __start
                	  = __str._M_data() + __str._M_check(__pos, "string::string");
                	_M_construct(__start, __start + __str._M_limit(__pos, __n));
                      }
                
                      /**
                       *  @brief  Construct string initialized by a character %array.
                       *  @param  __s  Source character %array.
                       *  @param  __n  Number of characters to copy.
                       *  @param  __a  Allocator to use (default is default allocator).
                       *
                       *  NB: @a __s must have at least @a __n characters, &apos;\\0&apos;
                       *  has no special meaning.
                       */
                      basic_string(const _CharT* __s, size_type __n,
                		   const _Alloc& __a = _Alloc())
                      : _M_dataplus(_M_local_data(), __a)
                      { _M_construct(__s, __s + __n); }
                
                      /**
                       *  @brief  Construct string as copy of a C string.
                       *  @param  __s  Source C string.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())
                      : _M_dataplus(_M_local_data(), __a)
                      { _M_construct(__s, __s ? __s + traits_type::length(__s) : __s+npos); }
                
                      /**
                       *  @brief  Construct string as multiple characters.
                       *  @param  __n  Number of characters.
                       *  @param  __c  Character to use.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())
                      : _M_dataplus(_M_local_data(), __a)
                      { _M_construct(__n, __c); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Move construct string.
                       *  @param  __str  Source string.
                       *
                       *  The newly-created string contains the exact contents of @a __str.
                       *  @a __str is a valid, but unspecified string.
                       **/
                      basic_string(basic_string&& __str) noexcept
                      : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator()))
                      {
                	if (__str._M_is_local())
                	  {
                	    traits_type::copy(_M_local_buf, __str._M_local_buf,
                			      _S_local_capacity + 1);
                	  }
                	else
                	  {
                	    _M_data(__str._M_data());
                	    _M_capacity(__str._M_allocated_capacity);
                	  }
                
                	// Must use _M_length() here not _M_set_length() because
                	// basic_stringbuf relies on writing into unallocated capacity so
                	// we mess up the contents if we put a '\0' in the string.
                	_M_length(__str.length());
                	__str._M_data(__str._M_local_data());
                	__str._M_set_length(0);
                      }
                
                      /**
                       *  @brief  Construct string from an initializer %list.
                       *  @param  __l  std::initializer_list of characters.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())
                      : _M_dataplus(_M_local_data(), __a)
                      { _M_construct(__l.begin(), __l.end()); }
                
                      basic_string(const basic_string& __str, const _Alloc& __a)
                      : _M_dataplus(_M_local_data(), __a)
                      { _M_construct(__str.begin(), __str.end()); }
                
                      basic_string(basic_string&& __str, const _Alloc& __a)
                      : _M_dataplus(_M_local_data(), __a)
                      {
                	if (__str.get_allocator() == __a)
                	  *this = std::move(__str);
                	else
                	  _M_construct(__str.begin(), __str.end());
                      }
                
                #endif // C++11
                
                      /**
                       *  @brief  Construct string as copy of a range.
                       *  @param  __beg  Start of range.
                       *  @param  __end  End of range.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                #if __cplusplus >= 201103L
                      template<typename _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                #else
                      template<typename _InputIterator>
                #endif
                        basic_string(_InputIterator __beg, _InputIterator __end,
                		     const _Alloc& __a = _Alloc())
                	: _M_dataplus(_M_local_data(), __a)
                	{ _M_construct(__beg, __end); }
                
                      /**
                       *  @brief  Destroy the string instance.
                       */
                      ~basic_string()
                      { _M_dispose(); }
                
                      /**
                       *  @brief  Assign the value of @a str to this string.
                       *  @param  __str  Source string.
                       */
                      basic_string&
                      operator=(const basic_string& __str)
                      { return this->assign(__str); }
                
                      /**
                       *  @brief  Copy contents of @a s into this string.
                       *  @param  __s  Source null-terminated string.
                       */
                      basic_string&
                      operator=(const _CharT* __s)
                      { return this->assign(__s); }
                
                      /**
                       *  @brief  Set value to string of length 1.
                       *  @param  __c  Source character.
                       *
                       *  Assigning to a character makes this string length 1 and
                       *  (*this)[0] == @a c.
                       */
                      basic_string&
                      operator=(_CharT __c)
                      {
                	this->assign(1, __c);
                	return *this;
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Move assign the value of @a str to this string.
                       *  @param  __str  Source string.
                       *
                       *  The contents of @a str are moved into this string (without copying).
                       *  @a str is a valid, but unspecified string.
                       **/
                      // PR 58265, this should be noexcept.
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2063. Contradictory requirements for string move assignment
                      basic_string&
                      operator=(basic_string&& __str)
                      {
                	this->swap(__str);
                	return *this;
                      }
                
                      /**
                       *  @brief  Set value to string constructed from initializer %list.
                       *  @param  __l  std::initializer_list.
                       */
                      basic_string&
                      operator=(initializer_list<_CharT> __l)
                      {
                	this->assign(__l.begin(), __l.size());
                	return *this;
                      }
                #endif // C++11
                
                      // Iterators:
                      /**
                       *  Returns a read/write iterator that points to the first character in
                       *  the %string.
                       */
                      iterator
                      begin() _GLIBCXX_NOEXCEPT
                      { return iterator(_M_data()); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points to the first
                       *  character in the %string.
                       */
                      const_iterator
                      begin() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(_M_data()); }
                
                      /**
                       *  Returns a read/write iterator that points one past the last
                       *  character in the %string.
                       */
                      iterator
                      end() _GLIBCXX_NOEXCEPT
                      { return iterator(_M_data() + this->size()); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past the
                       *  last character in the %string.
                       */
                      const_iterator
                      end() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(_M_data() + this->size()); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to the last
                       *  character in the %string.  Iteration is done in reverse element
                       *  order.
                       */
                      reverse_iterator
                      rbegin() _GLIBCXX_NOEXCEPT
                      { return reverse_iterator(this->end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last character in the %string.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      rbegin() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(this->end()); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to one before the
                       *  first character in the %string.  Iteration is done in reverse
                       *  element order.
                       */
                      reverse_iterator
                      rend() _GLIBCXX_NOEXCEPT
                      { return reverse_iterator(this->begin()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first character in the %string.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      rend() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(this->begin()); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  Returns a read-only (constant) iterator that points to the first
                       *  character in the %string.
                       */
                      const_iterator
                      cbegin() const noexcept
                      { return const_iterator(this->_M_data()); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past the
                       *  last character in the %string.
                       */
                      const_iterator
                      cend() const noexcept
                      { return const_iterator(this->_M_data() + this->size()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last character in the %string.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      crbegin() const noexcept
                      { return const_reverse_iterator(this->end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first character in the %string.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      crend() const noexcept
                      { return const_reverse_iterator(this->begin()); }
                #endif
                
                    public:
                      // Capacity:
                      ///  Returns the number of characters in the string, not including any
                      ///  null-termination.
                      size_type
                      size() const _GLIBCXX_NOEXCEPT
                      { return _M_string_length; }
                
                      ///  Returns the number of characters in the string, not including any
                      ///  null-termination.
                      size_type
                      length() const _GLIBCXX_NOEXCEPT
                      { return _M_string_length; }
                
                      ///  Returns the size() of the largest possible %string.
                      size_type
                      max_size() const _GLIBCXX_NOEXCEPT
                      { return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2; }
                
                      /**
                       *  @brief  Resizes the %string to the specified number of characters.
                       *  @param  __n  Number of characters the %string should contain.
                       *  @param  __c  Character to fill any new elements.
                       *
                       *  This function will %resize the %string to the specified
                       *  number of characters.  If the number is smaller than the
                       *  %string's current size the %string is truncated, otherwise
                       *  the %string is extended and new elements are %set to @a __c.
                       */
                      void
                      resize(size_type __n, _CharT __c);
                
                      /**
                       *  @brief  Resizes the %string to the specified number of characters.
                       *  @param  __n  Number of characters the %string should contain.
                       *
                       *  This function will resize the %string to the specified length.  If
                       *  the new size is smaller than the %string's current size the %string
                       *  is truncated, otherwise the %string is extended and new characters
                       *  are default-constructed.  For basic types such as char, this means
                       *  setting them to 0.
                       */
                      void
                      resize(size_type __n)
                      { this->resize(__n, _CharT()); }
                
                #if __cplusplus >= 201103L
                      ///  A non-binding request to reduce capacity() to size().
                      void
                      shrink_to_fit() noexcept
                      {
                #if __cpp_exceptions
                	if (capacity() > size())
                	  {
                	    try
                	      { reserve(0); }
                	    catch(...)
                	      { }
                	  }
                #endif
                      }
                #endif
                
                      /**
                       *  Returns the total number of characters that the %string can hold
                       *  before needing to allocate more memory.
                       */
                      size_type
                      capacity() const _GLIBCXX_NOEXCEPT
                      {
                	return _M_is_local() ? size_type(_S_local_capacity)
                	                     : _M_allocated_capacity;
                      }
                
                      /**
                       *  @brief  Attempt to preallocate enough memory for specified number of
                       *          characters.
                       *  @param  __res_arg  Number of characters required.
                       *  @throw  std::length_error  If @a __res_arg exceeds @c max_size().
                       *
                       *  This function attempts to reserve enough memory for the
                       *  %string to hold the specified number of characters.  If the
                       *  number requested is more than max_size(), length_error is
                       *  thrown.
                       *
                       *  The advantage of this function is that if optimal code is a
                       *  necessity and the user can determine the string length that will be
                       *  required, the user can reserve the memory in %advance, and thus
                       *  prevent a possible reallocation of memory and copying of %string
                       *  data.
                       */
                      void
                      reserve(size_type __res_arg = 0);
                
                      /**
                       *  Erases the string, making it empty.
                       */
                      void
                      clear() _GLIBCXX_NOEXCEPT
                      { _M_set_length(0); }
                
                      /**
                       *  Returns true if the %string is empty.  Equivalent to 
                       *  <code>*this == ""</code>.
                       */
                      bool
                      empty() const _GLIBCXX_NOEXCEPT
                      { return this->size() == 0; }
                
                      // Element access:
                      /**
                       *  @brief  Subscript access to the data contained in the %string.
                       *  @param  __pos  The index of the character to access.
                       *  @return  Read-only (constant) reference to the character.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)
                       */
                      const_reference
                      operator[] (size_type __pos) const _GLIBCXX_NOEXCEPT
                      {
                	_GLIBCXX_DEBUG_ASSERT(__pos <= size());
                	return _M_data()[__pos];
                      }
                
                      /**
                       *  @brief  Subscript access to the data contained in the %string.
                       *  @param  __pos  The index of the character to access.
                       *  @return  Read/write reference to the character.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)
                       */
                      reference
                      operator[](size_type __pos)
                      {
                        // Allow pos == size() both in C++98 mode, as v3 extension,
                	// and in C++11 mode.
                	_GLIBCXX_DEBUG_ASSERT(__pos <= size());
                        // In pedantic mode be strict in C++98 mode.
                	_GLIBCXX_DEBUG_PEDASSERT(__cplusplus >= 201103L || __pos < size());
                	return _M_data()[__pos];
                      }
                
                      /**
                       *  @brief  Provides access to the data contained in the %string.
                       *  @param __n The index of the character to access.
                       *  @return  Read-only (const) reference to the character.
                       *  @throw  std::out_of_range  If @a n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter is
                       *  first checked that it is in the range of the string.  The function
                       *  throws out_of_range if the check fails.
                       */
                      const_reference
                      at(size_type __n) const
                      {
                	if (__n >= this->size())
                	  __throw_out_of_range_fmt(__N("basic_string::at: __n "
                				       "(which is %zu) >= this->size() "
                				       "(which is %zu)"),
                				   __n, this->size());
                	return _M_data()[__n];
                      }
                
                      /**
                       *  @brief  Provides access to the data contained in the %string.
                       *  @param __n The index of the character to access.
                       *  @return  Read/write reference to the character.
                       *  @throw  std::out_of_range  If @a n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter is
                       *  first checked that it is in the range of the string.  The function
                       *  throws out_of_range if the check fails.
                       */
                      reference
                      at(size_type __n)
                      {
                	if (__n >= size())
                	  __throw_out_of_range_fmt(__N("basic_string::at: __n "
                				       "(which is %zu) >= this->size() "
                				       "(which is %zu)"),
                				   __n, this->size());
                	return _M_data()[__n];
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  Returns a read/write reference to the data at the first
                       *  element of the %string.
                       */
                      reference
                      front() noexcept
                      { return operator[](0); }
                
                      /**
                       *  Returns a read-only (constant) reference to the data at the first
                       *  element of the %string.
                       */
                      const_reference
                      front() const noexcept
                      { return operator[](0); }
                
                      /**
                       *  Returns a read/write reference to the data at the last
                       *  element of the %string.
                       */
                      reference
                      back() noexcept
                      { return operator[](this->size() - 1); }
                
                      /**
                       *  Returns a read-only (constant) reference to the data at the
                       *  last element of the %string.
                       */
                      const_reference
                      back() const noexcept
                      { return operator[](this->size() - 1); }
                #endif
                
                      // Modifiers:
                      /**
                       *  @brief  Append a string to this string.
                       *  @param __str  The string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(const basic_string& __str)
                      { return this->append(__str); }
                
                      /**
                       *  @brief  Append a C string.
                       *  @param __s  The C string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(const _CharT* __s)
                      { return this->append(__s); }
                
                      /**
                       *  @brief  Append a character.
                       *  @param __c  The character to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(_CharT __c)
                      {
                	this->push_back(__c);
                	return *this;
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Append an initializer_list of characters.
                       *  @param __l  The initializer_list of characters to be appended.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(initializer_list<_CharT> __l)
                      { return this->append(__l.begin(), __l.size()); }
                #endif // C++11
                
                      /**
                       *  @brief  Append a string to this string.
                       *  @param __str  The string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(const basic_string& __str)
                      { return _M_append(__str._M_data(), __str.size()); }
                
                      /**
                       *  @brief  Append a substring.
                       *  @param __str  The string to append.
                       *  @param __pos  Index of the first character of str to append.
                       *  @param __n  The number of characters to append.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range if @a __pos is not a valid index.
                       *
                       *  This function appends @a __n characters from @a __str
                       *  starting at @a __pos to this string.  If @a __n is is larger
                       *  than the number of available characters in @a __str, the
                       *  remainder of @a __str is appended.
                       */
                      basic_string&
                      append(const basic_string& __str, size_type __pos, size_type __n)
                      { return _M_append(__str._M_data()
                			 + __str._M_check(__pos, "basic_string::append"),
                			 __str._M_limit(__pos, __n)); }
                
                      /**
                       *  @brief  Append a C substring.
                       *  @param __s  The C string to append.
                       *  @param __n  The number of characters to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(const _CharT* __s, size_type __n)
                      {
                	__glibcxx_requires_string_len(__s, __n);
                	_M_check_length(size_type(0), __n, "basic_string::append");
                	return _M_append(__s, __n);
                      }
                
                      /**
                       *  @brief  Append a C string.
                       *  @param __s  The C string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	const size_type __n = traits_type::length(__s);
                	_M_check_length(size_type(0), __n, "basic_string::append");
                	return _M_append(__s, __n);
                      }
                
                      /**
                       *  @brief  Append multiple characters.
                       *  @param __n  The number of characters to append.
                       *  @param __c  The character to use.
                       *  @return  Reference to this string.
                       *
                       *  Appends __n copies of __c to this string.
                       */
                      basic_string&
                      append(size_type __n, _CharT __c)
                      { return _M_replace_aux(this->size(), size_type(0), __n, __c); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Append an initializer_list of characters.
                       *  @param __l  The initializer_list of characters to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(initializer_list<_CharT> __l)
                      { return this->append(__l.begin(), __l.size()); }
                #endif // C++11
                
                      /**
                       *  @brief  Append a range of characters.
                       *  @param __first  Iterator referencing the first character to append.
                       *  @param __last  Iterator marking the end of the range.
                       *  @return  Reference to this string.
                       *
                       *  Appends characters in the range [__first,__last) to this string.
                       */
                #if __cplusplus >= 201103L
                      template<class _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                #else
                      template<class _InputIterator>
                #endif
                        basic_string&
                        append(_InputIterator __first, _InputIterator __last)
                        { return this->replace(end(), end(), __first, __last); }
                
                      /**
                       *  @brief  Append a single character.
                       *  @param __c  Character to append.
                       */
                      void
                      push_back(_CharT __c)
                      {
                	const size_type __size = this->size();
                	if (__size + 1 > this->capacity())
                	  this->_M_mutate(__size, size_type(0), 0, size_type(1));
                	traits_type::assign(this->_M_data()[__size], __c);
                	this->_M_set_length(__size + 1);
                      }
                
                      /**
                       *  @brief  Set value to contents of another string.
                       *  @param  __str  Source string to use.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      assign(const basic_string& __str)
                      {
                	this->_M_assign(__str);
                	return *this;
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Set value to contents of another string.
                       *  @param  __str  Source string to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets this string to the exact contents of @a __str.
                       *  @a __str is a valid, but unspecified string.
                       */
                      basic_string&
                      assign(basic_string&& __str)
                      {
                	// _GLIBCXX_RESOLVE_LIB_DEFECTS
                	// 2063. Contradictory requirements for string move assignment
                	return *this = std::move(__str);
                      }
                #endif // C++11
                
                      /**
                       *  @brief  Set value to a substring of a string.
                       *  @param __str  The string to use.
                       *  @param __pos  Index of the first character of str.
                       *  @param __n  Number of characters to use.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range if @a pos is not a valid index.
                       *
                       *  This function sets this string to the substring of @a __str
                       *  consisting of @a __n characters at @a __pos.  If @a __n is
                       *  is larger than the number of available characters in @a
                       *  __str, the remainder of @a __str is used.
                       */
                      basic_string&
                      assign(const basic_string& __str, size_type __pos, size_type __n)
                      { return _M_replace(size_type(0), this->size(), __str._M_data()
                			  + __str._M_check(__pos, "basic_string::assign"),
                			  __str._M_limit(__pos, __n)); }
                
                      /**
                       *  @brief  Set value to a C substring.
                       *  @param __s  The C string to use.
                       *  @param __n  Number of characters to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets the value of this string to the first @a __n
                       *  characters of @a __s.  If @a __n is is larger than the number of
                       *  available characters in @a __s, the remainder of @a __s is used.
                       */
                      basic_string&
                      assign(const _CharT* __s, size_type __n)
                      {
                	__glibcxx_requires_string_len(__s, __n);
                	return _M_replace(size_type(0), this->size(), __s, __n);
                      }
                
                      /**
                       *  @brief  Set value to contents of a C string.
                       *  @param __s  The C string to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets the value of this string to the value of @a __s.
                       *  The data is copied, so there is no dependence on @a __s once the
                       *  function returns.
                       */
                      basic_string&
                      assign(const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return _M_replace(size_type(0), this->size(), __s,
                			  traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Set value to multiple characters.
                       *  @param __n  Length of the resulting string.
                       *  @param __c  The character to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets the value of this string to @a __n copies of
                       *  character @a __c.
                       */
                      basic_string&
                      assign(size_type __n, _CharT __c)
                      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
                
                      /**
                       *  @brief  Set value to a range of characters.
                       *  @param __first  Iterator referencing the first character to append.
                       *  @param __last  Iterator marking the end of the range.
                       *  @return  Reference to this string.
                       *
                       *  Sets value of string to characters in the range [__first,__last).
                      */
                #if __cplusplus >= 201103L
                      template<class _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                #else
                      template<class _InputIterator>
                #endif
                        basic_string&
                        assign(_InputIterator __first, _InputIterator __last)
                        { return this->replace(begin(), end(), __first, __last); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Set value to an initializer_list of characters.
                       *  @param __l  The initializer_list of characters to assign.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      assign(initializer_list<_CharT> __l)
                      { return this->assign(__l.begin(), __l.size()); }
                #endif // C++11
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Insert multiple characters.
                       *  @param __p  Const_iterator referencing location in string to
                       *              insert at.
                       *  @param __n  Number of characters to insert
                       *  @param __c  The character to insert.
                       *  @return  Iterator referencing the first inserted char.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts @a __n copies of character @a __c starting at the
                       *  position referenced by iterator @a __p.  If adding
                       *  characters causes the length to exceed max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      iterator
                      insert(const_iterator __p, size_type __n, _CharT __c)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__p >= begin() && __p <= end());
                	const size_type __pos = __p - begin();
                	this->replace(__p, __p, __n, __c);
                	return iterator(this->_M_data() + __pos);
                      }
                #else
                      /**
                       *  @brief  Insert multiple characters.
                       *  @param __p  Iterator referencing location in string to insert at.
                       *  @param __n  Number of characters to insert
                       *  @param __c  The character to insert.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts @a __n copies of character @a __c starting at the
                       *  position referenced by iterator @a __p.  If adding
                       *  characters causes the length to exceed max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      void
                      insert(iterator __p, size_type __n, _CharT __c)
                      {	this->replace(__p, __p, __n, __c);  }
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Insert a range of characters.
                       *  @param __p  Const_iterator referencing location in string to
                       *              insert at.
                       *  @param __beg  Start of range.
                       *  @param __end  End of range.
                       *  @return  Iterator referencing the first inserted char.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts characters in range [beg,end).  If adding characters
                       *  causes the length to exceed max_size(), length_error is
                       *  thrown.  The value of the string doesn't change if an error
                       *  is thrown.
                      */
                      template<class _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                	iterator
                        insert(const_iterator __p, _InputIterator __beg, _InputIterator __end)
                        {
                	  _GLIBCXX_DEBUG_PEDASSERT(__p >= begin() && __p <= end());
                	  const size_type __pos = __p - begin();
                	  this->replace(__p, __p, __beg, __end);
                	  return iterator(this->_M_data() + __pos);
                	}
                #else
                      /**
                       *  @brief  Insert a range of characters.
                       *  @param __p  Iterator referencing location in string to insert at.
                       *  @param __beg  Start of range.
                       *  @param __end  End of range.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts characters in range [__beg,__end).  If adding
                       *  characters causes the length to exceed max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      template<class _InputIterator>
                        void
                        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
                        { this->replace(__p, __p, __beg, __end); }
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Insert an initializer_list of characters.
                       *  @param __p  Iterator referencing location in string to insert at.
                       *  @param __l  The initializer_list of characters to insert.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       */
                      void
                      insert(iterator __p, initializer_list<_CharT> __l)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__p >= begin() && __p <= end());
                	this->insert(__p - begin(), __l.begin(), __l.size());
                      }
                #endif // C++11
                
                      /**
                       *  @brief  Insert value of a string.
                       *  @param __pos1  Iterator referencing location in string to insert at.
                       *  @param __str  The string to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts value of @a __str starting at @a __pos1.  If adding
                       *  characters causes the length to exceed max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      insert(size_type __pos1, const basic_string& __str)
                      { return this->replace(__pos1, size_type(0),
                			     __str._M_data(), __str.size()); }
                
                      /**
                       *  @brief  Insert a substring.
                       *  @param __pos1  Iterator referencing location in string to insert at.
                       *  @param __str  The string to insert.
                       *  @param __pos2  Start of characters in str to insert.
                       *  @param __n  Number of characters to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a pos1 > size() or
                       *  @a __pos2 > @a str.size().
                       *
                       *  Starting at @a pos1, insert @a __n character of @a __str
                       *  beginning with @a __pos2.  If adding characters causes the
                       *  length to exceed max_size(), length_error is thrown.  If @a
                       *  __pos1 is beyond the end of this string or @a __pos2 is
                       *  beyond the end of @a __str, out_of_range is thrown.  The
                       *  value of the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      insert(size_type __pos1, const basic_string& __str,
                	     size_type __pos2, size_type __n)
                      { return this->replace(__pos1, size_type(0), __str._M_data()
                			     + __str._M_check(__pos2, "basic_string::insert"),
                			     __str._M_limit(__pos2, __n)); }
                
                      /**
                       *  @brief  Insert a C substring.
                       *  @param __pos  Iterator referencing location in string to insert at.
                       *  @param __s  The C string to insert.
                       *  @param __n  The number of characters to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a __pos is beyond the end of this
                       *  string.
                       *
                       *  Inserts the first @a __n characters of @a __s starting at @a
                       *  __pos.  If adding characters causes the length to exceed
                       *  max_size(), length_error is thrown.  If @a __pos is beyond
                       *  end(), out_of_range is thrown.  The value of the string
                       *  doesn't change if an error is thrown.
                      */
                      basic_string&
                      insert(size_type __pos, const _CharT* __s, size_type __n)
                      { return this->replace(__pos, size_type(0), __s, __n); }
                
                      /**
                       *  @brief  Insert a C string.
                       *  @param __pos  Iterator referencing location in string to insert at.
                       *  @param __s  The C string to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a pos is beyond the end of this
                       *  string.
                       *
                       *  Inserts the first @a n characters of @a __s starting at @a __pos.  If
                       *  adding characters causes the length to exceed max_size(),
                       *  length_error is thrown.  If @a __pos is beyond end(), out_of_range is
                       *  thrown.  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                      basic_string&
                      insert(size_type __pos, const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->replace(__pos, size_type(0), __s,
                			     traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Insert multiple characters.
                       *  @param __pos  Index in string to insert at.
                       *  @param __n  Number of characters to insert
                       *  @param __c  The character to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a __pos is beyond the end of this
                       *  string.
                       *
                       *  Inserts @a __n copies of character @a __c starting at index
                       *  @a __pos.  If adding characters causes the length to exceed
                       *  max_size(), length_error is thrown.  If @a __pos > length(),
                       *  out_of_range is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      insert(size_type __pos, size_type __n, _CharT __c)
                      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
                			      size_type(0), __n, __c); }
                
                      /**
                       *  @brief  Insert one character.
                       *  @param __p  Iterator referencing position in string to insert at.
                       *  @param __c  The character to insert.
                       *  @return  Iterator referencing newly inserted char.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts character @a __c at position referenced by @a __p.
                       *  If adding character causes the length to exceed max_size(),
                       *  length_error is thrown.  If @a __p is beyond end of string,
                       *  out_of_range is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      iterator
                      insert(__const_iterator __p, _CharT __c)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__p >= begin() && __p <= end());
                	const size_type __pos = __p - begin();
                	_M_replace_aux(__pos, size_type(0), size_type(1), __c);
                	return iterator(_M_data() + __pos);
                      }
                
                      /**
                       *  @brief  Remove characters.
                       *  @param __pos  Index of first character to remove (default 0).
                       *  @param __n  Number of characters to remove (default remainder).
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos is beyond the end of this
                       *  string.
                       *
                       *  Removes @a __n characters from this string starting at @a
                       *  __pos.  The length of the string is reduced by @a __n.  If
                       *  there are < @a __n characters to remove, the remainder of
                       *  the string is truncated.  If @a __p is beyond end of string,
                       *  out_of_range is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      erase(size_type __pos = 0, size_type __n = npos)
                      {
                	this->_M_erase(_M_check(__pos, "basic_string::erase"),
                		       _M_limit(__pos, __n));
                	return *this;
                      }
                
                      /**
                       *  @brief  Remove one character.
                       *  @param __position  Iterator referencing the character to remove.
                       *  @return  iterator referencing same location after removal.
                       *
                       *  Removes the character at @a __position from this string. The value
                       *  of the string doesn't change if an error is thrown.
                      */
                      iterator
                      erase(__const_iterator __position)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__position >= begin()
                				 && __position < end());
                	const size_type __pos = __position - begin();
                	this->_M_erase(__pos, size_type(1));
                	return iterator(_M_data() + __pos);
                      }
                
                      /**
                       *  @brief  Remove a range of characters.
                       *  @param __first  Iterator referencing the first character to remove.
                       *  @param __last  Iterator referencing the end of the range.
                       *  @return  Iterator referencing location of first after removal.
                       *
                       *  Removes the characters in the range [first,last) from this string.
                       *  The value of the string doesn't change if an error is thrown.
                      */
                      iterator
                      erase(__const_iterator __first, __const_iterator __last)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__first >= begin() && __first <= __last
                				 && __last <= end());
                        const size_type __pos = __first - begin();
                	this->_M_erase(__pos, __last - __first);
                	return iterator(this->_M_data() + __pos);
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Remove the last character.
                       *
                       *  The string must be non-empty.
                       */
                      void
                      pop_back() noexcept
                      { _M_erase(size()-1, 1); }
                #endif // C++11
                
                      /**
                       *  @brief  Replace characters with value from another string.
                       *  @param __pos  Index of first character to replace.
                       *  @param __n  Number of characters to be replaced.
                       *  @param __str  String to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos is beyond the end of this
                       *  string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__pos,__pos+__n) from
                       *  this string.  In place, the value of @a __str is inserted.
                       *  If @a __pos is beyond end of string, out_of_range is thrown.
                       *  If the length of the result exceeds max_size(), length_error
                       *  is thrown.  The value of the string doesn't change if an
                       *  error is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n, const basic_string& __str)
                      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
                
                      /**
                       *  @brief  Replace characters with value from another string.
                       *  @param __pos1  Index of first character to replace.
                       *  @param __n1  Number of characters to be replaced.
                       *  @param __str  String to insert.
                       *  @param __pos2  Index of first character of str to use.
                       *  @param __n2  Number of characters from str to use.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a __pos1 > size() or @a __pos2 >
                       *  __str.size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__pos1,__pos1 + n) from this
                       *  string.  In place, the value of @a __str is inserted.  If @a __pos is
                       *  beyond end of string, out_of_range is thrown.  If the length of the
                       *  result exceeds max_size(), length_error is thrown.  The value of the
                       *  string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(size_type __pos1, size_type __n1, const basic_string& __str,
                	      size_type __pos2, size_type __n2)
                      { return this->replace(__pos1, __n1, __str._M_data()
                			     + __str._M_check(__pos2, "basic_string::replace"),
                			     __str._M_limit(__pos2, __n2)); }
                
                      /**
                       *  @brief  Replace characters with value of a C substring.
                       *  @param __pos  Index of first character to replace.
                       *  @param __n1  Number of characters to be replaced.
                       *  @param __s  C string to insert.
                       *  @param __n2  Number of characters from @a s to use.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos1 > size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__pos,__pos + __n1)
                       *  from this string.  In place, the first @a __n2 characters of
                       *  @a __s are inserted, or all of @a __s if @a __n2 is too large.  If
                       *  @a __pos is beyond end of string, out_of_range is thrown.  If
                       *  the length of result exceeds max_size(), length_error is
                       *  thrown.  The value of the string doesn't change if an error
                       *  is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n1, const _CharT* __s,
                	      size_type __n2)
                      {
                	__glibcxx_requires_string_len(__s, __n2);
                	return _M_replace(_M_check(__pos, "basic_string::replace"),
                			  _M_limit(__pos, __n1), __s, __n2);
                      }
                
                      /**
                       *  @brief  Replace characters with value of a C string.
                       *  @param __pos  Index of first character to replace.
                       *  @param __n1  Number of characters to be replaced.
                       *  @param __s  C string to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos > size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__pos,__pos + __n1)
                       *  from this string.  In place, the characters of @a __s are
                       *  inserted.  If @a __pos is beyond end of string, out_of_range
                       *  is thrown.  If the length of result exceeds max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n1, const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->replace(__pos, __n1, __s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Replace characters with multiple characters.
                       *  @param __pos  Index of first character to replace.
                       *  @param __n1  Number of characters to be replaced.
                       *  @param __n2  Number of characters to insert.
                       *  @param __c  Character to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a __pos > size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [pos,pos + n1) from this
                       *  string.  In place, @a __n2 copies of @a __c are inserted.
                       *  If @a __pos is beyond end of string, out_of_range is thrown.
                       *  If the length of result exceeds max_size(), length_error is
                       *  thrown.  The value of the string doesn't change if an error
                       *  is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
                      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
                			      _M_limit(__pos, __n1), __n2, __c); }
                
                      /**
                       *  @brief  Replace range of characters with string.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __str  String value to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  the value of @a __str is inserted.  If the length of result
                       *  exceeds max_size(), length_error is thrown.  The value of
                       *  the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(__const_iterator __i1, __const_iterator __i2,
                	      const basic_string& __str)
                      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
                
                      /**
                       *  @brief  Replace range of characters with C substring.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __s  C string value to insert.
                       *  @param __n  Number of characters from s to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  the first @a __n characters of @a __s are inserted.  If the
                       *  length of result exceeds max_size(), length_error is thrown.
                       *  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                      basic_string&
                      replace(__const_iterator __i1, __const_iterator __i2,
                	      const _CharT* __s, size_type __n)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
                				 && __i2 <= end());
                	return this->replace(__i1 - begin(), __i2 - __i1, __s, __n);
                      }
                
                      /**
                       *  @brief  Replace range of characters with C string.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __s  C string value to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  the characters of @a __s are inserted.  If the length of
                       *  result exceeds max_size(), length_error is thrown.  The
                       *  value of the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(__const_iterator __i1, __const_iterator __i2, const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->replace(__i1, __i2, __s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Replace range of characters with multiple characters
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __n  Number of characters to insert.
                       *  @param __c  Character to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  @a __n copies of @a __c are inserted.  If the length of
                       *  result exceeds max_size(), length_error is thrown.  The
                       *  value of the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(__const_iterator __i1, __const_iterator __i2, size_type __n,
                	      _CharT __c)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
                				 && __i2 <= end());
                	return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __c);
                      }
                
                      /**
                       *  @brief  Replace range of characters with range.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __k1  Iterator referencing start of range to insert.
                       *  @param __k2  Iterator referencing end of range to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  characters in the range [__k1,__k2) are inserted.  If the
                       *  length of result exceeds max_size(), length_error is thrown.
                       *  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                #if __cplusplus >= 201103L
                      template<class _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                        basic_string&
                        replace(const_iterator __i1, const_iterator __i2,
                		_InputIterator __k1, _InputIterator __k2)
                        {
                	  _GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
                				   && __i2 <= end());
                	  __glibcxx_requires_valid_range(__k1, __k2);
                	  return this->_M_replace_dispatch(__i1, __i2, __k1, __k2,
                					   std::__false_type());
                	}
                #else
                      template<class _InputIterator>
                #ifdef _GLIBCXX_DISAMBIGUATE_REPLACE_INST
                        typename __enable_if_not_native_iterator<_InputIterator>::__type
                #else
                        basic_string&
                #endif
                        replace(iterator __i1, iterator __i2,
                		_InputIterator __k1, _InputIterator __k2)
                        {
                	  _GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
                				   && __i2 <= end());
                	  __glibcxx_requires_valid_range(__k1, __k2);
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
                	}
                #endif
                
                      // Specializations for the common case of pointer and iterator:
                      // useful to avoid the overhead of temporary buffering in _M_replace.
                      basic_string&
                      replace(__const_iterator __i1, __const_iterator __i2,
                	      _CharT* __k1, _CharT* __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
                				 && __i2 <= end());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - begin(), __i2 - __i1,
                			     __k1, __k2 - __k1);
                      }
                
                      basic_string&
                      replace(__const_iterator __i1, __const_iterator __i2,
                	      const _CharT* __k1, const _CharT* __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
                				 && __i2 <= end());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - begin(), __i2 - __i1,
                			     __k1, __k2 - __k1);
                      }
                
                      basic_string&
                      replace(__const_iterator __i1, __const_iterator __i2,
                	      iterator __k1, iterator __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
                				 && __i2 <= end());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - begin(), __i2 - __i1,
                			     __k1.base(), __k2 - __k1);
                      }
                
                      basic_string&
                      replace(__const_iterator __i1, __const_iterator __i2,
                	      const_iterator __k1, const_iterator __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
                				 && __i2 <= end());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - begin(), __i2 - __i1,
                			     __k1.base(), __k2 - __k1);
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Replace range of characters with initializer_list.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __l  The initializer_list of characters to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  characters in the range [__k1,__k2) are inserted.  If the
                       *  length of result exceeds max_size(), length_error is thrown.
                       *  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                      basic_string& replace(const_iterator __i1, const_iterator __i2,
                			    initializer_list<_CharT> __l)
                      { return this->replace(__i1, __i2, __l.begin(), __l.end()); }
                #endif // C++11
                
                    private:
                      template<class _Integer>
                	basic_string&
                	_M_replace_dispatch(const_iterator __i1, const_iterator __i2,
                			    _Integer __n, _Integer __val, __true_type)
                        { return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __val); }
                
                      template<class _InputIterator>
                	basic_string&
                	_M_replace_dispatch(const_iterator __i1, const_iterator __i2,
                			    _InputIterator __k1, _InputIterator __k2,
                			    __false_type);
                
                      basic_string&
                      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
                		     _CharT __c);
                
                      basic_string&
                      _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
                		 const size_type __len2);
                
                      basic_string&
                      _M_append(const _CharT* __s, size_type __n);
                
                    public:
                
                      /**
                       *  @brief  Copy substring into C string.
                       *  @param __s  C string to copy value into.
                       *  @param __n  Number of characters to copy.
                       *  @param __pos  Index of first character to copy.
                       *  @return  Number of characters actually copied
                       *  @throw  std::out_of_range  If __pos > size().
                       *
                       *  Copies up to @a __n characters starting at @a __pos into the
                       *  C string @a __s.  If @a __pos is %greater than size(),
                       *  out_of_range is thrown.
                      */
                      size_type
                      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
                
                      /**
                       *  @brief  Swap contents with another string.
                       *  @param __s  String to swap with.
                       *
                       *  Exchanges the contents of this string with that of @a __s in constant
                       *  time.
                      */
                      void
                      swap(basic_string& __s) _GLIBCXX_NOEXCEPT;
                
                      // String operations:
                      /**
                       *  @brief  Return const pointer to null-terminated contents.
                       *
                       *  This is a handle to internal data.  Do not modify or dire things may
                       *  happen.
                      */
                      const _CharT*
                      c_str() const _GLIBCXX_NOEXCEPT
                      { return _M_data(); }
                
                      /**
                       *  @brief  Return const pointer to contents.
                       *
                       *  This is a handle to internal data.  Do not modify or dire things may
                       *  happen.
                      */
                      const _CharT*
                      data() const _GLIBCXX_NOEXCEPT
                      { return _M_data(); }
                
                      /**
                       *  @brief  Return copy of allocator used to construct this string.
                      */
                      allocator_type
                      get_allocator() const _GLIBCXX_NOEXCEPT
                      { return _M_get_allocator(); }
                
                      /**
                       *  @brief  Find position of a C substring.
                       *  @param __s  C string to locate.
                       *  @param __pos  Index of character to search from.
                       *  @param __n  Number of characters from @a s to search for.
                       *  @return  Index of start of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for the first @a
                       *  __n characters in @a __s within this string.  If found,
                       *  returns the index where it begins.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find(const _CharT* __s, size_type __pos, size_type __n) const;
                
                      /**
                       *  @brief  Find position of a string.
                       *  @param __str  String to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of start of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for value of @a __str within
                       *  this string.  If found, returns the index where it begins.  If not
                       *  found, returns npos.
                      */
                      size_type
                      find(const basic_string& __str, size_type __pos = 0) const
                	_GLIBCXX_NOEXCEPT
                      { return this->find(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find position of a C string.
                       *  @param __s  C string to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of start of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for the value of @a
                       *  __s within this string.  If found, returns the index where
                       *  it begins.  If not found, returns npos.
                      */
                      size_type
                      find(const _CharT* __s, size_type __pos = 0) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->find(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find position of a character.
                       *  @param __c  Character to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for @a __c within
                       *  this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      find(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find last position of a string.
                       *  @param __str  String to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of start of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for value of @a
                       *  __str within this string.  If found, returns the index where
                       *  it begins.  If not found, returns npos.
                      */
                      size_type
                      rfind(const basic_string& __str, size_type __pos = npos) const
                	_GLIBCXX_NOEXCEPT
                      { return this->rfind(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find last position of a C substring.
                       *  @param __s  C string to locate.
                       *  @param __pos  Index of character to search back from.
                       *  @param __n  Number of characters from s to search for.
                       *  @return  Index of start of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for the first @a
                       *  __n characters in @a __s within this string.  If found,
                       *  returns the index where it begins.  If not found, returns
                       *  npos.
                      */
                      size_type
                      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
                
                      /**
                       *  @brief  Find last position of a C string.
                       *  @param __s  C string to locate.
                       *  @param __pos  Index of character to start search at (default end).
                       *  @return  Index of start of  last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for the value of
                       *  @a __s within this string.  If found, returns the index
                       *  where it begins.  If not found, returns npos.
                      */
                      size_type
                      rfind(const _CharT* __s, size_type __pos = npos) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->rfind(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find last position of a character.
                       *  @param __c  Character to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for @a __c within
                       *  this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      rfind(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find position of a character of string.
                       *  @param __str  String containing characters to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for one of the
                       *  characters of @a __str within this string.  If found,
                       *  returns the index where it was found.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find_first_of(const basic_string& __str, size_type __pos = 0) const
                	_GLIBCXX_NOEXCEPT
                      { return this->find_first_of(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find position of a character of C substring.
                       *  @param __s  String containing characters to locate.
                       *  @param __pos  Index of character to search from.
                       *  @param __n  Number of characters from s to search for.
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for one of the
                       *  first @a __n characters of @a __s within this string.  If
                       *  found, returns the index where it was found.  If not found,
                       *  returns npos.
                      */
                      size_type
                      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
                
                      /**
                       *  @brief  Find position of a character of C string.
                       *  @param __s  String containing characters to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for one of the
                       *  characters of @a __s within this string.  If found, returns
                       *  the index where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_of(const _CharT* __s, size_type __pos = 0) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_first_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find position of a character.
                       *  @param __c  Character to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for the character
                       *  @a __c within this string.  If found, returns the index
                       *  where it was found.  If not found, returns npos.
                       *
                       *  Note: equivalent to find(__c, __pos).
                      */
                      size_type
                      find_first_of(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT
                      { return this->find(__c, __pos); }
                
                      /**
                       *  @brief  Find last position of a character of string.
                       *  @param __str  String containing characters to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for one of the
                       *  characters of @a __str within this string.  If found,
                       *  returns the index where it was found.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find_last_of(const basic_string& __str, size_type __pos = npos) const
                	_GLIBCXX_NOEXCEPT
                      { return this->find_last_of(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find last position of a character of C substring.
                       *  @param __s  C string containing characters to locate.
                       *  @param __pos  Index of character to search back from.
                       *  @param __n  Number of characters from s to search for.
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for one of the
                       *  first @a __n characters of @a __s within this string.  If
                       *  found, returns the index where it was found.  If not found,
                       *  returns npos.
                      */
                      size_type
                      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
                
                      /**
                       *  @brief  Find last position of a character of C string.
                       *  @param __s  C string containing characters to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for one of the
                       *  characters of @a __s within this string.  If found, returns
                       *  the index where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_last_of(const _CharT* __s, size_type __pos = npos) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_last_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find last position of a character.
                       *  @param __c  Character to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for @a __c within
                       *  this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                       *
                       *  Note: equivalent to rfind(__c, __pos).
                      */
                      size_type
                      find_last_of(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT
                      { return this->rfind(__c, __pos); }
                
                      /**
                       *  @brief  Find position of a character not in string.
                       *  @param __str  String containing characters to avoid.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for a character not contained
                       *  in @a __str within this string.  If found, returns the index where it
                       *  was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
                	_GLIBCXX_NOEXCEPT
                      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find position of a character not in C substring.
                       *  @param __s  C string containing characters to avoid.
                       *  @param __pos  Index of character to search from.
                       *  @param __n  Number of characters from __s to consider.
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for a character not
                       *  contained in the first @a __n characters of @a __s within
                       *  this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(const _CharT* __s, size_type __pos,
                			size_type __n) const;
                
                      /**
                       *  @brief  Find position of a character not in C string.
                       *  @param __s  C string containing characters to avoid.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for a character not
                       *  contained in @a __s within this string.  If found, returns
                       *  the index where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_first_not_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find position of a different character.
                       *  @param __c  Character to avoid.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for a character
                       *  other than @a __c within this string.  If found, returns the
                       *  index where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(_CharT __c, size_type __pos = 0) const
                	_GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find last position of a character not in string.
                       *  @param __str  String containing characters to avoid.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for a character
                       *  not contained in @a __str within this string.  If found,
                       *  returns the index where it was found.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
                	_GLIBCXX_NOEXCEPT
                      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find last position of a character not in C substring.
                       *  @param __s  C string containing characters to avoid.
                       *  @param __pos  Index of character to search back from.
                       *  @param __n  Number of characters from s to consider.
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for a character not
                       *  contained in the first @a __n characters of @a __s within this string.
                       *  If found, returns the index where it was found.  If not found,
                       *  returns npos.
                      */
                      size_type
                      find_last_not_of(const _CharT* __s, size_type __pos,
                		       size_type __n) const;
                      /**
                       *  @brief  Find last position of a character not in C string.
                       *  @param __s  C string containing characters to avoid.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for a character
                       *  not contained in @a __s within this string.  If found,
                       *  returns the index where it was found.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_last_not_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find last position of a different character.
                       *  @param __c  Character to avoid.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for a character other than
                       *  @a __c within this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      find_last_not_of(_CharT __c, size_type __pos = npos) const
                	_GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Get a substring.
                       *  @param __pos  Index of first character (default 0).
                       *  @param __n  Number of characters in substring (default remainder).
                       *  @return  The new string.
                       *  @throw  std::out_of_range  If __pos > size().
                       *
                       *  Construct and return a new string using the @a __n
                       *  characters starting at @a __pos.  If the string is too
                       *  short, use the remainder of the characters.  If @a __pos is
                       *  beyond the end of the string, out_of_range is thrown.
                      */
                      basic_string
                      substr(size_type __pos = 0, size_type __n = npos) const
                      { return basic_string(*this,
                			    _M_check(__pos, "basic_string::substr"), __n); }
                
                      /**
                       *  @brief  Compare to a string.
                       *  @param __str  String to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Returns an integer < 0 if this string is ordered before @a
                       *  __str, 0 if their values are equivalent, or > 0 if this
                       *  string is ordered after @a __str.  Determines the effective
                       *  length rlen of the strings to compare as the smallest of
                       *  size() and str.size().  The function then compares the two
                       *  strings by calling traits::compare(data(), str.data(),rlen).
                       *  If the result of the comparison is nonzero returns it,
                       *  otherwise the shorter one is ordered first.
                      */
                      int
                      compare(const basic_string& __str) const
                      {
                	const size_type __size = this->size();
                	const size_type __osize = __str.size();
                	const size_type __len = std::min(__size, __osize);
                
                	int __r = traits_type::compare(_M_data(), __str.data(), __len);
                	if (!__r)
                	  __r = _S_compare(__size, __osize);
                	return __r;
                      }
                
                      /**
                       *  @brief  Compare substring to a string.
                       *  @param __pos  Index of first character of substring.
                       *  @param __n  Number of characters in substring.
                       *  @param __str  String to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a __n characters
                       *  starting at @a __pos.  Returns an integer < 0 if the
                       *  substring is ordered before @a __str, 0 if their values are
                       *  equivalent, or > 0 if the substring is ordered after @a
                       *  __str.  Determines the effective length rlen of the strings
                       *  to compare as the smallest of the length of the substring
                       *  and @a __str.size().  The function then compares the two
                       *  strings by calling
                       *  traits::compare(substring.data(),str.data(),rlen).  If the
                       *  result of the comparison is nonzero returns it, otherwise
                       *  the shorter one is ordered first.
                      */
                      int
                      compare(size_type __pos, size_type __n, const basic_string& __str) const;
                
                      /**
                       *  @brief  Compare substring to a substring.
                       *  @param __pos1  Index of first character of substring.
                       *  @param __n1  Number of characters in substring.
                       *  @param __str  String to compare against.
                       *  @param __pos2  Index of first character of substring of str.
                       *  @param __n2  Number of characters in substring of str.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a __n1
                       *  characters starting at @a __pos1.  Form the substring of @a
                       *  __str from the @a __n2 characters starting at @a __pos2.
                       *  Returns an integer < 0 if this substring is ordered before
                       *  the substring of @a __str, 0 if their values are equivalent,
                       *  or > 0 if this substring is ordered after the substring of
                       *  @a __str.  Determines the effective length rlen of the
                       *  strings to compare as the smallest of the lengths of the
                       *  substrings.  The function then compares the two strings by
                       *  calling
                       *  traits::compare(substring.data(),str.substr(pos2,n2).data(),rlen).
                       *  If the result of the comparison is nonzero returns it,
                       *  otherwise the shorter one is ordered first.
                      */
                      int
                      compare(size_type __pos1, size_type __n1, const basic_string& __str,
                	      size_type __pos2, size_type __n2) const;
                
                      /**
                       *  @brief  Compare to a C string.
                       *  @param __s  C string to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Returns an integer < 0 if this string is ordered before @a __s, 0 if
                       *  their values are equivalent, or > 0 if this string is ordered after
                       *  @a __s.  Determines the effective length rlen of the strings to
                       *  compare as the smallest of size() and the length of a string
                       *  constructed from @a __s.  The function then compares the two strings
                       *  by calling traits::compare(data(),s,rlen).  If the result of the
                       *  comparison is nonzero returns it, otherwise the shorter one is
                       *  ordered first.
                      */
                      int
                      compare(const _CharT* __s) const;
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 5 String::compare specification questionable
                      /**
                       *  @brief  Compare substring to a C string.
                       *  @param __pos  Index of first character of substring.
                       *  @param __n1  Number of characters in substring.
                       *  @param __s  C string to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a __n1
                       *  characters starting at @a pos.  Returns an integer < 0 if
                       *  the substring is ordered before @a __s, 0 if their values
                       *  are equivalent, or > 0 if the substring is ordered after @a
                       *  __s.  Determines the effective length rlen of the strings to
                       *  compare as the smallest of the length of the substring and
                       *  the length of a string constructed from @a __s.  The
                       *  function then compares the two string by calling
                       *  traits::compare(substring.data(),__s,rlen).  If the result of
                       *  the comparison is nonzero returns it, otherwise the shorter
                       *  one is ordered first.
                      */
                      int
                      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
                
                      /**
                       *  @brief  Compare substring against a character %array.
                       *  @param __pos  Index of first character of substring.
                       *  @param __n1  Number of characters in substring.
                       *  @param __s  character %array to compare against.
                       *  @param __n2  Number of characters of s.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a __n1
                       *  characters starting at @a __pos.  Form a string from the
                       *  first @a __n2 characters of @a __s.  Returns an integer < 0
                       *  if this substring is ordered before the string from @a __s,
                       *  0 if their values are equivalent, or > 0 if this substring
                       *  is ordered after the string from @a __s.  Determines the
                       *  effective length rlen of the strings to compare as the
                       *  smallest of the length of the substring and @a __n2.  The
                       *  function then compares the two strings by calling
                       *  traits::compare(substring.data(),s,rlen).  If the result of
                       *  the comparison is nonzero returns it, otherwise the shorter
                       *  one is ordered first.
                       *
                       *  NB: s must have at least n2 characters, &apos;\\0&apos; has
                       *  no special meaning.
                      */
                      int
                      compare(size_type __pos, size_type __n1, const _CharT* __s,
                	      size_type __n2) const;
                  };
                _GLIBCXX_END_NAMESPACE_CXX11
                #else  // !_GLIBCXX_USE_CXX11_ABI
                  // Reference-counted COW string implentation
                
                  /**
                   *  @class basic_string basic_string.h <string>
                   *  @brief  Managing sequences of characters and character-like objects.
                   *
                   *  @ingroup strings
                   *  @ingroup sequences
                   *
                   *  @tparam _CharT  Type of character
                   *  @tparam _Traits  Traits for character type, defaults to
                   *                   char_traits<_CharT>.
                   *  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.
                   *
                   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
                   *  <a href="tables.html#66">reversible container</a>, and a
                   *  <a href="tables.html#67">sequence</a>.  Of the
                   *  <a href="tables.html#68">optional sequence requirements</a>, only
                   *  @c push_back, @c at, and @c %array access are supported.
                   *
                   *  @doctodo
                   *
                   *
                   *  Documentation?  What's that?
                   *  Nathan Myers <ncm@cantrip.org>.
                   *
                   *  A string looks like this:
                   *
                   *  @code
                   *                                        [_Rep]
                   *                                        _M_length
                   *   [basic_string<char_type>]            _M_capacity
                   *   _M_dataplus                          _M_refcount
                   *   _M_p ---------------->               unnamed array of char_type
                   *  @endcode
                   *
                   *  Where the _M_p points to the first character in the string, and
                   *  you cast it to a pointer-to-_Rep and subtract 1 to get a
                   *  pointer to the header.
                   *
                   *  This approach has the enormous advantage that a string object
                   *  requires only one allocation.  All the ugliness is confined
                   *  within a single %pair of inline functions, which each compile to
                   *  a single @a add instruction: _Rep::_M_data(), and
                   *  string::_M_rep(); and the allocation function which gets a
                   *  block of raw bytes and with room enough and constructs a _Rep
                   *  object at the front.
                   *
                   *  The reason you want _M_data pointing to the character %array and
                   *  not the _Rep is so that the debugger can see the string
                   *  contents. (Probably we should add a non-inline member to get
                   *  the _Rep for the debugger to use, so users can check the actual
                   *  string length.)
                   *
                   *  Note that the _Rep object is a POD so that you can have a
                   *  static <em>empty string</em> _Rep object already @a constructed before
                   *  static constructors have run.  The reference-count encoding is
                   *  chosen so that a 0 indicates one reference, so you never try to
                   *  destroy the empty-string _Rep object.
                   *
                   *  All but the last paragraph is considered pretty conventional
                   *  for a C++ string implementation.
                  */
                  // 21.3  Template class basic_string
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    class basic_string
                    {
                      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;
                
                      // Types:
                    public:
                      typedef _Traits					    traits_type;
                      typedef typename _Traits::char_type		    value_type;
                      typedef _Alloc					    allocator_type;
                      typedef typename _CharT_alloc_type::size_type	    size_type;
                      typedef typename _CharT_alloc_type::difference_type   difference_type;
                      typedef typename _CharT_alloc_type::reference	    reference;
                      typedef typename _CharT_alloc_type::const_reference   const_reference;
                      typedef typename _CharT_alloc_type::pointer	    pointer;
                      typedef typename _CharT_alloc_type::const_pointer	    const_pointer;
                      typedef __gnu_cxx::__normal_iterator<pointer, basic_string>  iterator;
                      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                                            const_iterator;
                      typedef std::reverse_iterator<const_iterator>	const_reverse_iterator;
                      typedef std::reverse_iterator<iterator>		    reverse_iterator;
                
                    private:
                      // _Rep: string representation
                      //   Invariants:
                      //   1. String really contains _M_length + 1 characters: due to 21.3.4
                      //      must be kept null-terminated.
                      //   2. _M_capacity >= _M_length
                      //      Allocated memory is always (_M_capacity + 1) * sizeof(_CharT).
                      //   3. _M_refcount has three states:
                      //      -1: leaked, one reference, no ref-copies allowed, non-const.
                      //       0: one reference, non-const.
                      //     n>0: n + 1 references, operations require a lock, const.
                      //   4. All fields==0 is an empty string, given the extra storage
                      //      beyond-the-end for a null terminator; thus, the shared
                      //      empty string representation needs no constructor.
                
                      struct _Rep_base
                      {
                	size_type		_M_length;
                	size_type		_M_capacity;
                	_Atomic_word		_M_refcount;
                      };
                
                      struct _Rep : _Rep_base
                      {
                	// Types:
                	typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
                
                	// (Public) Data members:
                
                	// The maximum number of individual char_type elements of an
                	// individual string is determined by _S_max_size. This is the
                	// value that will be returned by max_size().  (Whereas npos
                	// is the maximum number of bytes the allocator can allocate.)
                	// If one was to divvy up the theoretical largest size string,
                	// with a terminating character and m _CharT elements, it'd
                	// look like this:
                	// npos = sizeof(_Rep) + (m * sizeof(_CharT)) + sizeof(_CharT)
                	// Solving for m:
                	// m = ((npos - sizeof(_Rep))/sizeof(CharT)) - 1
                	// In addition, this implementation quarters this amount.
                	static const size_type	_S_max_size;
                	static const _CharT	_S_terminal;
                
                	// The following storage is init'd to 0 by the linker, resulting
                        // (carefully) in an empty string with one reference.
                        static size_type _S_empty_rep_storage[];
                
                        static _Rep&
                        _S_empty_rep() _GLIBCXX_NOEXCEPT
                        { 
                	  // NB: Mild hack to avoid strict-aliasing warnings.  Note that
                	  // _S_empty_rep_storage is never modified and the punning should
                	  // be reasonably safe in this case.
                	  void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);
                	  return *reinterpret_cast<_Rep*>(__p);
                	}
                
                        bool
                	_M_is_leaked() const _GLIBCXX_NOEXCEPT
                        { return this->_M_refcount < 0; }
                
                        bool
                	_M_is_shared() const _GLIBCXX_NOEXCEPT
                        { return this->_M_refcount > 0; }
                
                        void
                	_M_set_leaked() _GLIBCXX_NOEXCEPT
                        { this->_M_refcount = -1; }
                
                        void
                	_M_set_sharable() _GLIBCXX_NOEXCEPT
                        { this->_M_refcount = 0; }
                
                	void
                	_M_set_length_and_sharable(size_type __n) _GLIBCXX_NOEXCEPT
                	{
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                	  if (__builtin_expect(this != &_S_empty_rep(), false))
                #endif
                	    {
                	      this->_M_set_sharable();  // One reference.
                	      this->_M_length = __n;
                	      traits_type::assign(this->_M_refdata()[__n], _S_terminal);
                	      // grrr. (per 21.3.4)
                	      // You cannot leave those LWG people alone for a second.
                	    }
                	}
                
                	_CharT*
                	_M_refdata() throw()
                	{ return reinterpret_cast<_CharT*>(this + 1); }
                
                	_CharT*
                	_M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
                	{
                	  return (!_M_is_leaked() && __alloc1 == __alloc2)
                	          ? _M_refcopy() : _M_clone(__alloc1);
                	}
                
                	// Create & Destroy
                	static _Rep*
                	_S_create(size_type, size_type, const _Alloc&);
                
                	void
                	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
                	{
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                	  if (__builtin_expect(this != &_S_empty_rep(), false))
                #endif
                	    {
                	      // Be race-detector-friendly.  For more info see bits/c++config.
                	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
                	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
                							 -1) <= 0)
                		{
                		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
                		  _M_destroy(__a);
                		}
                	    }
                	}  // XXX MT
                
                	void
                	_M_destroy(const _Alloc&) throw();
                
                	_CharT*
                	_M_refcopy() throw()
                	{
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                	  if (__builtin_expect(this != &_S_empty_rep(), false))
                #endif
                            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
                	  return _M_refdata();
                	}  // XXX MT
                
                	_CharT*
                	_M_clone(const _Alloc&, size_type __res = 0);
                      };
                
                      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
                      struct _Alloc_hider : _Alloc
                      {
                	_Alloc_hider(_CharT* __dat, const _Alloc& __a) _GLIBCXX_NOEXCEPT
                	: _Alloc(__a), _M_p(__dat) { }
                
                	_CharT* _M_p; // The actual data.
                      };
                
                    public:
                      // Data Members (public):
                      // NB: This is an unsigned type, and thus represents the maximum
                      // size that the allocator can hold.
                      ///  Value returned by various member functions when they fail.
                      static const size_type	npos = static_cast<size_type>(-1);
                
                    private:
                      // Data Members (private):
                      mutable _Alloc_hider	_M_dataplus;
                
                      _CharT*
                      _M_data() const _GLIBCXX_NOEXCEPT
                      { return  _M_dataplus._M_p; }
                
                      _CharT*
                      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
                      { return (_M_dataplus._M_p = __p); }
                
                      _Rep*
                      _M_rep() const _GLIBCXX_NOEXCEPT
                      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
                
                      // For the internal use we have functions similar to `begin'/`end'
                      // but they do not call _M_leak.
                      iterator
                      _M_ibegin() const _GLIBCXX_NOEXCEPT
                      { return iterator(_M_data()); }
                
                      iterator
                      _M_iend() const _GLIBCXX_NOEXCEPT
                      { return iterator(_M_data() + this->size()); }
                
                      void
                      _M_leak()    // for use in begin() & non-const op[]
                      {
                	if (!_M_rep()->_M_is_leaked())
                	  _M_leak_hard();
                      }
                
                      size_type
                      _M_check(size_type __pos, const char* __s) const
                      {
                	if (__pos > this->size())
                	  __throw_out_of_range_fmt(__N("%s: __pos (which is %zu) > "
                				       "this->size() (which is %zu)"),
                				   __s, __pos, this->size());
                	return __pos;
                      }
                
                      void
                      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
                      {
                	if (this->max_size() - (this->size() - __n1) < __n2)
                	  __throw_length_error(__N(__s));
                      }
                
                      // NB: _M_limit doesn't check for a bad __pos value.
                      size_type
                      _M_limit(size_type __pos, size_type __off) const _GLIBCXX_NOEXCEPT
                      {
                	const bool __testoff =  __off < this->size() - __pos;
                	return __testoff ? __off : this->size() - __pos;
                      }
                
                      // True if _Rep and source do not overlap.
                      bool
                      _M_disjunct(const _CharT* __s) const _GLIBCXX_NOEXCEPT
                      {
                	return (less<const _CharT*>()(__s, _M_data())
                		|| less<const _CharT*>()(_M_data() + this->size(), __s));
                      }
                
                      // When __n = 1 way faster than the general multichar
                      // traits_type::copy/move/assign.
                      static void
                      _M_copy(_CharT* __d, const _CharT* __s, size_type __n) _GLIBCXX_NOEXCEPT
                      {
                	if (__n == 1)
                	  traits_type::assign(*__d, *__s);
                	else
                	  traits_type::copy(__d, __s, __n);
                      }
                
                      static void
                      _M_move(_CharT* __d, const _CharT* __s, size_type __n) _GLIBCXX_NOEXCEPT
                      {
                	if (__n == 1)
                	  traits_type::assign(*__d, *__s);
                	else
                	  traits_type::move(__d, __s, __n);	  
                      }
                
                      static void
                      _M_assign(_CharT* __d, size_type __n, _CharT __c) _GLIBCXX_NOEXCEPT
                      {
                	if (__n == 1)
                	  traits_type::assign(*__d, __c);
                	else
                	  traits_type::assign(__d, __n, __c);	  
                      }
                
                      // _S_copy_chars is a separate template to permit specialization
                      // to optimize for the common case of pointers as iterators.
                      template<class _Iterator>
                        static void
                        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
                        {
                	  for (; __k1 != __k2; ++__k1, ++__p)
                	    traits_type::assign(*__p, *__k1); // These types are off.
                	}
                
                      static void
                      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) _GLIBCXX_NOEXCEPT
                      { _S_copy_chars(__p, __k1.base(), __k2.base()); }
                
                      static void
                      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
                      _GLIBCXX_NOEXCEPT
                      { _S_copy_chars(__p, __k1.base(), __k2.base()); }
                
                      static void
                      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) _GLIBCXX_NOEXCEPT
                      { _M_copy(__p, __k1, __k2 - __k1); }
                
                      static void
                      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
                      _GLIBCXX_NOEXCEPT
                      { _M_copy(__p, __k1, __k2 - __k1); }
                
                      static int
                      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
                      {
                	const difference_type __d = difference_type(__n1 - __n2);
                
                	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
                	  return __gnu_cxx::__numeric_traits<int>::__max;
                	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
                	  return __gnu_cxx::__numeric_traits<int>::__min;
                	else
                	  return int(__d);
                      }
                
                      void
                      _M_mutate(size_type __pos, size_type __len1, size_type __len2);
                
                      void
                      _M_leak_hard();
                
                      static _Rep&
                      _S_empty_rep() _GLIBCXX_NOEXCEPT
                      { return _Rep::_S_empty_rep(); }
                
                    public:
                      // Construct/copy/destroy:
                      // NB: We overload ctors in some cases instead of using default
                      // arguments, per 17.4.4.4 para. 2 item 2.
                
                      /**
                       *  @brief  Default constructor creates an empty string.
                       */
                      basic_string()
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                      : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }
                #else
                      : _M_dataplus(_S_construct(size_type(), _CharT(), _Alloc()), _Alloc()){ }
                #endif
                
                      /**
                       *  @brief  Construct an empty string using allocator @a a.
                       */
                      explicit
                      basic_string(const _Alloc& __a);
                
                      // NB: per LWG issue 42, semantics different from IS:
                      /**
                       *  @brief  Construct string with copy of value of @a str.
                       *  @param  __str  Source string.
                       */
                      basic_string(const basic_string& __str);
                      /**
                       *  @brief  Construct string as copy of a substring.
                       *  @param  __str  Source string.
                       *  @param  __pos  Index of first character to copy from.
                       *  @param  __n  Number of characters to copy (default remainder).
                       */
                      basic_string(const basic_string& __str, size_type __pos,
                		   size_type __n = npos);
                      /**
                       *  @brief  Construct string as copy of a substring.
                       *  @param  __str  Source string.
                       *  @param  __pos  Index of first character to copy from.
                       *  @param  __n  Number of characters to copy.
                       *  @param  __a  Allocator to use.
                       */
                      basic_string(const basic_string& __str, size_type __pos,
                		   size_type __n, const _Alloc& __a);
                
                      /**
                       *  @brief  Construct string initialized by a character %array.
                       *  @param  __s  Source character %array.
                       *  @param  __n  Number of characters to copy.
                       *  @param  __a  Allocator to use (default is default allocator).
                       *
                       *  NB: @a __s must have at least @a __n characters, &apos;\\0&apos;
                       *  has no special meaning.
                       */
                      basic_string(const _CharT* __s, size_type __n,
                		   const _Alloc& __a = _Alloc());
                      /**
                       *  @brief  Construct string as copy of a C string.
                       *  @param  __s  Source C string.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());
                      /**
                       *  @brief  Construct string as multiple characters.
                       *  @param  __n  Number of characters.
                       *  @param  __c  Character to use.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Move construct string.
                       *  @param  __str  Source string.
                       *
                       *  The newly-created string contains the exact contents of @a __str.
                       *  @a __str is a valid, but unspecified string.
                       **/
                      basic_string(basic_string&& __str)
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                      noexcept // FIXME C++11: should always be noexcept.
                #endif
                      : _M_dataplus(__str._M_dataplus)
                      {
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                	__str._M_data(_S_empty_rep()._M_refdata());
                #else
                	__str._M_data(_S_construct(size_type(), _CharT(), get_allocator()));
                #endif
                      }
                
                      /**
                       *  @brief  Construct string from an initializer %list.
                       *  @param  __l  std::initializer_list of characters.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc());
                #endif // C++11
                
                      /**
                       *  @brief  Construct string as copy of a range.
                       *  @param  __beg  Start of range.
                       *  @param  __end  End of range.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                      template<class _InputIterator>
                        basic_string(_InputIterator __beg, _InputIterator __end,
                		     const _Alloc& __a = _Alloc());
                
                      /**
                       *  @brief  Destroy the string instance.
                       */
                      ~basic_string() _GLIBCXX_NOEXCEPT
                      { _M_rep()->_M_dispose(this->get_allocator()); }
                
                      /**
                       *  @brief  Assign the value of @a str to this string.
                       *  @param  __str  Source string.
                       */
                      basic_string&
                      operator=(const basic_string& __str) 
                      { return this->assign(__str); }
                
                      /**
                       *  @brief  Copy contents of @a s into this string.
                       *  @param  __s  Source null-terminated string.
                       */
                      basic_string&
                      operator=(const _CharT* __s) 
                      { return this->assign(__s); }
                
                      /**
                       *  @brief  Set value to string of length 1.
                       *  @param  __c  Source character.
                       *
                       *  Assigning to a character makes this string length 1 and
                       *  (*this)[0] == @a c.
                       */
                      basic_string&
                      operator=(_CharT __c) 
                      { 
                	this->assign(1, __c); 
                	return *this;
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Move assign the value of @a str to this string.
                       *  @param  __str  Source string.
                       *
                       *  The contents of @a str are moved into this string (without copying).
                       *  @a str is a valid, but unspecified string.
                       **/
                      // PR 58265, this should be noexcept.
                      basic_string&
                      operator=(basic_string&& __str)
                      {
                	// NB: DR 1204.
                	this->swap(__str);
                	return *this;
                      }
                
                      /**
                       *  @brief  Set value to string constructed from initializer %list.
                       *  @param  __l  std::initializer_list.
                       */
                      basic_string&
                      operator=(initializer_list<_CharT> __l)
                      {
                	this->assign(__l.begin(), __l.size());
                	return *this;
                      }
                #endif // C++11
                
                      // Iterators:
                      /**
                       *  Returns a read/write iterator that points to the first character in
                       *  the %string.  Unshares the string.
                       */
                      iterator
                      begin() // FIXME C++11: should be noexcept.
                      {
                	_M_leak();
                	return iterator(_M_data());
                      }
                
                      /**
                       *  Returns a read-only (constant) iterator that points to the first
                       *  character in the %string.
                       */
                      const_iterator
                      begin() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(_M_data()); }
                
                      /**
                       *  Returns a read/write iterator that points one past the last
                       *  character in the %string.  Unshares the string.
                       */
                      iterator
                      end() // FIXME C++11: should be noexcept.
                      {
                	_M_leak();
                	return iterator(_M_data() + this->size());
                      }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past the
                       *  last character in the %string.
                       */
                      const_iterator
                      end() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(_M_data() + this->size()); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to the last
                       *  character in the %string.  Iteration is done in reverse element
                       *  order.  Unshares the string.
                       */
                      reverse_iterator
                      rbegin() // FIXME C++11: should be noexcept.
                      { return reverse_iterator(this->end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last character in the %string.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      rbegin() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(this->end()); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to one before the
                       *  first character in the %string.  Iteration is done in reverse
                       *  element order.  Unshares the string.
                       */
                      reverse_iterator
                      rend() // FIXME C++11: should be noexcept.
                      { return reverse_iterator(this->begin()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first character in the %string.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      rend() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(this->begin()); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  Returns a read-only (constant) iterator that points to the first
                       *  character in the %string.
                       */
                      const_iterator
                      cbegin() const noexcept
                      { return const_iterator(this->_M_data()); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past the
                       *  last character in the %string.
                       */
                      const_iterator
                      cend() const noexcept
                      { return const_iterator(this->_M_data() + this->size()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last character in the %string.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      crbegin() const noexcept
                      { return const_reverse_iterator(this->end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first character in the %string.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      crend() const noexcept
                      { return const_reverse_iterator(this->begin()); }
                #endif
                
                    public:
                      // Capacity:
                      ///  Returns the number of characters in the string, not including any
                      ///  null-termination.
                      size_type
                      size() const _GLIBCXX_NOEXCEPT
                      { return _M_rep()->_M_length; }
                
                      ///  Returns the number of characters in the string, not including any
                      ///  null-termination.
                      size_type
                      length() const _GLIBCXX_NOEXCEPT
                      { return _M_rep()->_M_length; }
                
                      ///  Returns the size() of the largest possible %string.
                      size_type
                      max_size() const _GLIBCXX_NOEXCEPT
                      { return _Rep::_S_max_size; }
                
                      /**
                       *  @brief  Resizes the %string to the specified number of characters.
                       *  @param  __n  Number of characters the %string should contain.
                       *  @param  __c  Character to fill any new elements.
                       *
                       *  This function will %resize the %string to the specified
                       *  number of characters.  If the number is smaller than the
                       *  %string's current size the %string is truncated, otherwise
                       *  the %string is extended and new elements are %set to @a __c.
                       */
                      void
                      resize(size_type __n, _CharT __c);
                
                      /**
                       *  @brief  Resizes the %string to the specified number of characters.
                       *  @param  __n  Number of characters the %string should contain.
                       *
                       *  This function will resize the %string to the specified length.  If
                       *  the new size is smaller than the %string's current size the %string
                       *  is truncated, otherwise the %string is extended and new characters
                       *  are default-constructed.  For basic types such as char, this means
                       *  setting them to 0.
                       */
                      void
                      resize(size_type __n)
                      { this->resize(__n, _CharT()); }
                
                #if __cplusplus >= 201103L
                      ///  A non-binding request to reduce capacity() to size().
                      void
                      shrink_to_fit() _GLIBCXX_NOEXCEPT
                      {
                #if __cpp_exceptions
                	if (capacity() > size())
                	  {
                	    try
                	      { reserve(0); }
                	    catch(...)
                	      { }
                	  }
                #endif
                      }
                #endif
                
                      /**
                       *  Returns the total number of characters that the %string can hold
                       *  before needing to allocate more memory.
                       */
                      size_type
                      capacity() const _GLIBCXX_NOEXCEPT
                      { return _M_rep()->_M_capacity; }
                
                      /**
                       *  @brief  Attempt to preallocate enough memory for specified number of
                       *          characters.
                       *  @param  __res_arg  Number of characters required.
                       *  @throw  std::length_error  If @a __res_arg exceeds @c max_size().
                       *
                       *  This function attempts to reserve enough memory for the
                       *  %string to hold the specified number of characters.  If the
                       *  number requested is more than max_size(), length_error is
                       *  thrown.
                       *
                       *  The advantage of this function is that if optimal code is a
                       *  necessity and the user can determine the string length that will be
                       *  required, the user can reserve the memory in %advance, and thus
                       *  prevent a possible reallocation of memory and copying of %string
                       *  data.
                       */
                      void
                      reserve(size_type __res_arg = 0);
                
                      /**
                       *  Erases the string, making it empty.
                       */
                      // PR 56166: this should not throw.
                      void
                      clear()
                      { _M_mutate(0, this->size(), 0); }
                
                      /**
                       *  Returns true if the %string is empty.  Equivalent to 
                       *  <code>*this == ""</code>.
                       */
                      bool
                      empty() const _GLIBCXX_NOEXCEPT
                      { return this->size() == 0; }
                
                      // Element access:
                      /**
                       *  @brief  Subscript access to the data contained in the %string.
                       *  @param  __pos  The index of the character to access.
                       *  @return  Read-only (constant) reference to the character.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)
                       */
                      const_reference
                      operator[] (size_type __pos) const _GLIBCXX_NOEXCEPT
                      {
                	_GLIBCXX_DEBUG_ASSERT(__pos <= size());
                	return _M_data()[__pos];
                      }
                
                      /**
                       *  @brief  Subscript access to the data contained in the %string.
                       *  @param  __pos  The index of the character to access.
                       *  @return  Read/write reference to the character.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)  Unshares the string.
                       */
                      reference
                      operator[](size_type __pos)
                      {
                        // Allow pos == size() both in C++98 mode, as v3 extension,
                	// and in C++11 mode.
                	_GLIBCXX_DEBUG_ASSERT(__pos <= size());
                        // In pedantic mode be strict in C++98 mode.
                	_GLIBCXX_DEBUG_PEDASSERT(__cplusplus >= 201103L || __pos < size());
                	_M_leak();
                	return _M_data()[__pos];
                      }
                
                      /**
                       *  @brief  Provides access to the data contained in the %string.
                       *  @param __n The index of the character to access.
                       *  @return  Read-only (const) reference to the character.
                       *  @throw  std::out_of_range  If @a n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter is
                       *  first checked that it is in the range of the string.  The function
                       *  throws out_of_range if the check fails.
                       */
                      const_reference
                      at(size_type __n) const
                      {
                	if (__n >= this->size())
                	  __throw_out_of_range_fmt(__N("basic_string::at: __n "
                				       "(which is %zu) >= this->size() "
                				       "(which is %zu)"),
                				   __n, this->size());
                	return _M_data()[__n];
                      }
                
                      /**
                       *  @brief  Provides access to the data contained in the %string.
                       *  @param __n The index of the character to access.
                       *  @return  Read/write reference to the character.
                       *  @throw  std::out_of_range  If @a n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter is
                       *  first checked that it is in the range of the string.  The function
                       *  throws out_of_range if the check fails.  Success results in
                       *  unsharing the string.
                       */
                      reference
                      at(size_type __n)
                      {
                	if (__n >= size())
                	  __throw_out_of_range_fmt(__N("basic_string::at: __n "
                				       "(which is %zu) >= this->size() "
                				       "(which is %zu)"),
                				   __n, this->size());
                	_M_leak();
                	return _M_data()[__n];
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  Returns a read/write reference to the data at the first
                       *  element of the %string.
                       */
                      reference
                      front()
                      { return operator[](0); }
                
                      /**
                       *  Returns a read-only (constant) reference to the data at the first
                       *  element of the %string.
                       */
                      const_reference
                      front() const _GLIBCXX_NOEXCEPT
                      { return operator[](0); }
                
                      /**
                       *  Returns a read/write reference to the data at the last
                       *  element of the %string.
                       */
                      reference
                      back()
                      { return operator[](this->size() - 1); }
                
                      /**
                       *  Returns a read-only (constant) reference to the data at the
                       *  last element of the %string.
                       */
                      const_reference
                      back() const _GLIBCXX_NOEXCEPT
                      { return operator[](this->size() - 1); }
                #endif
                
                      // Modifiers:
                      /**
                       *  @brief  Append a string to this string.
                       *  @param __str  The string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(const basic_string& __str)
                      { return this->append(__str); }
                
                      /**
                       *  @brief  Append a C string.
                       *  @param __s  The C string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(const _CharT* __s)
                      { return this->append(__s); }
                
                      /**
                       *  @brief  Append a character.
                       *  @param __c  The character to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(_CharT __c)
                      { 
                	this->push_back(__c);
                	return *this;
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Append an initializer_list of characters.
                       *  @param __l  The initializer_list of characters to be appended.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(initializer_list<_CharT> __l)
                      { return this->append(__l.begin(), __l.size()); }
                #endif // C++11
                
                      /**
                       *  @brief  Append a string to this string.
                       *  @param __str  The string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(const basic_string& __str);
                
                      /**
                       *  @brief  Append a substring.
                       *  @param __str  The string to append.
                       *  @param __pos  Index of the first character of str to append.
                       *  @param __n  The number of characters to append.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range if @a __pos is not a valid index.
                       *
                       *  This function appends @a __n characters from @a __str
                       *  starting at @a __pos to this string.  If @a __n is is larger
                       *  than the number of available characters in @a __str, the
                       *  remainder of @a __str is appended.
                       */
                      basic_string&
                      append(const basic_string& __str, size_type __pos, size_type __n);
                
                      /**
                       *  @brief  Append a C substring.
                       *  @param __s  The C string to append.
                       *  @param __n  The number of characters to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(const _CharT* __s, size_type __n);
                
                      /**
                       *  @brief  Append a C string.
                       *  @param __s  The C string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->append(__s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Append multiple characters.
                       *  @param __n  The number of characters to append.
                       *  @param __c  The character to use.
                       *  @return  Reference to this string.
                       *
                       *  Appends __n copies of __c to this string.
                       */
                      basic_string&
                      append(size_type __n, _CharT __c);
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Append an initializer_list of characters.
                       *  @param __l  The initializer_list of characters to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(initializer_list<_CharT> __l)
                      { return this->append(__l.begin(), __l.size()); }
                #endif // C++11
                
                      /**
                       *  @brief  Append a range of characters.
                       *  @param __first  Iterator referencing the first character to append.
                       *  @param __last  Iterator marking the end of the range.
                       *  @return  Reference to this string.
                       *
                       *  Appends characters in the range [__first,__last) to this string.
                       */
                      template<class _InputIterator>
                        basic_string&
                        append(_InputIterator __first, _InputIterator __last)
                        { return this->replace(_M_iend(), _M_iend(), __first, __last); }
                
                      /**
                       *  @brief  Append a single character.
                       *  @param __c  Character to append.
                       */
                      void
                      push_back(_CharT __c)
                      { 
                	const size_type __len = 1 + this->size();
                	if (__len > this->capacity() || _M_rep()->_M_is_shared())
                	  this->reserve(__len);
                	traits_type::assign(_M_data()[this->size()], __c);
                	_M_rep()->_M_set_length_and_sharable(__len);
                      }
                
                      /**
                       *  @brief  Set value to contents of another string.
                       *  @param  __str  Source string to use.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      assign(const basic_string& __str);
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Set value to contents of another string.
                       *  @param  __str  Source string to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets this string to the exact contents of @a __str.
                       *  @a __str is a valid, but unspecified string.
                       */
                      // PR 58265, this should be noexcept.
                      basic_string&
                      assign(basic_string&& __str)
                      {
                	this->swap(__str);
                	return *this;
                      }
                #endif // C++11
                
                      /**
                       *  @brief  Set value to a substring of a string.
                       *  @param __str  The string to use.
                       *  @param __pos  Index of the first character of str.
                       *  @param __n  Number of characters to use.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range if @a pos is not a valid index.
                       *
                       *  This function sets this string to the substring of @a __str
                       *  consisting of @a __n characters at @a __pos.  If @a __n is
                       *  is larger than the number of available characters in @a
                       *  __str, the remainder of @a __str is used.
                       */
                      basic_string&
                      assign(const basic_string& __str, size_type __pos, size_type __n)
                      { return this->assign(__str._M_data()
                			    + __str._M_check(__pos, "basic_string::assign"),
                			    __str._M_limit(__pos, __n)); }
                
                      /**
                       *  @brief  Set value to a C substring.
                       *  @param __s  The C string to use.
                       *  @param __n  Number of characters to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets the value of this string to the first @a __n
                       *  characters of @a __s.  If @a __n is is larger than the number of
                       *  available characters in @a __s, the remainder of @a __s is used.
                       */
                      basic_string&
                      assign(const _CharT* __s, size_type __n);
                
                      /**
                       *  @brief  Set value to contents of a C string.
                       *  @param __s  The C string to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets the value of this string to the value of @a __s.
                       *  The data is copied, so there is no dependence on @a __s once the
                       *  function returns.
                       */
                      basic_string&
                      assign(const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->assign(__s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Set value to multiple characters.
                       *  @param __n  Length of the resulting string.
                       *  @param __c  The character to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets the value of this string to @a __n copies of
                       *  character @a __c.
                       */
                      basic_string&
                      assign(size_type __n, _CharT __c)
                      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
                
                      /**
                       *  @brief  Set value to a range of characters.
                       *  @param __first  Iterator referencing the first character to append.
                       *  @param __last  Iterator marking the end of the range.
                       *  @return  Reference to this string.
                       *
                       *  Sets value of string to characters in the range [__first,__last).
                      */
                      template<class _InputIterator>
                        basic_string&
                        assign(_InputIterator __first, _InputIterator __last)
                        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Set value to an initializer_list of characters.
                       *  @param __l  The initializer_list of characters to assign.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      assign(initializer_list<_CharT> __l)
                      { return this->assign(__l.begin(), __l.size()); }
                #endif // C++11
                
                      /**
                       *  @brief  Insert multiple characters.
                       *  @param __p  Iterator referencing location in string to insert at.
                       *  @param __n  Number of characters to insert
                       *  @param __c  The character to insert.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts @a __n copies of character @a __c starting at the
                       *  position referenced by iterator @a __p.  If adding
                       *  characters causes the length to exceed max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      void
                      insert(iterator __p, size_type __n, _CharT __c)
                      {	this->replace(__p, __p, __n, __c);  }
                
                      /**
                       *  @brief  Insert a range of characters.
                       *  @param __p  Iterator referencing location in string to insert at.
                       *  @param __beg  Start of range.
                       *  @param __end  End of range.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts characters in range [__beg,__end).  If adding
                       *  characters causes the length to exceed max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      template<class _InputIterator>
                        void
                        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
                        { this->replace(__p, __p, __beg, __end); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Insert an initializer_list of characters.
                       *  @param __p  Iterator referencing location in string to insert at.
                       *  @param __l  The initializer_list of characters to insert.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       */
                      void
                      insert(iterator __p, initializer_list<_CharT> __l)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__p >= _M_ibegin() && __p <= _M_iend());
                	this->insert(__p - _M_ibegin(), __l.begin(), __l.size());
                      }
                #endif // C++11
                
                      /**
                       *  @brief  Insert value of a string.
                       *  @param __pos1  Iterator referencing location in string to insert at.
                       *  @param __str  The string to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts value of @a __str starting at @a __pos1.  If adding
                       *  characters causes the length to exceed max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      insert(size_type __pos1, const basic_string& __str)
                      { return this->insert(__pos1, __str, size_type(0), __str.size()); }
                
                      /**
                       *  @brief  Insert a substring.
                       *  @param __pos1  Iterator referencing location in string to insert at.
                       *  @param __str  The string to insert.
                       *  @param __pos2  Start of characters in str to insert.
                       *  @param __n  Number of characters to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a pos1 > size() or
                       *  @a __pos2 > @a str.size().
                       *
                       *  Starting at @a pos1, insert @a __n character of @a __str
                       *  beginning with @a __pos2.  If adding characters causes the
                       *  length to exceed max_size(), length_error is thrown.  If @a
                       *  __pos1 is beyond the end of this string or @a __pos2 is
                       *  beyond the end of @a __str, out_of_range is thrown.  The
                       *  value of the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      insert(size_type __pos1, const basic_string& __str,
                	     size_type __pos2, size_type __n)
                      { return this->insert(__pos1, __str._M_data()
                			    + __str._M_check(__pos2, "basic_string::insert"),
                			    __str._M_limit(__pos2, __n)); }
                
                      /**
                       *  @brief  Insert a C substring.
                       *  @param __pos  Iterator referencing location in string to insert at.
                       *  @param __s  The C string to insert.
                       *  @param __n  The number of characters to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a __pos is beyond the end of this
                       *  string.
                       *
                       *  Inserts the first @a __n characters of @a __s starting at @a
                       *  __pos.  If adding characters causes the length to exceed
                       *  max_size(), length_error is thrown.  If @a __pos is beyond
                       *  end(), out_of_range is thrown.  The value of the string
                       *  doesn't change if an error is thrown.
                      */
                      basic_string&
                      insert(size_type __pos, const _CharT* __s, size_type __n);
                
                      /**
                       *  @brief  Insert a C string.
                       *  @param __pos  Iterator referencing location in string to insert at.
                       *  @param __s  The C string to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a pos is beyond the end of this
                       *  string.
                       *
                       *  Inserts the first @a n characters of @a __s starting at @a __pos.  If
                       *  adding characters causes the length to exceed max_size(),
                       *  length_error is thrown.  If @a __pos is beyond end(), out_of_range is
                       *  thrown.  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                      basic_string&
                      insert(size_type __pos, const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->insert(__pos, __s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Insert multiple characters.
                       *  @param __pos  Index in string to insert at.
                       *  @param __n  Number of characters to insert
                       *  @param __c  The character to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a __pos is beyond the end of this
                       *  string.
                       *
                       *  Inserts @a __n copies of character @a __c starting at index
                       *  @a __pos.  If adding characters causes the length to exceed
                       *  max_size(), length_error is thrown.  If @a __pos > length(),
                       *  out_of_range is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      insert(size_type __pos, size_type __n, _CharT __c)
                      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
                			      size_type(0), __n, __c); }
                
                      /**
                       *  @brief  Insert one character.
                       *  @param __p  Iterator referencing position in string to insert at.
                       *  @param __c  The character to insert.
                       *  @return  Iterator referencing newly inserted char.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts character @a __c at position referenced by @a __p.
                       *  If adding character causes the length to exceed max_size(),
                       *  length_error is thrown.  If @a __p is beyond end of string,
                       *  out_of_range is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      iterator
                      insert(iterator __p, _CharT __c)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__p >= _M_ibegin() && __p <= _M_iend());
                	const size_type __pos = __p - _M_ibegin();
                	_M_replace_aux(__pos, size_type(0), size_type(1), __c);
                	_M_rep()->_M_set_leaked();
                	return iterator(_M_data() + __pos);
                      }
                
                      /**
                       *  @brief  Remove characters.
                       *  @param __pos  Index of first character to remove (default 0).
                       *  @param __n  Number of characters to remove (default remainder).
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos is beyond the end of this
                       *  string.
                       *
                       *  Removes @a __n characters from this string starting at @a
                       *  __pos.  The length of the string is reduced by @a __n.  If
                       *  there are < @a __n characters to remove, the remainder of
                       *  the string is truncated.  If @a __p is beyond end of string,
                       *  out_of_range is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      erase(size_type __pos = 0, size_type __n = npos)
                      { 
                	_M_mutate(_M_check(__pos, "basic_string::erase"),
                		  _M_limit(__pos, __n), size_type(0));
                	return *this;
                      }
                
                      /**
                       *  @brief  Remove one character.
                       *  @param __position  Iterator referencing the character to remove.
                       *  @return  iterator referencing same location after removal.
                       *
                       *  Removes the character at @a __position from this string. The value
                       *  of the string doesn't change if an error is thrown.
                      */
                      iterator
                      erase(iterator __position)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__position >= _M_ibegin()
                				 && __position < _M_iend());
                	const size_type __pos = __position - _M_ibegin();
                	_M_mutate(__pos, size_type(1), size_type(0));
                	_M_rep()->_M_set_leaked();
                	return iterator(_M_data() + __pos);
                      }
                
                      /**
                       *  @brief  Remove a range of characters.
                       *  @param __first  Iterator referencing the first character to remove.
                       *  @param __last  Iterator referencing the end of the range.
                       *  @return  Iterator referencing location of first after removal.
                       *
                       *  Removes the characters in the range [first,last) from this string.
                       *  The value of the string doesn't change if an error is thrown.
                      */
                      iterator
                      erase(iterator __first, iterator __last);
                 
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Remove the last character.
                       *
                       *  The string must be non-empty.
                       */
                      void
                      pop_back() // FIXME C++11: should be noexcept.
                      { erase(size()-1, 1); }
                #endif // C++11
                
                      /**
                       *  @brief  Replace characters with value from another string.
                       *  @param __pos  Index of first character to replace.
                       *  @param __n  Number of characters to be replaced.
                       *  @param __str  String to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos is beyond the end of this
                       *  string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__pos,__pos+__n) from
                       *  this string.  In place, the value of @a __str is inserted.
                       *  If @a __pos is beyond end of string, out_of_range is thrown.
                       *  If the length of the result exceeds max_size(), length_error
                       *  is thrown.  The value of the string doesn't change if an
                       *  error is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n, const basic_string& __str)
                      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
                
                      /**
                       *  @brief  Replace characters with value from another string.
                       *  @param __pos1  Index of first character to replace.
                       *  @param __n1  Number of characters to be replaced.
                       *  @param __str  String to insert.
                       *  @param __pos2  Index of first character of str to use.
                       *  @param __n2  Number of characters from str to use.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a __pos1 > size() or @a __pos2 >
                       *  __str.size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__pos1,__pos1 + n) from this
                       *  string.  In place, the value of @a __str is inserted.  If @a __pos is
                       *  beyond end of string, out_of_range is thrown.  If the length of the
                       *  result exceeds max_size(), length_error is thrown.  The value of the
                       *  string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(size_type __pos1, size_type __n1, const basic_string& __str,
                	      size_type __pos2, size_type __n2)
                      { return this->replace(__pos1, __n1, __str._M_data()
                			     + __str._M_check(__pos2, "basic_string::replace"),
                			     __str._M_limit(__pos2, __n2)); }
                
                      /**
                       *  @brief  Replace characters with value of a C substring.
                       *  @param __pos  Index of first character to replace.
                       *  @param __n1  Number of characters to be replaced.
                       *  @param __s  C string to insert.
                       *  @param __n2  Number of characters from @a s to use.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos1 > size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__pos,__pos + __n1)
                       *  from this string.  In place, the first @a __n2 characters of
                       *  @a __s are inserted, or all of @a __s if @a __n2 is too large.  If
                       *  @a __pos is beyond end of string, out_of_range is thrown.  If
                       *  the length of result exceeds max_size(), length_error is
                       *  thrown.  The value of the string doesn't change if an error
                       *  is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n1, const _CharT* __s,
                	      size_type __n2);
                
                      /**
                       *  @brief  Replace characters with value of a C string.
                       *  @param __pos  Index of first character to replace.
                       *  @param __n1  Number of characters to be replaced.
                       *  @param __s  C string to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos > size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__pos,__pos + __n1)
                       *  from this string.  In place, the characters of @a __s are
                       *  inserted.  If @a __pos is beyond end of string, out_of_range
                       *  is thrown.  If the length of result exceeds max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n1, const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->replace(__pos, __n1, __s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Replace characters with multiple characters.
                       *  @param __pos  Index of first character to replace.
                       *  @param __n1  Number of characters to be replaced.
                       *  @param __n2  Number of characters to insert.
                       *  @param __c  Character to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a __pos > size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [pos,pos + n1) from this
                       *  string.  In place, @a __n2 copies of @a __c are inserted.
                       *  If @a __pos is beyond end of string, out_of_range is thrown.
                       *  If the length of result exceeds max_size(), length_error is
                       *  thrown.  The value of the string doesn't change if an error
                       *  is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
                      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
                			      _M_limit(__pos, __n1), __n2, __c); }
                
                      /**
                       *  @brief  Replace range of characters with string.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __str  String value to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  the value of @a __str is inserted.  If the length of result
                       *  exceeds max_size(), length_error is thrown.  The value of
                       *  the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(iterator __i1, iterator __i2, const basic_string& __str)
                      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
                
                      /**
                       *  @brief  Replace range of characters with C substring.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __s  C string value to insert.
                       *  @param __n  Number of characters from s to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  the first @a __n characters of @a __s are inserted.  If the
                       *  length of result exceeds max_size(), length_error is thrown.
                       *  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                      basic_string&
                      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				 && __i2 <= _M_iend());
                	return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
                      }
                
                      /**
                       *  @brief  Replace range of characters with C string.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __s  C string value to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  the characters of @a __s are inserted.  If the length of
                       *  result exceeds max_size(), length_error is thrown.  The
                       *  value of the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(iterator __i1, iterator __i2, const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->replace(__i1, __i2, __s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Replace range of characters with multiple characters
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __n  Number of characters to insert.
                       *  @param __c  Character to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  @a __n copies of @a __c are inserted.  If the length of
                       *  result exceeds max_size(), length_error is thrown.  The
                       *  value of the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				 && __i2 <= _M_iend());
                	return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
                      }
                
                      /**
                       *  @brief  Replace range of characters with range.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __k1  Iterator referencing start of range to insert.
                       *  @param __k2  Iterator referencing end of range to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  characters in the range [__k1,__k2) are inserted.  If the
                       *  length of result exceeds max_size(), length_error is thrown.
                       *  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                      template<class _InputIterator>
                        basic_string&
                        replace(iterator __i1, iterator __i2,
                		_InputIterator __k1, _InputIterator __k2)
                        {
                	  _GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				   && __i2 <= _M_iend());
                	  __glibcxx_requires_valid_range(__k1, __k2);
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
                	}
                
                      // Specializations for the common case of pointer and iterator:
                      // useful to avoid the overhead of temporary buffering in _M_replace.
                      basic_string&
                      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				 && __i2 <= _M_iend());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
                			     __k1, __k2 - __k1);
                      }
                
                      basic_string&
                      replace(iterator __i1, iterator __i2,
                	      const _CharT* __k1, const _CharT* __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				 && __i2 <= _M_iend());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
                			     __k1, __k2 - __k1);
                      }
                
                      basic_string&
                      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				 && __i2 <= _M_iend());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
                			     __k1.base(), __k2 - __k1);
                      }
                
                      basic_string&
                      replace(iterator __i1, iterator __i2,
                	      const_iterator __k1, const_iterator __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				 && __i2 <= _M_iend());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
                			     __k1.base(), __k2 - __k1);
                      }
                      
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Replace range of characters with initializer_list.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __l  The initializer_list of characters to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  characters in the range [__k1,__k2) are inserted.  If the
                       *  length of result exceeds max_size(), length_error is thrown.
                       *  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                      basic_string& replace(iterator __i1, iterator __i2,
                			    initializer_list<_CharT> __l)
                      { return this->replace(__i1, __i2, __l.begin(), __l.end()); }
                #endif // C++11
                
                    private:
                      template<class _Integer>
                	basic_string&
                	_M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,
                			    _Integer __val, __true_type)
                        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }
                
                      template<class _InputIterator>
                	basic_string&
                	_M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
                			    _InputIterator __k2, __false_type);
                
                      basic_string&
                      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
                		     _CharT __c);
                
                      basic_string&
                      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
                		      size_type __n2);
                
                      // _S_construct_aux is used to implement the 21.3.1 para 15 which
                      // requires special behaviour if _InIter is an integral type
                      template<class _InIterator>
                        static _CharT*
                        _S_construct_aux(_InIterator __beg, _InIterator __end,
                			 const _Alloc& __a, __false_type)
                	{
                          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
                          return _S_construct(__beg, __end, __a, _Tag());
                	}
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<class _Integer>
                        static _CharT*
                        _S_construct_aux(_Integer __beg, _Integer __end,
                			 const _Alloc& __a, __true_type)
                        { return _S_construct_aux_2(static_cast<size_type>(__beg),
                				    __end, __a); }
                
                      static _CharT*
                      _S_construct_aux_2(size_type __req, _CharT __c, const _Alloc& __a)
                      { return _S_construct(__req, __c, __a); }
                
                      template<class _InIterator>
                        static _CharT*
                        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)
                	{
                	  typedef typename std::__is_integer<_InIterator>::__type _Integral;
                	  return _S_construct_aux(__beg, __end, __a, _Integral());
                        }
                
                      // For Input Iterators, used in istreambuf_iterators, etc.
                      template<class _InIterator>
                        static _CharT*
                         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
                		      input_iterator_tag);
                
                      // For forward_iterators up to random_access_iterators, used for
                      // string::iterator, _CharT*, etc.
                      template<class _FwdIterator>
                        static _CharT*
                        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,
                		     forward_iterator_tag);
                
                      static _CharT*
                      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);
                
                    public:
                
                      /**
                       *  @brief  Copy substring into C string.
                       *  @param __s  C string to copy value into.
                       *  @param __n  Number of characters to copy.
                       *  @param __pos  Index of first character to copy.
                       *  @return  Number of characters actually copied
                       *  @throw  std::out_of_range  If __pos > size().
                       *
                       *  Copies up to @a __n characters starting at @a __pos into the
                       *  C string @a __s.  If @a __pos is %greater than size(),
                       *  out_of_range is thrown.
                      */
                      size_type
                      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
                
                      /**
                       *  @brief  Swap contents with another string.
                       *  @param __s  String to swap with.
                       *
                       *  Exchanges the contents of this string with that of @a __s in constant
                       *  time.
                      */
                      // PR 58265, this should be noexcept.
                      void
                      swap(basic_string& __s);
                
                      // String operations:
                      /**
                       *  @brief  Return const pointer to null-terminated contents.
                       *
                       *  This is a handle to internal data.  Do not modify or dire things may
                       *  happen.
                      */
                      const _CharT*
                      c_str() const _GLIBCXX_NOEXCEPT
                      { return _M_data(); }
                
                      /**
                       *  @brief  Return const pointer to contents.
                       *
                       *  This is a handle to internal data.  Do not modify or dire things may
                       *  happen.
                      */
                      const _CharT*
                      data() const _GLIBCXX_NOEXCEPT
                      { return _M_data(); }
                
                      /**
                       *  @brief  Return copy of allocator used to construct this string.
                      */
                      allocator_type
                      get_allocator() const _GLIBCXX_NOEXCEPT
                      { return _M_dataplus; }
                
                      /**
                       *  @brief  Find position of a C substring.
                       *  @param __s  C string to locate.
                       *  @param __pos  Index of character to search from.
                       *  @param __n  Number of characters from @a s to search for.
                       *  @return  Index of start of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for the first @a
                       *  __n characters in @a __s within this string.  If found,
                       *  returns the index where it begins.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find(const _CharT* __s, size_type __pos, size_type __n) const;
                
                      /**
                       *  @brief  Find position of a string.
                       *  @param __str  String to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of start of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for value of @a __str within
                       *  this string.  If found, returns the index where it begins.  If not
                       *  found, returns npos.
                      */
                      size_type
                      find(const basic_string& __str, size_type __pos = 0) const
                	_GLIBCXX_NOEXCEPT
                      { return this->find(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find position of a C string.
                       *  @param __s  C string to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of start of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for the value of @a
                       *  __s within this string.  If found, returns the index where
                       *  it begins.  If not found, returns npos.
                      */
                      size_type
                      find(const _CharT* __s, size_type __pos = 0) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->find(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find position of a character.
                       *  @param __c  Character to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for @a __c within
                       *  this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      find(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find last position of a string.
                       *  @param __str  String to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of start of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for value of @a
                       *  __str within this string.  If found, returns the index where
                       *  it begins.  If not found, returns npos.
                      */
                      size_type
                      rfind(const basic_string& __str, size_type __pos = npos) const
                	_GLIBCXX_NOEXCEPT
                      { return this->rfind(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find last position of a C substring.
                       *  @param __s  C string to locate.
                       *  @param __pos  Index of character to search back from.
                       *  @param __n  Number of characters from s to search for.
                       *  @return  Index of start of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for the first @a
                       *  __n characters in @a __s within this string.  If found,
                       *  returns the index where it begins.  If not found, returns
                       *  npos.
                      */
                      size_type
                      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
                
                      /**
                       *  @brief  Find last position of a C string.
                       *  @param __s  C string to locate.
                       *  @param __pos  Index of character to start search at (default end).
                       *  @return  Index of start of  last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for the value of
                       *  @a __s within this string.  If found, returns the index
                       *  where it begins.  If not found, returns npos.
                      */
                      size_type
                      rfind(const _CharT* __s, size_type __pos = npos) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->rfind(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find last position of a character.
                       *  @param __c  Character to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for @a __c within
                       *  this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      rfind(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find position of a character of string.
                       *  @param __str  String containing characters to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for one of the
                       *  characters of @a __str within this string.  If found,
                       *  returns the index where it was found.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find_first_of(const basic_string& __str, size_type __pos = 0) const
                	_GLIBCXX_NOEXCEPT
                      { return this->find_first_of(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find position of a character of C substring.
                       *  @param __s  String containing characters to locate.
                       *  @param __pos  Index of character to search from.
                       *  @param __n  Number of characters from s to search for.
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for one of the
                       *  first @a __n characters of @a __s within this string.  If
                       *  found, returns the index where it was found.  If not found,
                       *  returns npos.
                      */
                      size_type
                      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
                
                      /**
                       *  @brief  Find position of a character of C string.
                       *  @param __s  String containing characters to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for one of the
                       *  characters of @a __s within this string.  If found, returns
                       *  the index where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_of(const _CharT* __s, size_type __pos = 0) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_first_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find position of a character.
                       *  @param __c  Character to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for the character
                       *  @a __c within this string.  If found, returns the index
                       *  where it was found.  If not found, returns npos.
                       *
                       *  Note: equivalent to find(__c, __pos).
                      */
                      size_type
                      find_first_of(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT
                      { return this->find(__c, __pos); }
                
                      /**
                       *  @brief  Find last position of a character of string.
                       *  @param __str  String containing characters to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for one of the
                       *  characters of @a __str within this string.  If found,
                       *  returns the index where it was found.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find_last_of(const basic_string& __str, size_type __pos = npos) const
                	_GLIBCXX_NOEXCEPT
                      { return this->find_last_of(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find last position of a character of C substring.
                       *  @param __s  C string containing characters to locate.
                       *  @param __pos  Index of character to search back from.
                       *  @param __n  Number of characters from s to search for.
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for one of the
                       *  first @a __n characters of @a __s within this string.  If
                       *  found, returns the index where it was found.  If not found,
                       *  returns npos.
                      */
                      size_type
                      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
                
                      /**
                       *  @brief  Find last position of a character of C string.
                       *  @param __s  C string containing characters to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for one of the
                       *  characters of @a __s within this string.  If found, returns
                       *  the index where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_last_of(const _CharT* __s, size_type __pos = npos) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_last_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find last position of a character.
                       *  @param __c  Character to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for @a __c within
                       *  this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                       *
                       *  Note: equivalent to rfind(__c, __pos).
                      */
                      size_type
                      find_last_of(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT
                      { return this->rfind(__c, __pos); }
                
                      /**
                       *  @brief  Find position of a character not in string.
                       *  @param __str  String containing characters to avoid.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for a character not contained
                       *  in @a __str within this string.  If found, returns the index where it
                       *  was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
                	_GLIBCXX_NOEXCEPT
                      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find position of a character not in C substring.
                       *  @param __s  C string containing characters to avoid.
                       *  @param __pos  Index of character to search from.
                       *  @param __n  Number of characters from __s to consider.
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for a character not
                       *  contained in the first @a __n characters of @a __s within
                       *  this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(const _CharT* __s, size_type __pos,
                			size_type __n) const;
                
                      /**
                       *  @brief  Find position of a character not in C string.
                       *  @param __s  C string containing characters to avoid.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for a character not
                       *  contained in @a __s within this string.  If found, returns
                       *  the index where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_first_not_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find position of a different character.
                       *  @param __c  Character to avoid.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for a character
                       *  other than @a __c within this string.  If found, returns the
                       *  index where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(_CharT __c, size_type __pos = 0) const
                	_GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find last position of a character not in string.
                       *  @param __str  String containing characters to avoid.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for a character
                       *  not contained in @a __str within this string.  If found,
                       *  returns the index where it was found.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
                	_GLIBCXX_NOEXCEPT
                      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find last position of a character not in C substring.
                       *  @param __s  C string containing characters to avoid.
                       *  @param __pos  Index of character to search back from.
                       *  @param __n  Number of characters from s to consider.
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for a character not
                       *  contained in the first @a __n characters of @a __s within this string.
                       *  If found, returns the index where it was found.  If not found,
                       *  returns npos.
                      */
                      size_type
                      find_last_not_of(const _CharT* __s, size_type __pos,
                		       size_type __n) const;
                      /**
                       *  @brief  Find last position of a character not in C string.
                       *  @param __s  C string containing characters to avoid.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for a character
                       *  not contained in @a __s within this string.  If found,
                       *  returns the index where it was found.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_last_not_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find last position of a different character.
                       *  @param __c  Character to avoid.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for a character other than
                       *  @a __c within this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      find_last_not_of(_CharT __c, size_type __pos = npos) const
                	_GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Get a substring.
                       *  @param __pos  Index of first character (default 0).
                       *  @param __n  Number of characters in substring (default remainder).
                       *  @return  The new string.
                       *  @throw  std::out_of_range  If __pos > size().
                       *
                       *  Construct and return a new string using the @a __n
                       *  characters starting at @a __pos.  If the string is too
                       *  short, use the remainder of the characters.  If @a __pos is
                       *  beyond the end of the string, out_of_range is thrown.
                      */
                      basic_string
                      substr(size_type __pos = 0, size_type __n = npos) const
                      { return basic_string(*this,
                			    _M_check(__pos, "basic_string::substr"), __n); }
                
                      /**
                       *  @brief  Compare to a string.
                       *  @param __str  String to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Returns an integer < 0 if this string is ordered before @a
                       *  __str, 0 if their values are equivalent, or > 0 if this
                       *  string is ordered after @a __str.  Determines the effective
                       *  length rlen of the strings to compare as the smallest of
                       *  size() and str.size().  The function then compares the two
                       *  strings by calling traits::compare(data(), str.data(),rlen).
                       *  If the result of the comparison is nonzero returns it,
                       *  otherwise the shorter one is ordered first.
                      */
                      int
                      compare(const basic_string& __str) const
                      {
                	const size_type __size = this->size();
                	const size_type __osize = __str.size();
                	const size_type __len = std::min(__size, __osize);
                
                	int __r = traits_type::compare(_M_data(), __str.data(), __len);
                	if (!__r)
                	  __r = _S_compare(__size, __osize);
                	return __r;
                      }
                
                      /**
                       *  @brief  Compare substring to a string.
                       *  @param __pos  Index of first character of substring.
                       *  @param __n  Number of characters in substring.
                       *  @param __str  String to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a __n characters
                       *  starting at @a __pos.  Returns an integer < 0 if the
                       *  substring is ordered before @a __str, 0 if their values are
                       *  equivalent, or > 0 if the substring is ordered after @a
                       *  __str.  Determines the effective length rlen of the strings
                       *  to compare as the smallest of the length of the substring
                       *  and @a __str.size().  The function then compares the two
                       *  strings by calling
                       *  traits::compare(substring.data(),str.data(),rlen).  If the
                       *  result of the comparison is nonzero returns it, otherwise
                       *  the shorter one is ordered first.
                      */
                      int
                      compare(size_type __pos, size_type __n, const basic_string& __str) const;
                
                      /**
                       *  @brief  Compare substring to a substring.
                       *  @param __pos1  Index of first character of substring.
                       *  @param __n1  Number of characters in substring.
                       *  @param __str  String to compare against.
                       *  @param __pos2  Index of first character of substring of str.
                       *  @param __n2  Number of characters in substring of str.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a __n1
                       *  characters starting at @a __pos1.  Form the substring of @a
                       *  __str from the @a __n2 characters starting at @a __pos2.
                       *  Returns an integer < 0 if this substring is ordered before
                       *  the substring of @a __str, 0 if their values are equivalent,
                       *  or > 0 if this substring is ordered after the substring of
                       *  @a __str.  Determines the effective length rlen of the
                       *  strings to compare as the smallest of the lengths of the
                       *  substrings.  The function then compares the two strings by
                       *  calling
                       *  traits::compare(substring.data(),str.substr(pos2,n2).data(),rlen).
                       *  If the result of the comparison is nonzero returns it,
                       *  otherwise the shorter one is ordered first.
                      */
                      int
                      compare(size_type __pos1, size_type __n1, const basic_string& __str,
                	      size_type __pos2, size_type __n2) const;
                
                      /**
                       *  @brief  Compare to a C string.
                       *  @param __s  C string to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Returns an integer < 0 if this string is ordered before @a __s, 0 if
                       *  their values are equivalent, or > 0 if this string is ordered after
                       *  @a __s.  Determines the effective length rlen of the strings to
                       *  compare as the smallest of size() and the length of a string
                       *  constructed from @a __s.  The function then compares the two strings
                       *  by calling traits::compare(data(),s,rlen).  If the result of the
                       *  comparison is nonzero returns it, otherwise the shorter one is
                       *  ordered first.
                      */
                      int
                      compare(const _CharT* __s) const;
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 5 String::compare specification questionable
                      /**
                       *  @brief  Compare substring to a C string.
                       *  @param __pos  Index of first character of substring.
                       *  @param __n1  Number of characters in substring.
                       *  @param __s  C string to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a __n1
                       *  characters starting at @a pos.  Returns an integer < 0 if
                       *  the substring is ordered before @a __s, 0 if their values
                       *  are equivalent, or > 0 if the substring is ordered after @a
                       *  __s.  Determines the effective length rlen of the strings to
                       *  compare as the smallest of the length of the substring and
                       *  the length of a string constructed from @a __s.  The
                       *  function then compares the two string by calling
                       *  traits::compare(substring.data(),__s,rlen).  If the result of
                       *  the comparison is nonzero returns it, otherwise the shorter
                       *  one is ordered first.
                      */
                      int
                      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
                
                      /**
                       *  @brief  Compare substring against a character %array.
                       *  @param __pos  Index of first character of substring.
                       *  @param __n1  Number of characters in substring.
                       *  @param __s  character %array to compare against.
                       *  @param __n2  Number of characters of s.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a __n1
                       *  characters starting at @a __pos.  Form a string from the
                       *  first @a __n2 characters of @a __s.  Returns an integer < 0
                       *  if this substring is ordered before the string from @a __s,
                       *  0 if their values are equivalent, or > 0 if this substring
                       *  is ordered after the string from @a __s.  Determines the
                       *  effective length rlen of the strings to compare as the
                       *  smallest of the length of the substring and @a __n2.  The
                       *  function then compares the two strings by calling
                       *  traits::compare(substring.data(),s,rlen).  If the result of
                       *  the comparison is nonzero returns it, otherwise the shorter
                       *  one is ordered first.
                       *
                       *  NB: s must have at least n2 characters, &apos;\\0&apos; has
                       *  no special meaning.
                      */
                      int
                      compare(size_type __pos, size_type __n1, const _CharT* __s,
                	      size_type __n2) const;
                  };
                #endif  // !_GLIBCXX_USE_CXX11_ABI
                
                  // operator+
                  /**
                   *  @brief  Concatenate two strings.
                   *  @param __lhs  First string.
                   *  @param __rhs  Last string.
                   *  @return  New string with value of @a __lhs followed by @a __rhs.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>
                    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    {
                      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
                      __str.append(__rhs);
                      return __str;
                    }
                
                  /**
                   *  @brief  Concatenate C string and string.
                   *  @param __lhs  First string.
                   *  @param __rhs  Last string.
                   *  @return  New string with value of @a __lhs followed by @a __rhs.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT,_Traits,_Alloc>
                    operator+(const _CharT* __lhs,
                	      const basic_string<_CharT,_Traits,_Alloc>& __rhs);
                
                  /**
                   *  @brief  Concatenate character and string.
                   *  @param __lhs  First string.
                   *  @param __rhs  Last string.
                   *  @return  New string with @a __lhs followed by @a __rhs.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT,_Traits,_Alloc>
                    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);
                
                  /**
                   *  @brief  Concatenate string and C string.
                   *  @param __lhs  First string.
                   *  @param __rhs  Last string.
                   *  @return  New string with @a __lhs followed by @a __rhs.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	      const _CharT* __rhs)
                    {
                      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
                      __str.append(__rhs);
                      return __str;
                    }
                
                  /**
                   *  @brief  Concatenate string and character.
                   *  @param __lhs  First string.
                   *  @param __rhs  Last string.
                   *  @return  New string with @a __lhs followed by @a __rhs.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
                    {
                      typedef basic_string<_CharT, _Traits, _Alloc>	__string_type;
                      typedef typename __string_type::size_type		__size_type;
                      __string_type __str(__lhs);
                      __str.append(__size_type(1), __rhs);
                      return __str;
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
                	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return std::move(__lhs.append(__rhs)); }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	      basic_string<_CharT, _Traits, _Alloc>&& __rhs)
                    { return std::move(__rhs.insert(0, __lhs)); }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
                	      basic_string<_CharT, _Traits, _Alloc>&& __rhs)
                    {
                      const auto __size = __lhs.size() + __rhs.size();
                      const bool __cond = (__size > __lhs.capacity()
                			   && __size <= __rhs.capacity());
                      return __cond ? std::move(__rhs.insert(0, __lhs))
                	            : std::move(__lhs.append(__rhs));
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(const _CharT* __lhs,
                	      basic_string<_CharT, _Traits, _Alloc>&& __rhs)
                    { return std::move(__rhs.insert(0, __lhs)); }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(_CharT __lhs,
                	      basic_string<_CharT, _Traits, _Alloc>&& __rhs)
                    { return std::move(__rhs.insert(0, 1, __lhs)); }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
           1 ->     operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
                	      const _CharT* __rhs)
                    { return std::move(__lhs.append(__rhs)); }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
                	      _CharT __rhs)
                    { return std::move(__lhs.append(1, __rhs)); }
                #endif
                
                  // operator ==
                  /**
                   *  @brief  Test equivalence of two strings.
                   *  @param __lhs  First string.
                   *  @param __rhs  Second string.
                   *  @return  True if @a __lhs.compare(@a __rhs) == 0.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __lhs.compare(__rhs) == 0; }
                
                  template<typename _CharT>
                    inline
                    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
                    operator==(const basic_string<_CharT>& __lhs,
                	       const basic_string<_CharT>& __rhs)
                    { return (__lhs.size() == __rhs.size()
                	      && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
                						    __lhs.size())); }
                
                  /**
                   *  @brief  Test equivalence of C string and string.
                   *  @param __lhs  C string.
                   *  @param __rhs  String.
                   *  @return  True if @a __rhs.compare(@a __lhs) == 0.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator==(const _CharT* __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __rhs.compare(__lhs) == 0; }
                
                  /**
                   *  @brief  Test equivalence of string and C string.
                   *  @param __lhs  String.
                   *  @param __rhs  C string.
                   *  @return  True if @a __lhs.compare(@a __rhs) == 0.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const _CharT* __rhs)
                    { return __lhs.compare(__rhs) == 0; }
                
                  // operator !=
                  /**
                   *  @brief  Test difference of two strings.
                   *  @param __lhs  First string.
                   *  @param __rhs  Second string.
                   *  @return  True if @a __lhs.compare(@a __rhs) != 0.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return !(__lhs == __rhs); }
                
                  /**
                   *  @brief  Test difference of C string and string.
                   *  @param __lhs  C string.
                   *  @param __rhs  String.
                   *  @return  True if @a __rhs.compare(@a __lhs) != 0.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator!=(const _CharT* __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return !(__lhs == __rhs); }
                
                  /**
                   *  @brief  Test difference of string and C string.
                   *  @param __lhs  String.
                   *  @param __rhs  C string.
                   *  @return  True if @a __lhs.compare(@a __rhs) != 0.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const _CharT* __rhs)
                    { return !(__lhs == __rhs); }
                
                  // operator <
                  /**
                   *  @brief  Test if string precedes string.
                   *  @param __lhs  First string.
                   *  @param __rhs  Second string.
                   *  @return  True if @a __lhs precedes @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __lhs.compare(__rhs) < 0; }
                
                  /**
                   *  @brief  Test if string precedes C string.
                   *  @param __lhs  String.
                   *  @param __rhs  C string.
                   *  @return  True if @a __lhs precedes @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	      const _CharT* __rhs)
                    { return __lhs.compare(__rhs) < 0; }
                
                  /**
                   *  @brief  Test if C string precedes string.
                   *  @param __lhs  C string.
                   *  @param __rhs  String.
                   *  @return  True if @a __lhs precedes @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator<(const _CharT* __lhs,
                	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __rhs.compare(__lhs) > 0; }
                
                  // operator >
                  /**
                   *  @brief  Test if string follows string.
                   *  @param __lhs  First string.
                   *  @param __rhs  Second string.
                   *  @return  True if @a __lhs follows @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __lhs.compare(__rhs) > 0; }
                
                  /**
                   *  @brief  Test if string follows C string.
                   *  @param __lhs  String.
                   *  @param __rhs  C string.
                   *  @return  True if @a __lhs follows @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	      const _CharT* __rhs)
                    { return __lhs.compare(__rhs) > 0; }
                
                  /**
                   *  @brief  Test if C string follows string.
                   *  @param __lhs  C string.
                   *  @param __rhs  String.
                   *  @return  True if @a __lhs follows @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator>(const _CharT* __lhs,
                	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __rhs.compare(__lhs) < 0; }
                
                  // operator <=
                  /**
                   *  @brief  Test if string doesn't follow string.
                   *  @param __lhs  First string.
                   *  @param __rhs  Second string.
                   *  @return  True if @a __lhs doesn't follow @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __lhs.compare(__rhs) <= 0; }
                
                  /**
                   *  @brief  Test if string doesn't follow C string.
                   *  @param __lhs  String.
                   *  @param __rhs  C string.
                   *  @return  True if @a __lhs doesn't follow @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const _CharT* __rhs)
                    { return __lhs.compare(__rhs) <= 0; }
                
                  /**
                   *  @brief  Test if C string doesn't follow string.
                   *  @param __lhs  C string.
                   *  @param __rhs  String.
                   *  @return  True if @a __lhs doesn't follow @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator<=(const _CharT* __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __rhs.compare(__lhs) >= 0; }
                
                  // operator >=
                  /**
                   *  @brief  Test if string doesn't precede string.
                   *  @param __lhs  First string.
                   *  @param __rhs  Second string.
                   *  @return  True if @a __lhs doesn't precede @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __lhs.compare(__rhs) >= 0; }
                
                  /**
                   *  @brief  Test if string doesn't precede C string.
                   *  @param __lhs  String.
                   *  @param __rhs  C string.
                   *  @return  True if @a __lhs doesn't precede @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const _CharT* __rhs)
                    { return __lhs.compare(__rhs) >= 0; }
                
                  /**
                   *  @brief  Test if C string doesn't precede string.
                   *  @param __lhs  C string.
                   *  @param __rhs  String.
                   *  @return  True if @a __lhs doesn't precede @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator>=(const _CharT* __lhs,
                	     const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __rhs.compare(__lhs) <= 0; }
                
                  /**
                   *  @brief  Swap contents of two strings.
                   *  @param __lhs  First string.
                   *  @param __rhs  Second string.
                   *
                   *  Exchanges the contents of @a __lhs and @a __rhs in constant time.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline void
                    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	 basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { __lhs.swap(__rhs); }
                
                
                  /**
                   *  @brief  Read stream into a string.
                   *  @param __is  Input stream.
                   *  @param __str  Buffer to store into.
                   *  @return  Reference to the input stream.
                   *
                   *  Stores characters from @a __is into @a __str until whitespace is
                   *  found, the end of the stream is encountered, or str.max_size()
                   *  is reached.  If is.width() is non-zero, that is the limit on the
                   *  number of characters stored into @a __str.  Any previous
                   *  contents of @a __str are erased.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_istream<_CharT, _Traits>&
                    operator>>(basic_istream<_CharT, _Traits>& __is,
                	       basic_string<_CharT, _Traits, _Alloc>& __str);
                
                  template<>
                    basic_istream<char>&
                    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
                
                  /**
                   *  @brief  Write string to a stream.
                   *  @param __os  Output stream.
                   *  @param __str  String to write out.
                   *  @return  Reference to the output stream.
                   *
                   *  Output characters of @a __str into os following the same rules as for
                   *  writing a C string.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_ostream<_CharT, _Traits>&
                    operator<<(basic_ostream<_CharT, _Traits>& __os,
                	       const basic_string<_CharT, _Traits, _Alloc>& __str)
                    {
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 586. string inserter not a formatted function
                      return __ostream_insert(__os, __str.data(), __str.size());
                    }
                
                  /**
                   *  @brief  Read a line from stream into a string.
                   *  @param __is  Input stream.
                   *  @param __str  Buffer to store into.
                   *  @param __delim  Character marking end of line.
                   *  @return  Reference to the input stream.
                   *
                   *  Stores characters from @a __is into @a __str until @a __delim is
                   *  found, the end of the stream is encountered, or str.max_size()
                   *  is reached.  Any previous contents of @a __str are erased.  If
                   *  @a __delim is encountered, it is extracted but not stored into
                   *  @a __str.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_istream<_CharT, _Traits>&
                    getline(basic_istream<_CharT, _Traits>& __is,
                	    basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
                
                  /**
                   *  @brief  Read a line from stream into a string.
                   *  @param __is  Input stream.
                   *  @param __str  Buffer to store into.
                   *  @return  Reference to the input stream.
                   *
                   *  Stores characters from is into @a __str until &apos;\n&apos; is
                   *  found, the end of the stream is encountered, or str.max_size()
                   *  is reached.  Any previous contents of @a __str are erased.  If
                   *  end of line is encountered, it is extracted but not stored into
                   *  @a __str.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_istream<_CharT, _Traits>&
                    getline(basic_istream<_CharT, _Traits>& __is,
                	    basic_string<_CharT, _Traits, _Alloc>& __str)
                    { return std::getline(__is, __str, __is.widen('\n')); }
                
                #if __cplusplus >= 201103L
                  /// Read a line from an rvalue stream into a string.
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_istream<_CharT, _Traits>&
                    getline(basic_istream<_CharT, _Traits>&& __is,
                	    basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
                    { return std::getline(__is, __str, __delim); }
                
                  /// Read a line from an rvalue stream into a string.
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_istream<_CharT, _Traits>&
                    getline(basic_istream<_CharT, _Traits>&& __is,
                	    basic_string<_CharT, _Traits, _Alloc>& __str)
                    { return std::getline(__is, __str); }
                #endif
                
                  template<>
                    basic_istream<char>&
                    getline(basic_istream<char>& __in, basic_string<char>& __str,
                	    char __delim);
                
                #ifdef _GLIBCXX_USE_WCHAR_T
                  template<>
                    basic_istream<wchar_t>&
                    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
                	    wchar_t __delim);
                #endif  
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #if __cplusplus >= 201103L && defined(_GLIBCXX_USE_C99)
                
                #include <ext/string_conversions.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                _GLIBCXX_BEGIN_NAMESPACE_CXX11
                
                  // 21.4 Numeric Conversions [string.conversions].
                  inline int
                  stoi(const string& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(),
                					__idx, __base); }
                
                  inline long
                  stol(const string& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(),
                			     __idx, __base); }
                
                  inline unsigned long
                  stoul(const string& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(),
                			     __idx, __base); }
                
                  inline long long
                  stoll(const string& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(),
                			     __idx, __base); }
                
                  inline unsigned long long
                  stoull(const string& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(),
                			     __idx, __base); }
                
                  // NB: strtof vs strtod.
                  inline float
                  stof(const string& __str, size_t* __idx = 0)
                  { return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx); }
                
                  inline double
                  stod(const string& __str, size_t* __idx = 0)
                  { return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx); }
                
                  inline long double
                  stold(const string& __str, size_t* __idx = 0)
                  { return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); }
                
                  // NB: (v)snprintf vs sprintf.
                
                  // DR 1261.
                  inline string
                  to_string(int __val)
                  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(int),
                					   "%d", __val); }
                
                  inline string
                  to_string(unsigned __val)
                  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
                					   4 * sizeof(unsigned),
                					   "%u", __val); }
                
                  inline string
                  to_string(long __val)
                  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(long),
                					   "%ld", __val); }
                
                  inline string
                  to_string(unsigned long __val)
                  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
                					   4 * sizeof(unsigned long),
                					   "%lu", __val); }
                
                  inline string
                  to_string(long long __val)
                  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
                					   4 * sizeof(long long),
                					   "%lld", __val); }
                
                  inline string
                  to_string(unsigned long long __val)
                  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
                					   4 * sizeof(unsigned long long),
                					   "%llu", __val); }
                
                  inline string
                  to_string(float __val)
                  {
                    const int __n = 
                      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
                    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
                					   "%f", __val);
                  }
                
                  inline string
                  to_string(double __val)
                  {
                    const int __n = 
                      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
                    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
                					   "%f", __val);
                  }
                
                  inline string
                  to_string(long double __val)
                  {
                    const int __n = 
                      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
                    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
                					   "%Lf", __val);
                  }
                
                #ifdef _GLIBCXX_USE_WCHAR_T
                  inline int 
                  stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(),
                					__idx, __base); }
                
                  inline long 
                  stol(const wstring& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(),
                			     __idx, __base); }
                
                  inline unsigned long
                  stoul(const wstring& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(),
                			     __idx, __base); }
                
                  inline long long
                  stoll(const wstring& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(),
                			     __idx, __base); }
                
                  inline unsigned long long
                  stoull(const wstring& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(),
                			     __idx, __base); }
                
                  // NB: wcstof vs wcstod.
                  inline float
                  stof(const wstring& __str, size_t* __idx = 0)
                  { return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx); }
                
                  inline double
                  stod(const wstring& __str, size_t* __idx = 0)
                  { return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx); }
                
                  inline long double
                  stold(const wstring& __str, size_t* __idx = 0)
                  { return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx); }
                
                #ifndef _GLIBCXX_HAVE_BROKEN_VSWPRINTF
                  // DR 1261.
                  inline wstring
                  to_wstring(int __val)
                  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(int),
                					    L"%d", __val); }
                
                  inline wstring
                  to_wstring(unsigned __val)
                  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
                					    4 * sizeof(unsigned),
                					    L"%u", __val); }
                
                  inline wstring
                  to_wstring(long __val)
                  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(long),
                					    L"%ld", __val); }
                
                  inline wstring
                  to_wstring(unsigned long __val)
                  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
                					    4 * sizeof(unsigned long),
                					    L"%lu", __val); }
                
                  inline wstring
                  to_wstring(long long __val)
                  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
                					    4 * sizeof(long long),
                					    L"%lld", __val); }
                
                  inline wstring
                  to_wstring(unsigned long long __val)
                  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
                					    4 * sizeof(unsigned long long),
                					    L"%llu", __val); }
                
                  inline wstring
                  to_wstring(float __val)
                  {
                    const int __n =
                      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
                    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
                					    L"%f", __val);
                  }
                
                  inline wstring
                  to_wstring(double __val)
                  {
                    const int __n =
                      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
                    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
                					    L"%f", __val);
                  }
                
                  inline wstring
                  to_wstring(long double __val)
                  {
                    const int __n =
                      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
                    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
                					    L"%Lf", __val);
                  }
                #endif // _GLIBCXX_HAVE_BROKEN_VSWPRINTF
                #endif
                
                _GLIBCXX_END_NAMESPACE_CXX11
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif /* C++11 && _GLIBCXX_USE_C99 ... */
                
                #if __cplusplus >= 201103L
                
                #include <bits/functional_hash.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  // DR 1182.
                
                #ifndef _GLIBCXX_COMPATIBILITY_CXX0X
                  /// std::hash specialization for string.
                  template<>
                    struct hash<string>
                    : public __hash_base<size_t, string>
                    {
                      size_t
                      operator()(const string& __s) const noexcept
                      { return std::_Hash_impl::hash(__s.data(), __s.length()); }
                    };
                
                  template<>
                    struct __is_fast_hash<hash<string>> : std::false_type
                    { };
                
                #ifdef _GLIBCXX_USE_WCHAR_T
                  /// std::hash specialization for wstring.
                  template<>
                    struct hash<wstring>
                    : public __hash_base<size_t, wstring>
                    {
                      size_t
                      operator()(const wstring& __s) const noexcept
                      { return std::_Hash_impl::hash(__s.data(),
                                                     __s.length() * sizeof(wchar_t)); }
                    };
                
                  template<>
                    struct __is_fast_hash<hash<wstring>> : std::false_type
                    { };
                #endif
                #endif /* _GLIBCXX_COMPATIBILITY_CXX0X */
                
                #ifdef _GLIBCXX_USE_C99_STDINT_TR1
                  /// std::hash specialization for u16string.
                  template<>
                    struct hash<u16string>
                    : public __hash_base<size_t, u16string>
                    {
                      size_t
                      operator()(const u16string& __s) const noexcept
                      { return std::_Hash_impl::hash(__s.data(),
                                                     __s.length() * sizeof(char16_t)); }
                    };
                
                  template<>
                    struct __is_fast_hash<hash<u16string>> : std::false_type
                    { };
                
                  /// std::hash specialization for u32string.
                  template<>
                    struct hash<u32string>
                    : public __hash_base<size_t, u32string>
                    {
                      size_t
                      operator()(const u32string& __s) const noexcept
                      { return std::_Hash_impl::hash(__s.data(),
                                                     __s.length() * sizeof(char32_t)); }
                    };
                
                  template<>
                    struct __is_fast_hash<hash<u32string>> : std::false_type
                    { };
                #endif
                
                #if __cplusplus > 201103L
                
                #define __cpp_lib_string_udls 201304
                
                  inline namespace literals
                  {
                  inline namespace string_literals
                  {
                
                    _GLIBCXX_DEFAULT_ABI_TAG
                    inline basic_string<char>
                    operator""s(const char* __str, size_t __len)
                    { return basic_string<char>{__str, __len}; }
                
                #ifdef _GLIBCXX_USE_WCHAR_T
                    _GLIBCXX_DEFAULT_ABI_TAG
                    inline basic_string<wchar_t>
                    operator""s(const wchar_t* __str, size_t __len)
                    { return basic_string<wchar_t>{__str, __len}; }
                #endif
                
                #ifdef _GLIBCXX_USE_C99_STDINT_TR1
                    _GLIBCXX_DEFAULT_ABI_TAG
                    inline basic_string<char16_t>
                    operator""s(const char16_t* __str, size_t __len)
                    { return basic_string<char16_t>{__str, __len}; }
                
                    _GLIBCXX_DEFAULT_ABI_TAG
                    inline basic_string<char32_t>
                    operator""s(const char32_t* __str, size_t __len)
                    { return basic_string<char32_t>{__str, __len}; }
                #endif
                
                  } // inline namespace string_literals
                  } // inline namespace literals
                
                #endif // __cplusplus > 201103L
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif // C++11
                
                #endif /* _BASIC_STRING_H */


Top 10 Lines:

     Line      Count

     4884          1

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

        1   Total number of line executions
     1.00   Average executions per line


*** File /home/chaos/git_reposity/zlib/inftrees.c:
                /* inftrees.c -- generate Huffman trees for efficient decoding
                 * Copyright (C) 1995-2017 Mark Adler
                 * For conditions of distribution and use, see copyright notice in zlib.h
                 */
                
                #include "zutil.h"
                #include "inftrees.h"
                
                #define MAXBITS 15
                
                const char inflate_copyright[] =
                   " inflate 1.2.11 Copyright 1995-2017 Mark Adler ";
                /*
                  If you use the zlib library in a product, an acknowledgment is welcome
                  in the documentation of your product. If for some reason you cannot
                  include such an acknowledgment, I would appreciate that you keep this
                  copyright string in the executable of your product.
                 */
                
                /*
                   Build a set of tables to decode the provided canonical Huffman code.
                   The code lengths are lens[0..codes-1].  The result starts at *table,
                   whose indices are 0..2^bits-1.  work is a writable array of at least
                   lens shorts, which is used as a work area.  type is the type of code
                   to be generated, CODES, LENS, or DISTS.  On return, zero is success,
                   -1 is an invalid code, and +1 means that ENOUGH isn't enough.  table
                   on return points to the next available entry's address.  bits is the
                   requested root table index bits, and on return it is the actual root
                   table index bits.  It will differ if the request is greater than the
                   longest code or if it is less than the shortest code.
                 */
                int ZLIB_INTERNAL inflate_table(type, lens, codes, table, bits, work)
                codetype type;
                unsigned short FAR *lens;
                unsigned codes;
                code FAR * FAR *table;
                unsigned FAR *bits;
                unsigned short FAR *work;
       38370 -> {
                    unsigned len;               /* a code's length in bits */
                    unsigned sym;               /* index of code symbols */
                    unsigned min, max;          /* minimum and maximum code lengths */
                    unsigned root;              /* number of index bits for root table */
                    unsigned curr;              /* number of index bits for current table */
                    unsigned drop;              /* code bits to drop for sub-table */
                    int left;                   /* number of prefix codes available */
                    unsigned used;              /* code entries in table used */
                    unsigned huff;              /* Huffman code */
                    unsigned incr;              /* for incrementing code, index */
                    unsigned fill;              /* index for replicating entries */
                    unsigned low;               /* low bits for current root entry */
                    unsigned mask;              /* mask for low root bits */
                    code here;                  /* table entry for duplication */
                    code FAR *next;             /* next available space in table */
                    const unsigned short FAR *base;     /* base value table to use */
                    const unsigned short FAR *extra;    /* extra bits table to use */
                    unsigned match;             /* use base and extra for symbol >= match */
                    unsigned short count[MAXBITS+1];    /* number of codes of each length */
                    unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
                    static const unsigned short lbase[31] = { /* Length codes 257..285 base */
                        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
                        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
                    static const unsigned short lext[31] = { /* Length codes 257..285 extra */
                        16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
                        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 77, 202};
                    static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
                        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
                        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
                        8193, 12289, 16385, 24577, 0, 0};
                    static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
                        16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
                        23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
                        28, 28, 29, 29, 64, 64};
                
                    /*
                       Process a set of code lengths to create a canonical Huffman code.  The
                       code lengths are lens[0..codes-1].  Each length corresponds to the
                       symbols 0..codes-1.  The Huffman code is generated by first sorting the
                       symbols by length from short to long, and retaining the symbol order
                       for codes with equal lengths.  Then the code starts with all zero bits
                       for the first code of the shortest length, and the codes are integer
                       increments for the same length, and zeros are appended as the length
                       increases.  For the deflate format, these bits are stored backwards
                       from their more natural integer increment ordering, and so when the
                       decoding tables are built in the large loop below, the integer codes
                       are incremented backwards.
                
                       This routine assumes, but does not check, that all of the entries in
                       lens[] are in the range 0..MAXBITS.  The caller must assure this.
                       1..MAXBITS is interpreted as that code length.  zero means that that
                       symbol does not occur in this code.
                
                       The codes are sorted by computing a count of codes for each length,
                       creating from that a table of starting indices for each length in the
                       sorted table, and then entering the symbols in order in the sorted
                       table.  The sorted table is work[], with that space being provided by
                       the caller.
                
                       The length counts are used for other purposes as well, i.e. finding
                       the minimum and maximum length codes, determining if there are any
                       codes at all, checking for a valid set of lengths, and looking ahead
                       at length counts to determine sub-table sizes when building the
                       decoding tables.
                     */
                
                    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
                    for (len = 0; len <= MAXBITS; len++)
                        count[len] = 0;
                    for (sym = 0; sym < codes; sym++)
                        count[lens[sym]]++;
                
                    /* bound code lengths, force root to be within code lengths */
                    root = *bits;
                    for (max = MAXBITS; max >= 1; max--)
                        if (count[max] != 0) break;
                    if (root > max) root = max;
                    if (max == 0) {                     /* no symbols to code at all */
                        here.op = (unsigned char)64;    /* invalid code marker */
                        here.bits = (unsigned char)1;
                        here.val = (unsigned short)0;
                        *(*table)++ = here;             /* make a table to force an error */
                        *(*table)++ = here;
                        *bits = 1;
                        return 0;     /* no symbols, but wait for decoding to report error */
                    }
                    for (min = 1; min < max; min++)
                        if (count[min] != 0) break;
                    if (root < min) root = min;
                
                    /* check for an over-subscribed or incomplete set of lengths */
                    left = 1;
                    for (len = 1; len <= MAXBITS; len++) {
                        left <<= 1;
                        left -= count[len];
                        if (left < 0) return -1;        /* over-subscribed */
                    }
                    if (left > 0 && (type == CODES || max != 1))
                        return -1;                      /* incomplete set */
                
                    /* generate offsets into symbol table for each length for sorting */
                    offs[1] = 0;
                    for (len = 1; len < MAXBITS; len++)
                        offs[len + 1] = offs[len] + count[len];
                
                    /* sort symbols by length, by symbol order within each length */
                    for (sym = 0; sym < codes; sym++)
                        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;
                
                    /*
                       Create and fill in decoding tables.  In this loop, the table being
                       filled is at next and has curr index bits.  The code being used is huff
                       with length len.  That code is converted to an index by dropping drop
                       bits off of the bottom.  For codes where len is less than drop + curr,
                       those top drop + curr - len bits are incremented through all values to
                       fill the table with replicated entries.
                
                       root is the number of index bits for the root table.  When len exceeds
                       root, sub-tables are created pointed to by the root entry with an index
                       of the low root bits of huff.  This is saved in low to check for when a
                       new sub-table should be started.  drop is zero when the root table is
                       being filled, and drop is root when sub-tables are being filled.
                
                       When a new sub-table is needed, it is necessary to look ahead in the
                       code lengths to determine what size sub-table is needed.  The length
                       counts are used for this, and so count[] is decremented as codes are
                       entered in the tables.
                
                       used keeps track of how many table entries have been allocated from the
                       provided *table space.  It is checked for LENS and DIST tables against
                       the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
                       the initial root table size constants.  See the comments in inftrees.h
                       for more information.
                
                       sym increments through all symbols, and the loop terminates when
                       all codes of length max, i.e. all codes, have been processed.  This
                       routine permits incomplete codes, so another loop after this one fills
                       in the rest of the decoding tables with invalid code markers.
                     */
                
                    /* set up for code type */
                    switch (type) {
                    case CODES:
                        base = extra = work;    /* dummy value--not used */
                        match = 20;
                        break;
                    case LENS:
                        base = lbase;
                        extra = lext;
                        match = 257;
                        break;
                    default:    /* DISTS */
                        base = dbase;
                        extra = dext;
                        match = 0;
                    }
                
                    /* initialize state for loop */
                    huff = 0;                   /* starting code */
                    sym = 0;                    /* starting code symbol */
                    len = min;                  /* starting code length */
                    next = *table;              /* current table to fill in */
                    curr = root;                /* current table index bits */
                    drop = 0;                   /* current bits to drop from code for index */
                    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
                    used = 1U << root;          /* use root table entries */
                    mask = used - 1;            /* mask for comparing low */
                
                    /* check available table space */
                    if ((type == LENS && used > ENOUGH_LENS) ||
                        (type == DISTS && used > ENOUGH_DISTS))
                        return 1;
                
                    /* process all codes and make table entries */
                    for (;;) {
                        /* create table entry */
                        here.bits = (unsigned char)(len - drop);
                        if (work[sym] + 1U < match) {
                            here.op = (unsigned char)0;
                            here.val = work[sym];
                        }
                        else if (work[sym] >= match) {
                            here.op = (unsigned char)(extra[work[sym] - match]);
                            here.val = base[work[sym] - match];
                        }
                        else {
                            here.op = (unsigned char)(32 + 64);         /* end of block */
                            here.val = 0;
                        }
                
                        /* replicate for those indices with low len bits equal to huff */
                        incr = 1U << (len - drop);
                        fill = 1U << curr;
                        min = fill;                 /* save offset to next table */
                        do {
                            fill -= incr;
                            next[(huff >> drop) + fill] = here;
                        } while (fill != 0);
                
                        /* backwards increment the len-bit code huff */
                        incr = 1U << (len - 1);
                        while (huff & incr)
                            incr >>= 1;
                        if (incr != 0) {
                            huff &= incr - 1;
                            huff += incr;
                        }
                        else
                            huff = 0;
                
                        /* go to next symbol, update count, len */
                        sym++;
                        if (--(count[len]) == 0) {
                            if (len == max) break;
                            len = lens[work[sym]];
                        }
                
                        /* create new sub-table if needed */
                        if (len > root && (huff & mask) != low) {
                            /* if first time, transition to sub-tables */
                            if (drop == 0)
                                drop = root;
                
                            /* increment past last table */
                            next += min;            /* here min is 1 << curr */
                
                            /* determine length of next table */
                            curr = len - drop;
                            left = (int)(1 << curr);
                            while (curr + drop < max) {
                                left -= count[curr + drop];
                                if (left <= 0) break;
                                curr++;
                                left <<= 1;
                            }
                
                            /* check for enough space */
                            used += 1U << curr;
                            if ((type == LENS && used > ENOUGH_LENS) ||
                                (type == DISTS && used > ENOUGH_DISTS))
                                return 1;
                
                            /* point entry in root table to sub-table */
                            low = huff & mask;
                            (*table)[low].op = (unsigned char)curr;
                            (*table)[low].bits = (unsigned char)root;
                            (*table)[low].val = (unsigned short)(next - *table);
                        }
                    }
                
                    /* fill in remaining table entry if code is incomplete (guaranteed to have
                       at most one remaining entry, since if the code is incomplete, the
                       maximum code length that was allowed to get this far is one bit) */
                    if (huff != 0) {
                        here.op = (unsigned char)64;            /* invalid code marker */
                        here.bits = (unsigned char)(len - drop);
                        here.val = (unsigned short)0;
                        next[huff] = here;
                    }
                
                    /* set return parameters */
                    *table += used;
                    *bits = root;
                    return 0;
                }


Top 10 Lines:

     Line      Count

       39      38370

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

    38370   Total number of line executions
 38370.00   Average executions per line


*** File /usr/include/c++/5/iomanip:
                // Standard stream manipulators -*- C++ -*-
                
                // Copyright (C) 1997-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file include/iomanip
                 *  This is a Standard C++ Library header.
                 */
                
                //
                // ISO C++ 14882: 27.6.3  Standard manipulators
                //
                
                #ifndef _GLIBCXX_IOMANIP
                #define _GLIBCXX_IOMANIP 1
                
                #pragma GCC system_header
                
                #include <bits/c++config.h>
                #include <iosfwd>
                #include <bits/ios_base.h>
                
                #if __cplusplus >= 201103L
                #include <locale>
                #if __cplusplus > 201103L
                #include <bits/quoted_string.h>
                #endif
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  // [27.6.3] standard manipulators
                  // Also see DR 183.
                
                  struct _Resetiosflags { ios_base::fmtflags _M_mask; };
                
                  /**
                   *  @brief  Manipulator for @c setf.
                   *  @param  __mask  A format flags mask.
                   *
                   *  Sent to a stream object, this manipulator resets the specified flags,
                   *  via @e stream.setf(0,__mask).
                  */
                  inline _Resetiosflags 
                  resetiosflags(ios_base::fmtflags __mask)
                  { return { __mask }; }
                
                  template<typename _CharT, typename _Traits>
                    inline basic_istream<_CharT, _Traits>& 
                    operator>>(basic_istream<_CharT, _Traits>& __is, _Resetiosflags __f)
                    { 
                      __is.setf(ios_base::fmtflags(0), __f._M_mask); 
                      return __is; 
                    }
                
                  template<typename _CharT, typename _Traits>
                    inline basic_ostream<_CharT, _Traits>& 
                    operator<<(basic_ostream<_CharT, _Traits>& __os, _Resetiosflags __f)
                    { 
                      __os.setf(ios_base::fmtflags(0), __f._M_mask); 
                      return __os; 
                    }
                
                
                  struct _Setiosflags { ios_base::fmtflags _M_mask; };
                
                  /**
                   *  @brief  Manipulator for @c setf.
                   *  @param  __mask  A format flags mask.
                   *
                   *  Sent to a stream object, this manipulator sets the format flags
                   *  to @a __mask.
                  */
                  inline _Setiosflags 
                  setiosflags(ios_base::fmtflags __mask)
                  { return { __mask }; }
                
                  template<typename _CharT, typename _Traits>
                    inline basic_istream<_CharT, _Traits>& 
                    operator>>(basic_istream<_CharT, _Traits>& __is, _Setiosflags __f)
                    { 
                      __is.setf(__f._M_mask); 
                      return __is; 
                    }
                
                  template<typename _CharT, typename _Traits>
                    inline basic_ostream<_CharT, _Traits>& 
                    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setiosflags __f)
                    { 
                      __os.setf(__f._M_mask); 
                      return __os; 
                    }
                
                
                  struct _Setbase { int _M_base; };
                
                  /**
                   *  @brief  Manipulator for @c setf.
                   *  @param  __base  A numeric base.
                   *
                   *  Sent to a stream object, this manipulator changes the
                   *  @c ios_base::basefield flags to @c oct, @c dec, or @c hex when @a base
                   *  is 8, 10, or 16, accordingly, and to 0 if @a __base is any other value.
                  */
                  inline _Setbase 
                  setbase(int __base)
                  { return { __base }; }
                
                  template<typename _CharT, typename _Traits>
                    inline basic_istream<_CharT, _Traits>& 
                    operator>>(basic_istream<_CharT, _Traits>& __is, _Setbase __f)
                    {
                      __is.setf(__f._M_base ==  8 ? ios_base::oct : 
                		__f._M_base == 10 ? ios_base::dec : 
                		__f._M_base == 16 ? ios_base::hex : 
                		ios_base::fmtflags(0), ios_base::basefield);
                      return __is; 
                    }
                  
                  template<typename _CharT, typename _Traits>
                    inline basic_ostream<_CharT, _Traits>& 
                    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setbase __f)
                    {
                      __os.setf(__f._M_base ==  8 ? ios_base::oct : 
                		__f._M_base == 10 ? ios_base::dec : 
                		__f._M_base == 16 ? ios_base::hex : 
                		ios_base::fmtflags(0), ios_base::basefield);
                      return __os; 
                    }
                  
                
                  template<typename _CharT>
                    struct _Setfill { _CharT _M_c; };
                
                  /**
                   *  @brief  Manipulator for @c fill.
                   *  @param  __c  The new fill character.
                   *
                   *  Sent to a stream object, this manipulator calls @c fill(__c) for that
                   *  object.
                  */
                  template<typename _CharT>
                    inline _Setfill<_CharT>
                    setfill(_CharT __c)
                    { return { __c }; }
                
                  template<typename _CharT, typename _Traits>
                    inline basic_istream<_CharT, _Traits>& 
                    operator>>(basic_istream<_CharT, _Traits>& __is, _Setfill<_CharT> __f)
                    { 
                      __is.fill(__f._M_c); 
                      return __is; 
                    }
                
                  template<typename _CharT, typename _Traits>
                    inline basic_ostream<_CharT, _Traits>& 
                    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setfill<_CharT> __f)
                    { 
                      __os.fill(__f._M_c); 
                      return __os; 
                    }
                
                
                  struct _Setprecision { int _M_n; };
                
                  /**
                   *  @brief  Manipulator for @c precision.
                   *  @param  __n  The new precision.
                   *
                   *  Sent to a stream object, this manipulator calls @c precision(__n) for
                   *  that object.
                  */
                  inline _Setprecision 
                  setprecision(int __n)
           1 ->   { return { __n }; }
                
                  template<typename _CharT, typename _Traits>
                    inline basic_istream<_CharT, _Traits>& 
                    operator>>(basic_istream<_CharT, _Traits>& __is, _Setprecision __f)
                    { 
                      __is.precision(__f._M_n); 
                      return __is; 
                    }
                
                  template<typename _CharT, typename _Traits>
                    inline basic_ostream<_CharT, _Traits>& 
                    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setprecision __f)
                    { 
                      __os.precision(__f._M_n); 
                      return __os; 
                    }
                
                
                  struct _Setw { int _M_n; };
                
                  /**
                   *  @brief  Manipulator for @c width.
                   *  @param  __n  The new width.
                   *
                   *  Sent to a stream object, this manipulator calls @c width(__n) for
                   *  that object.
                  */
                  inline _Setw 
                  setw(int __n)
                  { return { __n }; }
                
                  template<typename _CharT, typename _Traits>
                    inline basic_istream<_CharT, _Traits>& 
                    operator>>(basic_istream<_CharT, _Traits>& __is, _Setw __f)
                    {
                      __is.width(__f._M_n);
                      return __is; 
                    }
                
                  template<typename _CharT, typename _Traits>
                    inline basic_ostream<_CharT, _Traits>& 
                    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setw __f)
                    {
                      __os.width(__f._M_n);
                      return __os; 
                    }
                
                #if __cplusplus >= 201103L
                  
                  template<typename _MoneyT>
                    struct _Get_money { _MoneyT& _M_mon; bool _M_intl; };
                
                  /**
                   *  @brief  Extended manipulator for extracting money.
                   *  @param  __mon  Either long double or a specialization of @c basic_string.
                   *  @param  __intl A bool indicating whether international format 
                   *                 is to be used.
                   *
                   *  Sent to a stream object, this manipulator extracts @a __mon.
                  */
                  template<typename _MoneyT>
                    inline _Get_money<_MoneyT>
                    get_money(_MoneyT& __mon, bool __intl = false)
                    { return { __mon, __intl }; }
                
                  template<typename _CharT, typename _Traits, typename _MoneyT>
                    basic_istream<_CharT, _Traits>&
                    operator>>(basic_istream<_CharT, _Traits>& __is, _Get_money<_MoneyT> __f)
                    {
                      typename basic_istream<_CharT, _Traits>::sentry __cerb(__is, false);
                      if (__cerb)
                	{
                	  ios_base::iostate __err = ios_base::goodbit;
                	  __try
                	    {
                	      typedef istreambuf_iterator<_CharT, _Traits>   _Iter;
                	      typedef money_get<_CharT, _Iter>               _MoneyGet;
                
                	      const _MoneyGet& __mg = use_facet<_MoneyGet>(__is.getloc());
                	      __mg.get(_Iter(__is.rdbuf()), _Iter(), __f._M_intl,
                		       __is, __err, __f._M_mon);
                	    }
                	  __catch(__cxxabiv1::__forced_unwind&)
                	    {
                	      __is._M_setstate(ios_base::badbit);
                	      __throw_exception_again;
                	    }
                	  __catch(...)
                	    { __is._M_setstate(ios_base::badbit); }
                	  if (__err)
                	    __is.setstate(__err);
                	}
                      return __is; 
                    }
                
                
                  template<typename _MoneyT>
                    struct _Put_money { const _MoneyT& _M_mon; bool _M_intl; };
                
                  /**
                   *  @brief  Extended manipulator for inserting money.
                   *  @param  __mon  Either long double or a specialization of @c basic_string.
                   *  @param  __intl A bool indicating whether international format 
                   *                 is to be used.
                   *
                   *  Sent to a stream object, this manipulator inserts @a __mon.
                  */
                  template<typename _MoneyT>
                    inline _Put_money<_MoneyT>
                    put_money(const _MoneyT& __mon, bool __intl = false)
                    { return { __mon, __intl }; }
                
                  template<typename _CharT, typename _Traits, typename _MoneyT>
                    basic_ostream<_CharT, _Traits>& 
                    operator<<(basic_ostream<_CharT, _Traits>& __os, _Put_money<_MoneyT> __f)
                    {
                      typename basic_ostream<_CharT, _Traits>::sentry __cerb(__os);
                      if (__cerb)
                	{
                	  ios_base::iostate __err = ios_base::goodbit;
                	  __try
                	    {
                	      typedef ostreambuf_iterator<_CharT, _Traits>   _Iter;
                	      typedef money_put<_CharT, _Iter>               _MoneyPut;
                
                	      const _MoneyPut& __mp = use_facet<_MoneyPut>(__os.getloc());
                	      if (__mp.put(_Iter(__os.rdbuf()), __f._M_intl, __os,
                			   __os.fill(), __f._M_mon).failed())
                		__err |= ios_base::badbit;
                	    }
                	  __catch(__cxxabiv1::__forced_unwind&)
                	    {
                	      __os._M_setstate(ios_base::badbit);
                	      __throw_exception_again;
                	    }
                	  __catch(...)
                	    { __os._M_setstate(ios_base::badbit); }
                	  if (__err)
                	    __os.setstate(__err);
                	}
                      return __os; 
                    }
                
                  template<typename _CharT>
                    struct _Put_time
                    {
                      const std::tm* _M_tmb;
                      const _CharT* _M_fmt;
                    };
                
                  /**
                   *  @brief  Extended manipulator for formatting time.
                   *
                   *  This manipulator uses time_put::put to format time.
                   *  [ext.manip]
                   *
                   *  @param __tmb  struct tm time data to format.
                   *  @param __fmt  format string.
                   */
                  template<typename _CharT>
                    inline _Put_time<_CharT>
                    put_time(const std::tm* __tmb, const _CharT* __fmt)
                    { return { __tmb, __fmt }; }
                
                  template<typename _CharT, typename _Traits>
                    basic_ostream<_CharT, _Traits>&
                    operator<<(basic_ostream<_CharT, _Traits>& __os, _Put_time<_CharT> __f)
                    {
                      typename basic_ostream<_CharT, _Traits>::sentry __cerb(__os);
                      if (__cerb)
                        {
                          ios_base::iostate __err = ios_base::goodbit;
                          __try
                            {
                              typedef ostreambuf_iterator<_CharT, _Traits>   _Iter;
                              typedef time_put<_CharT, _Iter>                _TimePut;
                
                              const _CharT* const __fmt_end = __f._M_fmt +
                                _Traits::length(__f._M_fmt);
                
                              const _TimePut& __mp = use_facet<_TimePut>(__os.getloc());
                              if (__mp.put(_Iter(__os.rdbuf()), __os, __os.fill(),
                                           __f._M_tmb, __f._M_fmt, __fmt_end).failed())
                                __err |= ios_base::badbit;
                            }
                          __catch(__cxxabiv1::__forced_unwind&)
                            {
                              __os._M_setstate(ios_base::badbit);
                              __throw_exception_again;
                            }
                          __catch(...)
                            { __os._M_setstate(ios_base::badbit); }
                          if (__err)
                            __os.setstate(__err);
                        }
                      return __os;
                    }
                
                  template<typename _CharT>
                    struct _Get_time
                    {
                      std::tm*	    _M_tmb;
                      const _CharT* _M_fmt;
                    };
                
                  /**
                   *  @brief  Extended manipulator for extracting time.
                   *
                   *  This manipulator uses time_get::get to extract time.
                   *  [ext.manip]
                   *
                   *  @param __tmb  struct to extract the time data to.
                   *  @param __fmt  format string.
                   */
                  template<typename _CharT>
                    inline _Get_time<_CharT>
                    get_time(std::tm* __tmb, const _CharT* __fmt)
                    { return { __tmb, __fmt }; }
                
                  template<typename _CharT, typename _Traits>
                    basic_istream<_CharT, _Traits>&
                    operator>>(basic_istream<_CharT, _Traits>& __is, _Get_time<_CharT> __f)
                    {
                      typename basic_istream<_CharT, _Traits>::sentry __cerb(__is, false);
                      if (__cerb)
                        {
                          ios_base::iostate __err = ios_base::goodbit;
                          __try
                            {
                              typedef istreambuf_iterator<_CharT, _Traits>   _Iter;
                              typedef time_get<_CharT, _Iter>                _TimeGet;
                
                              const _CharT* const __fmt_end = __f._M_fmt +
                                _Traits::length(__f._M_fmt);
                
                              const _TimeGet& __mg = use_facet<_TimeGet>(__is.getloc());
                              __mg.get(_Iter(__is.rdbuf()), _Iter(), __is,
                                       __err, __f._M_tmb, __f._M_fmt, __fmt_end);
                            }
                          __catch(__cxxabiv1::__forced_unwind&)
                            {
                              __is._M_setstate(ios_base::badbit);
                              __throw_exception_again;
                            }
                          __catch(...)
                            { __is._M_setstate(ios_base::badbit); }
                          if (__err)
                            __is.setstate(__err);
                        }
                      return __is;
                    }
                
                #if __cplusplus > 201103L
                
                #define __cpp_lib_quoted_string_io 201304
                
                  /**
                   * @brief Manipulator for quoted strings.
                   * @param __string String to quote.
                   * @param __delim  Character to quote string with.
                   * @param __escape Escape character to escape itself or quote character.
                   */
                  template<typename _CharT>
                    inline auto
                    quoted(const _CharT* __string,
                	   _CharT __delim = _CharT('"'), _CharT __escape = _CharT('\\'))
                    {
                      return __detail::_Quoted_string<const _CharT*, _CharT>(__string, __delim,
                							     __escape);
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline auto
                    quoted(const basic_string<_CharT, _Traits, _Alloc>& __string,
                	   _CharT __delim = _CharT('"'), _CharT __escape = _CharT('\\'))
                    {
                      return __detail::_Quoted_string<
                			const basic_string<_CharT, _Traits, _Alloc>&, _CharT>(
                				__string, __delim, __escape);
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline auto
                    quoted(basic_string<_CharT, _Traits, _Alloc>& __string,
                	   _CharT __delim = _CharT('"'), _CharT __escape = _CharT('\\'))
                    {
                      return __detail::_Quoted_string<
                			basic_string<_CharT, _Traits, _Alloc>&, _CharT>(
                				__string, __delim, __escape);
                    }
                
                #endif // __cplusplus > 201103L
                
                #endif // __cplusplus >= 201103L
                
                  // Inhibit implicit instantiations for required instantiations,
                  // which are defined via explicit instantiations elsewhere.  
                  // NB:  This syntax is a GNU extension.
                #if _GLIBCXX_EXTERN_TEMPLATE
                  extern template ostream& operator<<(ostream&, _Setfill<char>);
                  extern template ostream& operator<<(ostream&, _Setiosflags);
                  extern template ostream& operator<<(ostream&, _Resetiosflags);
                  extern template ostream& operator<<(ostream&, _Setbase);
                  extern template ostream& operator<<(ostream&, _Setprecision);
                  extern template ostream& operator<<(ostream&, _Setw);
                  extern template istream& operator>>(istream&, _Setfill<char>);
                  extern template istream& operator>>(istream&, _Setiosflags);
                  extern template istream& operator>>(istream&, _Resetiosflags);
                  extern template istream& operator>>(istream&, _Setbase);
                  extern template istream& operator>>(istream&, _Setprecision);
                  extern template istream& operator>>(istream&, _Setw);
                
                #ifdef _GLIBCXX_USE_WCHAR_T
                  extern template wostream& operator<<(wostream&, _Setfill<wchar_t>);
                  extern template wostream& operator<<(wostream&, _Setiosflags);
                  extern template wostream& operator<<(wostream&, _Resetiosflags);
                  extern template wostream& operator<<(wostream&, _Setbase);
                  extern template wostream& operator<<(wostream&, _Setprecision);
                  extern template wostream& operator<<(wostream&, _Setw);
                  extern template wistream& operator>>(wistream&, _Setfill<wchar_t>);
                  extern template wistream& operator>>(wistream&, _Setiosflags);
                  extern template wistream& operator>>(wistream&, _Resetiosflags);
                  extern template wistream& operator>>(wistream&, _Setbase);
                  extern template wistream& operator>>(wistream&, _Setprecision);
                  extern template wistream& operator>>(wistream&, _Setw);
                #endif
                #endif
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif /* _GLIBCXX_IOMANIP */


Top 10 Lines:

     Line      Count

      196          1

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

        1   Total number of line executions
     1.00   Average executions per line


*** File /home/chaos/git_reposity/zlib/zutil.c:
                /* zutil.c -- target dependent utility functions for the compression library
                 * Copyright (C) 1995-2017 Jean-loup Gailly
                 * For conditions of distribution and use, see copyright notice in zlib.h
                 */
                
                /* @(#) $Id$ */
                
                #include "zutil.h"
                #ifndef Z_SOLO
                #  include "gzguts.h"
                #endif
                
                z_const char * const z_errmsg[10] = {
                    (z_const char *)"need dictionary",     /* Z_NEED_DICT       2  */
                    (z_const char *)"stream end",          /* Z_STREAM_END      1  */
                    (z_const char *)"",                    /* Z_OK              0  */
                    (z_const char *)"file error",          /* Z_ERRNO         (-1) */
                    (z_const char *)"stream error",        /* Z_STREAM_ERROR  (-2) */
                    (z_const char *)"data error",          /* Z_DATA_ERROR    (-3) */
                    (z_const char *)"insufficient memory", /* Z_MEM_ERROR     (-4) */
                    (z_const char *)"buffer error",        /* Z_BUF_ERROR     (-5) */
                    (z_const char *)"incompatible version",/* Z_VERSION_ERROR (-6) */
                    (z_const char *)""
                };
                
                
                const char * ZEXPORT zlibVersion()
       ##### -> {
                    return ZLIB_VERSION;
                }
                
                uLong ZEXPORT zlibCompileFlags()
       ##### -> {
                    uLong flags;
                
                    flags = 0;
                    switch ((int)(sizeof(uInt))) {
                    case 2:     break;
                    case 4:     flags += 1;     break;
                    case 8:     flags += 2;     break;
                    default:    flags += 3;
                    }
                    switch ((int)(sizeof(uLong))) {
                    case 2:     break;
                    case 4:     flags += 1 << 2;        break;
                    case 8:     flags += 2 << 2;        break;
                    default:    flags += 3 << 2;
                    }
                    switch ((int)(sizeof(voidpf))) {
                    case 2:     break;
                    case 4:     flags += 1 << 4;        break;
                    case 8:     flags += 2 << 4;        break;
                    default:    flags += 3 << 4;
                    }
                    switch ((int)(sizeof(z_off_t))) {
                    case 2:     break;
                    case 4:     flags += 1 << 6;        break;
                    case 8:     flags += 2 << 6;        break;
                    default:    flags += 3 << 6;
                    }
                #ifdef ZLIB_DEBUG
                    flags += 1 << 8;
                #endif
                #if defined(ASMV) || defined(ASMINF)
                    flags += 1 << 9;
                #endif
                #ifdef ZLIB_WINAPI
                    flags += 1 << 10;
                #endif
                #ifdef BUILDFIXED
                    flags += 1 << 12;
                #endif
                #ifdef DYNAMIC_CRC_TABLE
                    flags += 1 << 13;
                #endif
                #ifdef NO_GZCOMPRESS
                    flags += 1L << 16;
                #endif
                #ifdef NO_GZIP
                    flags += 1L << 17;
                #endif
                #ifdef PKZIP_BUG_WORKAROUND
                    flags += 1L << 20;
                #endif
                #ifdef FASTEST
                    flags += 1L << 21;
                #endif
                #if defined(STDC) || defined(Z_HAVE_STDARG_H)
                #  ifdef NO_vsnprintf
                    flags += 1L << 25;
                #    ifdef HAS_vsprintf_void
                    flags += 1L << 26;
                #    endif
                #  else
                #    ifdef HAS_vsnprintf_void
                    flags += 1L << 26;
                #    endif
                #  endif
                #else
                    flags += 1L << 24;
                #  ifdef NO_snprintf
                    flags += 1L << 25;
                #    ifdef HAS_sprintf_void
                    flags += 1L << 26;
                #    endif
                #  else
                #    ifdef HAS_snprintf_void
                    flags += 1L << 26;
                #    endif
                #  endif
                #endif
                    return flags;
                }
                
                #ifdef ZLIB_DEBUG
                #include <stdlib.h>
                #  ifndef verbose
                #    define verbose 0
                #  endif
                int ZLIB_INTERNAL z_verbose = verbose;
                
                void ZLIB_INTERNAL z_error (m)
                    char *m;
       ##### -> {
                    fprintf(stderr, "%s\n", m);
                    exit(1);
                }
                #endif
                
                /* exported to allow conversion of error code to string for compress() and
                 * uncompress()
                 */
                const char * ZEXPORT zError(err)
                    int err;
       ##### -> {
                    return ERR_MSG(err);
                }
                
                #if defined(_WIN32_WCE)
                    /* The Microsoft C Run-Time Library for Windows CE doesn't have
                     * errno.  We define it as a global variable to simplify porting.
                     * Its value is always 0 and should not be used.
                     */
                    int errno = 0;
                #endif
                
                #ifndef HAVE_MEMCPY
                
                void ZLIB_INTERNAL zmemcpy(dest, source, len)
                    Bytef* dest;
                    const Bytef* source;
                    uInt  len;
                {
                    if (len == 0) return;
                    do {
                        *dest++ = *source++; /* ??? to be unrolled */
                    } while (--len != 0);
                }
                
                int ZLIB_INTERNAL zmemcmp(s1, s2, len)
                    const Bytef* s1;
                    const Bytef* s2;
                    uInt  len;
                {
                    uInt j;
                
                    for (j = 0; j < len; j++) {
                        if (s1[j] != s2[j]) return 2*(s1[j] > s2[j])-1;
                    }
                    return 0;
                }
                
                void ZLIB_INTERNAL zmemzero(dest, len)
                    Bytef* dest;
                    uInt  len;
                {
                    if (len == 0) return;
                    do {
                        *dest++ = 0;  /* ??? to be unrolled */
                    } while (--len != 0);
                }
                #endif
                
                #ifndef Z_SOLO
                
                #ifdef SYS16BIT
                
                #ifdef __TURBOC__
                /* Turbo C in 16-bit mode */
                
                #  define MY_ZCALLOC
                
                /* Turbo C malloc() does not allow dynamic allocation of 64K bytes
                 * and farmalloc(64K) returns a pointer with an offset of 8, so we
                 * must fix the pointer. Warning: the pointer must be put back to its
                 * original form in order to free it, use zcfree().
                 */
                
                #define MAX_PTR 10
                /* 10*64K = 640K */
                
                local int next_ptr = 0;
                
                typedef struct ptr_table_s {
                    voidpf org_ptr;
                    voidpf new_ptr;
                } ptr_table;
                
                local ptr_table table[MAX_PTR];
                /* This table is used to remember the original form of pointers
                 * to large buffers (64K). Such pointers are normalized with a zero offset.
                 * Since MSDOS is not a preemptive multitasking OS, this table is not
                 * protected from concurrent access. This hack doesn't work anyway on
                 * a protected system like OS/2. Use Microsoft C instead.
                 */
                
                voidpf ZLIB_INTERNAL zcalloc (voidpf opaque, unsigned items, unsigned size)
                {
                    voidpf buf;
                    ulg bsize = (ulg)items*size;
                
                    (void)opaque;
                
                    /* If we allocate less than 65520 bytes, we assume that farmalloc
                     * will return a usable pointer which doesn't have to be normalized.
                     */
                    if (bsize < 65520L) {
                        buf = farmalloc(bsize);
                        if (*(ush*)&buf != 0) return buf;
                    } else {
                        buf = farmalloc(bsize + 16L);
                    }
                    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;
                    table[next_ptr].org_ptr = buf;
                
                    /* Normalize the pointer to seg:0 */
                    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;
                    *(ush*)&buf = 0;
                    table[next_ptr++].new_ptr = buf;
                    return buf;
                }
                
                void ZLIB_INTERNAL zcfree (voidpf opaque, voidpf ptr)
                {
                    int n;
                
                    (void)opaque;
                
                    if (*(ush*)&ptr != 0) { /* object < 64K */
                        farfree(ptr);
                        return;
                    }
                    /* Find the original pointer */
                    for (n = 0; n < next_ptr; n++) {
                        if (ptr != table[n].new_ptr) continue;
                
                        farfree(table[n].org_ptr);
                        while (++n < next_ptr) {
                            table[n-1] = table[n];
                        }
                        next_ptr--;
                        return;
                    }
                    Assert(0, "zcfree: ptr not found");
                }
                
                #endif /* __TURBOC__ */
                
                
                #ifdef M_I86
                /* Microsoft C in 16-bit mode */
                
                #  define MY_ZCALLOC
                
                #if (!defined(_MSC_VER) || (_MSC_VER <= 600))
                #  define _halloc  halloc
                #  define _hfree   hfree
                #endif
                
                voidpf ZLIB_INTERNAL zcalloc (voidpf opaque, uInt items, uInt size)
                {
                    (void)opaque;
                    return _halloc((long)items, size);
                }
                
                void ZLIB_INTERNAL zcfree (voidpf opaque, voidpf ptr)
                {
                    (void)opaque;
                    _hfree(ptr);
                }
                
                #endif /* M_I86 */
                
                #endif /* SYS16BIT */
                
                
                #ifndef MY_ZCALLOC /* Any system without a special alloc function */
                
                #ifndef STDC
                extern voidp  malloc OF((uInt size));
                extern voidp  calloc OF((uInt items, uInt size));
                extern void   free   OF((voidpf ptr));
                #endif
                
                voidpf ZLIB_INTERNAL zcalloc (opaque, items, size)
                    voidpf opaque;
                    unsigned items;
                    unsigned size;
           7 -> {
                    (void)opaque;
                    return sizeof(uInt) > 2 ? (voidpf)malloc(items * size) :
                                              (voidpf)calloc(items, size);
                }
                
                void ZLIB_INTERNAL zcfree (opaque, ptr)
                    voidpf opaque;
                    voidpf ptr;
           7 -> {
                    (void)opaque;
                    free(ptr);
                }
                
                #endif /* MY_ZCALLOC */
                
                #endif /* !Z_SOLO */


Top 10 Lines:

     Line      Count

      309          7
      318          7

Execution Summary:

        6   Executable lines in this file
        6   Lines executed
   100.00   Percent of the file executed

       14   Total number of line executions
     2.33   Average executions per line


*** File /usr/include/c++/5/bits/move.h:
                // Move, forward and identity for C++0x + swap -*- C++ -*-
                
                // Copyright (C) 2007-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/move.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{utility}
                 */
                
                #ifndef _MOVE_H
                #define _MOVE_H 1
                
                #include <bits/c++config.h>
                #include <bits/concept_check.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  // Used, in C++03 mode too, by allocators, etc.
                  /**
                   *  @brief Same as C++11 std::addressof
                   *  @ingroup utilities
                   */
                  template<typename _Tp>
                    inline _Tp*
                    __addressof(_Tp& __r) _GLIBCXX_NOEXCEPT
                    {
                      return reinterpret_cast<_Tp*>
                	(&const_cast<char&>(reinterpret_cast<const volatile char&>(__r)));
                    }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #if __cplusplus >= 201103L
                #include <type_traits> // Brings in std::declval too.
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  @addtogroup utilities
                   *  @{
                   */
                
                  /**
                   *  @brief  Forward an lvalue.
                   *  @return The parameter cast to the specified type.
                   *
                   *  This function is used to implement "perfect forwarding".
                   */
                  template<typename _Tp>
                    constexpr _Tp&&
                    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
                    { return static_cast<_Tp&&>(__t); }
                
                  /**
                   *  @brief  Forward an rvalue.
                   *  @return The parameter cast to the specified type.
                   *
                   *  This function is used to implement "perfect forwarding".
                   */
                  template<typename _Tp>
                    constexpr _Tp&&
                    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
                    {
                      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
                		    " substituting _Tp is an lvalue reference type");
                      return static_cast<_Tp&&>(__t);
                    }
                
                  /**
                   *  @brief  Convert a value to an rvalue.
                   *  @param  __t  A thing of arbitrary type.
                   *  @return The parameter cast to an rvalue-reference to allow moving it.
                  */
                  template<typename _Tp>
                    constexpr typename std::remove_reference<_Tp>::type&&
           1 ->     move(_Tp&& __t) noexcept
                    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
                
                
                  template<typename _Tp>
                    struct __move_if_noexcept_cond
                    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                                    is_copy_constructible<_Tp>>::type { };
                
                  /**
                   *  @brief  Conditionally convert a value to an rvalue.
                   *  @param  __x  A thing of arbitrary type.
                   *  @return The parameter, possibly cast to an rvalue-reference.
                   *
                   *  Same as std::move unless the type's move constructor could throw and the
                   *  type is copyable, in which case an lvalue-reference is returned instead.
                   */
                  template<typename _Tp>
                    constexpr typename
                    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
                    move_if_noexcept(_Tp& __x) noexcept
                    { return std::move(__x); }
                
                  // declval, from type_traits.
                
                  /**
                   *  @brief Returns the actual address of the object or function
                   *         referenced by r, even in the presence of an overloaded
                   *         operator&.
                   *  @param  __r  Reference to an object or function.
                   *  @return   The actual address.
                  */
                  template<typename _Tp>
                    inline _Tp*
                    addressof(_Tp& __r) noexcept
                    { return std::__addressof(__r); }
                
                  // C++11 version of std::exchange for internal use.
                  template <typename _Tp, typename _Up = _Tp>
                    inline _Tp
                    __exchange(_Tp& __obj, _Up&& __new_val)
                    {
                      _Tp __old_val = std::move(__obj);
                      __obj = std::forward<_Up>(__new_val);
                      return __old_val;
                    }
                
                  /// @} group utilities
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #define _GLIBCXX_MOVE(__val) std::move(__val)
                #define _GLIBCXX_FORWARD(_Tp, __val) std::forward<_Tp>(__val)
                #else
                #define _GLIBCXX_MOVE(__val) (__val)
                #define _GLIBCXX_FORWARD(_Tp, __val) (__val)
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  @addtogroup utilities
                   *  @{
                   */
                
                  /**
                   *  @brief Swaps two values.
                   *  @param  __a  A thing of arbitrary type.
                   *  @param  __b  Another thing of arbitrary type.
                   *  @return   Nothing.
                  */
                  template<typename _Tp>
                    inline void
                    swap(_Tp& __a, _Tp& __b)
                #if __cplusplus >= 201103L
                    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
                	            is_nothrow_move_assignable<_Tp>>::value)
                #endif
                    {
                      // concept requirements
                      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)
                
                      _Tp __tmp = _GLIBCXX_MOVE(__a);
                      __a = _GLIBCXX_MOVE(__b);
                      __b = _GLIBCXX_MOVE(__tmp);
                    }
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 809. std::swap should be overloaded for array types.
                  /// Swap the contents of two arrays.
                  template<typename _Tp, size_t _Nm>
                    inline void
                    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
                #if __cplusplus >= 201103L
                    noexcept(noexcept(swap(*__a, *__b)))
                #endif
                    {
                      for (size_t __n = 0; __n < _Nm; ++__n)
                	swap(__a[__n], __b[__n]);
                    }
                
                  /// @} group utilities
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif /* _MOVE_H */


Top 10 Lines:

     Line      Count

      101          1

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

        1   Total number of line executions
     1.00   Average executions per line


*** File /home/chaos/git_reposity/zlib/crc32.c:
                /* crc32.c -- compute the CRC-32 of a data stream
                 * Copyright (C) 1995-2006, 2010, 2011, 2012, 2016 Mark Adler
                 * For conditions of distribution and use, see copyright notice in zlib.h
                 *
                 * Thanks to Rodney Brown <rbrown64@csc.com.au> for his contribution of faster
                 * CRC methods: exclusive-oring 32 bits of data at a time, and pre-computing
                 * tables for updating the shift register in one step with three exclusive-ors
                 * instead of four steps with four exclusive-ors.  This results in about a
                 * factor of two increase in speed on a Power PC G4 (PPC7455) using gcc -O3.
                 */
                
                /* @(#) $Id$ */
                
                /*
                  Note on the use of DYNAMIC_CRC_TABLE: there is no mutex or semaphore
                  protection on the static variables used to control the first-use generation
                  of the crc tables.  Therefore, if you #define DYNAMIC_CRC_TABLE, you should
                  first call get_crc_table() to initialize the tables before allowing more than
                  one thread to use crc32().
                
                  DYNAMIC_CRC_TABLE and MAKECRCH can be #defined to write out crc32.h.
                 */
                
                #ifdef MAKECRCH
                #  include <stdio.h>
                #  ifndef DYNAMIC_CRC_TABLE
                #    define DYNAMIC_CRC_TABLE
                #  endif /* !DYNAMIC_CRC_TABLE */
                #endif /* MAKECRCH */
                
                #include "zutil.h"      /* for STDC and FAR definitions */
                
                /* Definitions for doing the crc four data bytes at a time. */
                #if !defined(NOBYFOUR) && defined(Z_U4)
                #  define BYFOUR
                #endif
                #ifdef BYFOUR
                   local unsigned long crc32_little OF((unsigned long,
                                        const unsigned char FAR *, z_size_t));
                   local unsigned long crc32_big OF((unsigned long,
                                        const unsigned char FAR *, z_size_t));
                #  define TBLS 8
                #else
                #  define TBLS 1
                #endif /* BYFOUR */
                
                /* Local functions for crc concatenation */
                local unsigned long gf2_matrix_times OF((unsigned long *mat,
                                                         unsigned long vec));
                local void gf2_matrix_square OF((unsigned long *square, unsigned long *mat));
                local uLong crc32_combine_ OF((uLong crc1, uLong crc2, z_off64_t len2));
                
                
                #ifdef DYNAMIC_CRC_TABLE
                
                local volatile int crc_table_empty = 1;
                local z_crc_t FAR crc_table[TBLS][256];
                local void make_crc_table OF((void));
                #ifdef MAKECRCH
                   local void write_table OF((FILE *, const z_crc_t FAR *));
                #endif /* MAKECRCH */
                /*
                  Generate tables for a byte-wise 32-bit CRC calculation on the polynomial:
                  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
                
                  Polynomials over GF(2) are represented in binary, one bit per coefficient,
                  with the lowest powers in the most significant bit.  Then adding polynomials
                  is just exclusive-or, and multiplying a polynomial by x is a right shift by
                  one.  If we call the above polynomial p, and represent a byte as the
                  polynomial q, also with the lowest power in the most significant bit (so the
                  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
                  where a mod b means the remainder after dividing a by b.
                
                  This calculation is done using the shift-register method of multiplying and
                  taking the remainder.  The register is initialized to zero, and for each
                  incoming bit, x^32 is added mod p to the register if the bit is a one (where
                  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
                  x (which is shifting right by one and adding x^32 mod p if the bit shifted
                  out is a one).  We start with the highest power (least significant bit) of
                  q and repeat for all eight bits of q.
                
                  The first table is simply the CRC of all possible eight bit values.  This is
                  all the information needed to generate CRCs on data a byte at a time for all
                  combinations of CRC register values and incoming bytes.  The remaining tables
                  allow for word-at-a-time CRC calculation for both big-endian and little-
                  endian machines, where a word is four bytes.
                */
                local void make_crc_table()
                {
                    z_crc_t c;
                    int n, k;
                    z_crc_t poly;                       /* polynomial exclusive-or pattern */
                    /* terms of polynomial defining this crc (except x^32): */
                    static volatile int first = 1;      /* flag to limit concurrent making */
                    static const unsigned char p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};
                
                    /* See if another task is already doing this (not thread-safe, but better
                       than nothing -- significantly reduces duration of vulnerability in
                       case the advice about DYNAMIC_CRC_TABLE is ignored) */
                    if (first) {
                        first = 0;
                
                        /* make exclusive-or pattern from polynomial (0xedb88320UL) */
                        poly = 0;
                        for (n = 0; n < (int)(sizeof(p)/sizeof(unsigned char)); n++)
                            poly |= (z_crc_t)1 << (31 - p[n]);
                
                        /* generate a crc for every 8-bit value */
                        for (n = 0; n < 256; n++) {
                            c = (z_crc_t)n;
                            for (k = 0; k < 8; k++)
                                c = c & 1 ? poly ^ (c >> 1) : c >> 1;
                            crc_table[0][n] = c;
                        }
                
                #ifdef BYFOUR
                        /* generate crc for each value followed by one, two, and three zeros,
                           and then the byte reversal of those as well as the first table */
                        for (n = 0; n < 256; n++) {
                            c = crc_table[0][n];
                            crc_table[4][n] = ZSWAP32(c);
                            for (k = 1; k < 4; k++) {
                                c = crc_table[0][c & 0xff] ^ (c >> 8);
                                crc_table[k][n] = c;
                                crc_table[k + 4][n] = ZSWAP32(c);
                            }
                        }
                #endif /* BYFOUR */
                
                        crc_table_empty = 0;
                    }
                    else {      /* not first */
                        /* wait for the other guy to finish (not efficient, but rare) */
                        while (crc_table_empty)
                            ;
                    }
                
                #ifdef MAKECRCH
                    /* write out CRC tables to crc32.h */
                    {
                        FILE *out;
                
                        out = fopen("crc32.h", "w");
                        if (out == NULL) return;
                        fprintf(out, "/* crc32.h -- tables for rapid CRC calculation\n");
                        fprintf(out, " * Generated automatically by crc32.c\n */\n\n");
                        fprintf(out, "local const z_crc_t FAR ");
                        fprintf(out, "crc_table[TBLS][256] =\n{\n  {\n");
                        write_table(out, crc_table[0]);
                #  ifdef BYFOUR
                        fprintf(out, "#ifdef BYFOUR\n");
                        for (k = 1; k < 8; k++) {
                            fprintf(out, "  },\n  {\n");
                            write_table(out, crc_table[k]);
                        }
                        fprintf(out, "#endif\n");
                #  endif /* BYFOUR */
                        fprintf(out, "  }\n};\n");
                        fclose(out);
                    }
                #endif /* MAKECRCH */
                }
                
                #ifdef MAKECRCH
                local void write_table(out, table)
                    FILE *out;
                    const z_crc_t FAR *table;
                {
                    int n;
                
                    for (n = 0; n < 256; n++)
                        fprintf(out, "%s0x%08lxUL%s", n % 5 ? "" : "    ",
                                (unsigned long)(table[n]),
                                n == 255 ? "\n" : (n % 5 == 4 ? ",\n" : ", "));
                }
                #endif /* MAKECRCH */
                
                #else /* !DYNAMIC_CRC_TABLE */
                /* ========================================================================
                 * Tables of CRC-32s of all single-byte values, made by make_crc_table().
                 */
                #include "crc32.h"
                #endif /* DYNAMIC_CRC_TABLE */
                
                /* =========================================================================
                 * This function can be used by asm versions of crc32()
                 */
                const z_crc_t FAR * ZEXPORT get_crc_table()
       ##### -> {
                #ifdef DYNAMIC_CRC_TABLE
                    if (crc_table_empty)
                        make_crc_table();
                #endif /* DYNAMIC_CRC_TABLE */
                    return (const z_crc_t FAR *)crc_table;
                }
                
                /* ========================================================================= */
                #define DO1 crc = crc_table[0][((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8)
                #define DO8 DO1; DO1; DO1; DO1; DO1; DO1; DO1; DO1
                
                /* ========================================================================= */
                unsigned long ZEXPORT crc32_z(crc, buf, len)
                    unsigned long crc;
                    const unsigned char FAR *buf;
                    z_size_t len;
      170874 -> {
                    if (buf == Z_NULL) return 0UL;
                
                #ifdef DYNAMIC_CRC_TABLE
                    if (crc_table_empty)
                        make_crc_table();
                #endif /* DYNAMIC_CRC_TABLE */
                
                #ifdef BYFOUR
                    if (sizeof(void *) == sizeof(ptrdiff_t)) {
                        z_crc_t endian;
                
                        endian = 1;
                        if (*((unsigned char *)(&endian)))
                            return crc32_little(crc, buf, len);
                        else
                            return crc32_big(crc, buf, len);
                    }
                #endif /* BYFOUR */
                    crc = crc ^ 0xffffffffUL;
                    while (len >= 8) {
                        DO8;
                        len -= 8;
                    }
                    if (len) do {
                        DO1;
                    } while (--len);
                    return crc ^ 0xffffffffUL;
                }
                
                /* ========================================================================= */
                unsigned long ZEXPORT crc32(crc, buf, len)
                    unsigned long crc;
                    const unsigned char FAR *buf;
                    uInt len;
      170874 -> {
                    return crc32_z(crc, buf, len);
                }
                
                #ifdef BYFOUR
                
                /*
                   This BYFOUR code accesses the passed unsigned char * buffer with a 32-bit
                   integer pointer type. This violates the strict aliasing rule, where a
                   compiler can assume, for optimization purposes, that two pointers to
                   fundamentally different types won't ever point to the same memory. This can
                   manifest as a problem only if one of the pointers is written to. This code
                   only reads from those pointers. So long as this code remains isolated in
                   this compilation unit, there won't be a problem. For this reason, this code
                   should not be copied and pasted into a compilation unit in which other code
                   writes to the buffer that is passed to these routines.
                 */
                
                /* ========================================================================= */
                #define DOLIT4 c ^= *buf4++; \
                        c = crc_table[3][c & 0xff] ^ crc_table[2][(c >> 8) & 0xff] ^ \
                            crc_table[1][(c >> 16) & 0xff] ^ crc_table[0][c >> 24]
                #define DOLIT32 DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4
                
                /* ========================================================================= */
                local unsigned long crc32_little(crc, buf, len)
                    unsigned long crc;
                    const unsigned char FAR *buf;
                    z_size_t len;
      170817 -> {
                    register z_crc_t c;
                    register const z_crc_t FAR *buf4;
                
                    c = (z_crc_t)crc;
                    c = ~c;
                    while (len && ((ptrdiff_t)buf & 3)) {
                        c = crc_table[0][(c ^ *buf++) & 0xff] ^ (c >> 8);
                        len--;
                    }
                
                    buf4 = (const z_crc_t FAR *)(const void FAR *)buf;
                    while (len >= 32) {
                        DOLIT32;
                        len -= 32;
                    }
                    while (len >= 4) {
                        DOLIT4;
                        len -= 4;
                    }
                    buf = (const unsigned char FAR *)buf4;
                
                    if (len) do {
                        c = crc_table[0][(c ^ *buf++) & 0xff] ^ (c >> 8);
                    } while (--len);
                    c = ~c;
                    return (unsigned long)c;
                }
                
                /* ========================================================================= */
                #define DOBIG4 c ^= *buf4++; \
                        c = crc_table[4][c & 0xff] ^ crc_table[5][(c >> 8) & 0xff] ^ \
                            crc_table[6][(c >> 16) & 0xff] ^ crc_table[7][c >> 24]
                #define DOBIG32 DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4
                
                /* ========================================================================= */
                local unsigned long crc32_big(crc, buf, len)
                    unsigned long crc;
                    const unsigned char FAR *buf;
                    z_size_t len;
       ##### -> {
                    register z_crc_t c;
                    register const z_crc_t FAR *buf4;
                
                    c = ZSWAP32((z_crc_t)crc);
                    c = ~c;
                    while (len && ((ptrdiff_t)buf & 3)) {
                        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);
                        len--;
                    }
                
                    buf4 = (const z_crc_t FAR *)(const void FAR *)buf;
                    while (len >= 32) {
                        DOBIG32;
                        len -= 32;
                    }
                    while (len >= 4) {
                        DOBIG4;
                        len -= 4;
                    }
                    buf = (const unsigned char FAR *)buf4;
                
                    if (len) do {
                        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);
                    } while (--len);
                    c = ~c;
                    return (unsigned long)(ZSWAP32(c));
                }
                
                #endif /* BYFOUR */
                
                #define GF2_DIM 32      /* dimension of GF(2) vectors (length of CRC) */
                
                /* ========================================================================= */
                local unsigned long gf2_matrix_times(mat, vec)
                    unsigned long *mat;
                    unsigned long vec;
       ##### -> {
                    unsigned long sum;
                
                    sum = 0;
                    while (vec) {
                        if (vec & 1)
                            sum ^= *mat;
                        vec >>= 1;
                        mat++;
                    }
                    return sum;
                }
                
                /* ========================================================================= */
                local void gf2_matrix_square(square, mat)
                    unsigned long *square;
                    unsigned long *mat;
       ##### -> {
                    int n;
                
                    for (n = 0; n < GF2_DIM; n++)
                        square[n] = gf2_matrix_times(mat, mat[n]);
                }
                
                /* ========================================================================= */
                local uLong crc32_combine_(crc1, crc2, len2)
                    uLong crc1;
                    uLong crc2;
                    z_off64_t len2;
       ##### -> {
                    int n;
                    unsigned long row;
                    unsigned long even[GF2_DIM];    /* even-power-of-two zeros operator */
                    unsigned long odd[GF2_DIM];     /* odd-power-of-two zeros operator */
                
                    /* degenerate case (also disallow negative lengths) */
                    if (len2 <= 0)
                        return crc1;
                
                    /* put operator for one zero bit in odd */
                    odd[0] = 0xedb88320UL;          /* CRC-32 polynomial */
                    row = 1;
                    for (n = 1; n < GF2_DIM; n++) {
                        odd[n] = row;
                        row <<= 1;
                    }
                
                    /* put operator for two zero bits in even */
                    gf2_matrix_square(even, odd);
                
                    /* put operator for four zero bits in odd */
                    gf2_matrix_square(odd, even);
                
                    /* apply len2 zeros to crc1 (first square will put the operator for one
                       zero byte, eight zero bits, in even) */
                    do {
                        /* apply zeros operator for this bit of len2 */
                        gf2_matrix_square(even, odd);
                        if (len2 & 1)
                            crc1 = gf2_matrix_times(even, crc1);
                        len2 >>= 1;
                
                        /* if no more bits set, then done */
                        if (len2 == 0)
                            break;
                
                        /* another iteration of the loop with odd and even swapped */
                        gf2_matrix_square(odd, even);
                        if (len2 & 1)
                            crc1 = gf2_matrix_times(odd, crc1);
                        len2 >>= 1;
                
                        /* if no more bits set, then done */
                    } while (len2 != 0);
                
                    /* return combined crc */
                    crc1 ^= crc2;
                    return crc1;
                }
                
                /* ========================================================================= */
                uLong ZEXPORT crc32_combine(crc1, crc2, len2)
                    uLong crc1;
                    uLong crc2;
                    z_off_t len2;
       ##### -> {
                    return crc32_combine_(crc1, crc2, len2);
                }
                
                uLong ZEXPORT crc32_combine64(crc1, crc2, len2)
                    uLong crc1;
                    uLong crc2;
                    z_off64_t len2;
       ##### -> {
                    return crc32_combine_(crc1, crc2, len2);
                }


Top 10 Lines:

     Line      Count

      206     170874
      241     170874
      270     170817

Execution Summary:

       10   Executable lines in this file
       10   Lines executed
   100.00   Percent of the file executed

   512565   Total number of line executions
 51256.50   Average executions per line


*** File /home/chaos/git_reposity/zlib/trees.c:
                /* trees.c -- output deflated data using Huffman coding
                 * Copyright (C) 1995-2017 Jean-loup Gailly
                 * detect_data_type() function provided freely by Cosmin Truta, 2006
                 * For conditions of distribution and use, see copyright notice in zlib.h
                 */
                
                /*
                 *  ALGORITHM
                 *
                 *      The "deflation" process uses several Huffman trees. The more
                 *      common source values are represented by shorter bit sequences.
                 *
                 *      Each code tree is stored in a compressed form which is itself
                 * a Huffman encoding of the lengths of all the code strings (in
                 * ascending order by source values).  The actual code strings are
                 * reconstructed from the lengths in the inflate process, as described
                 * in the deflate specification.
                 *
                 *  REFERENCES
                 *
                 *      Deutsch, L.P.,"'Deflate' Compressed Data Format Specification".
                 *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc
                 *
                 *      Storer, James A.
                 *          Data Compression:  Methods and Theory, pp. 49-50.
                 *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
                 *
                 *      Sedgewick, R.
                 *          Algorithms, p290.
                 *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
                 */
                
                /* @(#) $Id$ */
                
                /* #define GEN_TREES_H */
                
                #include "deflate.h"
                
                #ifdef ZLIB_DEBUG
                #  include <ctype.h>
                #endif
                
                /* ===========================================================================
                 * Constants
                 */
                
                #define MAX_BL_BITS 7
                /* Bit length codes must not exceed MAX_BL_BITS bits */
                
                #define END_BLOCK 256
                /* end of block literal code */
                
                #define REP_3_6      16
                /* repeat previous bit length 3-6 times (2 bits of repeat count) */
                
                #define REPZ_3_10    17
                /* repeat a zero length 3-10 times  (3 bits of repeat count) */
                
                #define REPZ_11_138  18
                /* repeat a zero length 11-138 times  (7 bits of repeat count) */
                
                local const int extra_lbits[LENGTH_CODES] /* extra bits for each length code */
                   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};
                
                local const int extra_dbits[D_CODES] /* extra bits for each distance code */
                   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
                
                local const int extra_blbits[BL_CODES]/* extra bits for each bit length code */
                   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};
                
                local const uch bl_order[BL_CODES]
                   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
                /* The lengths of the bit length codes are sent in order of decreasing
                 * probability, to avoid transmitting the lengths for unused bit length codes.
                 */
                
                /* ===========================================================================
                 * Local data. These are initialized only once.
                 */
                
                #define DIST_CODE_LEN  512 /* see definition of array dist_code below */
                
                #if defined(GEN_TREES_H) || !defined(STDC)
                /* non ANSI compilers may not accept trees.h */
                
                local ct_data static_ltree[L_CODES+2];
                /* The static literal tree. Since the bit lengths are imposed, there is no
                 * need for the L_CODES extra codes used during heap construction. However
                 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
                 * below).
                 */
                
                local ct_data static_dtree[D_CODES];
                /* The static distance tree. (Actually a trivial tree since all codes use
                 * 5 bits.)
                 */
                
                uch _dist_code[DIST_CODE_LEN];
                /* Distance codes. The first 256 values correspond to the distances
                 * 3 .. 258, the last 256 values correspond to the top 8 bits of
                 * the 15 bit distances.
                 */
                
                uch _length_code[MAX_MATCH-MIN_MATCH+1];
                /* length code for each normalized match length (0 == MIN_MATCH) */
                
                local int base_length[LENGTH_CODES];
                /* First normalized length for each code (0 = MIN_MATCH) */
                
                local int base_dist[D_CODES];
                /* First normalized distance for each code (0 = distance of 1) */
                
                #else
                #  include "trees.h"
                #endif /* GEN_TREES_H */
                
                struct static_tree_desc_s {
                    const ct_data *static_tree;  /* static tree or NULL */
                    const intf *extra_bits;      /* extra bits for each code or NULL */
                    int     extra_base;          /* base index for extra_bits */
                    int     elems;               /* max number of elements in the tree */
                    int     max_length;          /* max bit length for the codes */
                };
                
                local const static_tree_desc  static_l_desc =
                {static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};
                
                local const static_tree_desc  static_d_desc =
                {static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};
                
                local const static_tree_desc  static_bl_desc =
                {(const ct_data *)0, extra_blbits, 0,   BL_CODES, MAX_BL_BITS};
                
                /* ===========================================================================
                 * Local (static) routines in this file.
                 */
                
                local void tr_static_init OF((void));
                local void init_block     OF((deflate_state *s));
                local void pqdownheap     OF((deflate_state *s, ct_data *tree, int k));
                local void gen_bitlen     OF((deflate_state *s, tree_desc *desc));
                local void gen_codes      OF((ct_data *tree, int max_code, ushf *bl_count));
                local void build_tree     OF((deflate_state *s, tree_desc *desc));
                local void scan_tree      OF((deflate_state *s, ct_data *tree, int max_code));
                local void send_tree      OF((deflate_state *s, ct_data *tree, int max_code));
                local int  build_bl_tree  OF((deflate_state *s));
                local void send_all_trees OF((deflate_state *s, int lcodes, int dcodes,
                                              int blcodes));
                local void compress_block OF((deflate_state *s, const ct_data *ltree,
                                              const ct_data *dtree));
                local int  detect_data_type OF((deflate_state *s));
                local unsigned bi_reverse OF((unsigned value, int length));
                local void bi_windup      OF((deflate_state *s));
                local void bi_flush       OF((deflate_state *s));
                
                #ifdef GEN_TREES_H
                local void gen_trees_header OF((void));
                #endif
                
                #ifndef ZLIB_DEBUG
                #  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)
                   /* Send a code of the given tree. c and tree must not have side effects */
                
                #else /* !ZLIB_DEBUG */
                #  define send_code(s, c, tree) \
                     { if (z_verbose>2) fprintf(stderr,"\ncd %3d ",(c)); \
                       send_bits(s, tree[c].Code, tree[c].Len); }
                #endif
                
                /* ===========================================================================
                 * Output a short LSB first on the stream.
                 * IN assertion: there is enough room in pendingBuf.
                 */
                #define put_short(s, w) { \
                    put_byte(s, (uch)((w) & 0xff)); \
                    put_byte(s, (uch)((ush)(w) >> 8)); \
                }
                
                /* ===========================================================================
                 * Send a value on a given number of bits.
                 * IN assertion: length <= 16 and value fits in length bits.
                 */
                #ifdef ZLIB_DEBUG
                local void send_bits      OF((deflate_state *s, int value, int length));
                
                local void send_bits(s, value, length)
                    deflate_state *s;
                    int value;  /* value to send */
                    int length; /* number of bits */
   230241616 -> {
                    Tracevv((stderr," l %2d v %4x ", length, value));
                    Assert(length > 0 && length <= 15, "invalid length");
                    s->bits_sent += (ulg)length;
                
                    /* If not enough room in bi_buf, use (valid) bits from bi_buf and
                     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
                     * unused bits in value.
                     */
                    if (s->bi_valid > (int)Buf_size - length) {
                        s->bi_buf |= (ush)value << s->bi_valid;
                        put_short(s, s->bi_buf);
                        s->bi_buf = (ush)value >> (Buf_size - s->bi_valid);
                        s->bi_valid += length - Buf_size;
                    } else {
                        s->bi_buf |= (ush)value << s->bi_valid;
                        s->bi_valid += length;
                    }
                }
                #else /* !ZLIB_DEBUG */
                
                #define send_bits(s, value, length) \
                { int len = length;\
                  if (s->bi_valid > (int)Buf_size - len) {\
                    int val = (int)value;\
                    s->bi_buf |= (ush)val << s->bi_valid;\
                    put_short(s, s->bi_buf);\
                    s->bi_buf = (ush)val >> (Buf_size - s->bi_valid);\
                    s->bi_valid += len - Buf_size;\
                  } else {\
                    s->bi_buf |= (ush)(value) << s->bi_valid;\
                    s->bi_valid += len;\
                  }\
                }
                #endif /* ZLIB_DEBUG */
                
                
                /* the arguments must not have side effects */
                
                /* ===========================================================================
                 * Initialize the various 'constant' tables.
                 */
                local void tr_static_init()
           2 -> {
                #if defined(GEN_TREES_H) || !defined(STDC)
                    static int static_init_done = 0;
                    int n;        /* iterates over tree elements */
                    int bits;     /* bit counter */
                    int length;   /* length value */
                    int code;     /* code value */
                    int dist;     /* distance index */
                    ush bl_count[MAX_BITS+1];
                    /* number of codes at each bit length for an optimal tree */
                
                    if (static_init_done) return;
                
                    /* For some embedded targets, global variables are not initialized: */
                #ifdef NO_INIT_GLOBAL_POINTERS
                    static_l_desc.static_tree = static_ltree;
                    static_l_desc.extra_bits = extra_lbits;
                    static_d_desc.static_tree = static_dtree;
                    static_d_desc.extra_bits = extra_dbits;
                    static_bl_desc.extra_bits = extra_blbits;
                #endif
                
                    /* Initialize the mapping length (0..255) -> length code (0..28) */
                    length = 0;
                    for (code = 0; code < LENGTH_CODES-1; code++) {
                        base_length[code] = length;
                        for (n = 0; n < (1<<extra_lbits[code]); n++) {
                            _length_code[length++] = (uch)code;
                        }
                    }
                    Assert (length == 256, "tr_static_init: length != 256");
                    /* Note that the length 255 (match length 258) can be represented
                     * in two different ways: code 284 + 5 bits or code 285, so we
                     * overwrite length_code[255] to use the best encoding:
                     */
                    _length_code[length-1] = (uch)code;
                
                    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
                    dist = 0;
                    for (code = 0 ; code < 16; code++) {
                        base_dist[code] = dist;
                        for (n = 0; n < (1<<extra_dbits[code]); n++) {
                            _dist_code[dist++] = (uch)code;
                        }
                    }
                    Assert (dist == 256, "tr_static_init: dist != 256");
                    dist >>= 7; /* from now on, all distances are divided by 128 */
                    for ( ; code < D_CODES; code++) {
                        base_dist[code] = dist << 7;
                        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
                            _dist_code[256 + dist++] = (uch)code;
                        }
                    }
                    Assert (dist == 256, "tr_static_init: 256+dist != 512");
                
                    /* Construct the codes of the static literal tree */
                    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
                    n = 0;
                    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
                    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
                    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
                    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
                    /* Codes 286 and 287 do not exist, but we must include them in the
                     * tree construction to get a canonical Huffman tree (longest code
                     * all ones)
                     */
                    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);
                
                    /* The static distance tree is trivial: */
                    for (n = 0; n < D_CODES; n++) {
                        static_dtree[n].Len = 5;
                        static_dtree[n].Code = bi_reverse((unsigned)n, 5);
                    }
                    static_init_done = 1;
                
                #  ifdef GEN_TREES_H
                    gen_trees_header();
                #  endif
                #endif /* defined(GEN_TREES_H) || !defined(STDC) */
                }
                
                /* ===========================================================================
                 * Genererate the file trees.h describing the static trees.
                 */
                #ifdef GEN_TREES_H
                #  ifndef ZLIB_DEBUG
                #    include <stdio.h>
                #  endif
                
                #  define SEPARATOR(i, last, width) \
                      ((i) == (last)? "\n};\n\n" :    \
                       ((i) % (width) == (width)-1 ? ",\n" : ", "))
                
                void gen_trees_header()
                {
                    FILE *header = fopen("trees.h", "w");
                    int i;
                
                    Assert (header != NULL, "Can't open trees.h");
                    fprintf(header,
                            "/* header created automatically with -DGEN_TREES_H */\n\n");
                
                    fprintf(header, "local const ct_data static_ltree[L_CODES+2] = {\n");
                    for (i = 0; i < L_CODES+2; i++) {
                        fprintf(header, "{{%3u},{%3u}}%s", static_ltree[i].Code,
                                static_ltree[i].Len, SEPARATOR(i, L_CODES+1, 5));
                    }
                
                    fprintf(header, "local const ct_data static_dtree[D_CODES] = {\n");
                    for (i = 0; i < D_CODES; i++) {
                        fprintf(header, "{{%2u},{%2u}}%s", static_dtree[i].Code,
                                static_dtree[i].Len, SEPARATOR(i, D_CODES-1, 5));
                    }
                
                    fprintf(header, "const uch ZLIB_INTERNAL _dist_code[DIST_CODE_LEN] = {\n");
                    for (i = 0; i < DIST_CODE_LEN; i++) {
                        fprintf(header, "%2u%s", _dist_code[i],
                                SEPARATOR(i, DIST_CODE_LEN-1, 20));
                    }
                
                    fprintf(header,
                        "const uch ZLIB_INTERNAL _length_code[MAX_MATCH-MIN_MATCH+1]= {\n");
                    for (i = 0; i < MAX_MATCH-MIN_MATCH+1; i++) {
                        fprintf(header, "%2u%s", _length_code[i],
                                SEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));
                    }
                
                    fprintf(header, "local const int base_length[LENGTH_CODES] = {\n");
                    for (i = 0; i < LENGTH_CODES; i++) {
                        fprintf(header, "%1u%s", base_length[i],
                                SEPARATOR(i, LENGTH_CODES-1, 20));
                    }
                
                    fprintf(header, "local const int base_dist[D_CODES] = {\n");
                    for (i = 0; i < D_CODES; i++) {
                        fprintf(header, "%5u%s", base_dist[i],
                                SEPARATOR(i, D_CODES-1, 10));
                    }
                
                    fclose(header);
                }
                #endif /* GEN_TREES_H */
                
                /* ===========================================================================
                 * Initialize the tree data structures for a new zlib stream.
                 */
                void ZLIB_INTERNAL _tr_init(s)
                    deflate_state *s;
           2 -> {
                    tr_static_init();
                
                    s->l_desc.dyn_tree = s->dyn_ltree;
                    s->l_desc.stat_desc = &static_l_desc;
                
                    s->d_desc.dyn_tree = s->dyn_dtree;
                    s->d_desc.stat_desc = &static_d_desc;
                
                    s->bl_desc.dyn_tree = s->bl_tree;
                    s->bl_desc.stat_desc = &static_bl_desc;
                
                    s->bi_buf = 0;
                    s->bi_valid = 0;
                #ifdef ZLIB_DEBUG
                    s->compressed_len = 0L;
                    s->bits_sent = 0L;
                #endif
                
                    /* Initialize the first block of the first file: */
                    init_block(s);
                }
                
                /* ===========================================================================
                 * Initialize a new block.
                 */
                local void init_block(s)
                    deflate_state *s;
        5656 -> {
                    int n; /* iterates over tree elements */
                
                    /* Initialize the trees. */
                    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;
                    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;
                    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;
                
                    s->dyn_ltree[END_BLOCK].Freq = 1;
                    s->opt_len = s->static_len = 0L;
                    s->last_lit = s->matches = 0;
                }
                
                #define SMALLEST 1
                /* Index within the heap array of least frequent node in the Huffman tree */
                
                
                /* ===========================================================================
                 * Remove the smallest element from the heap and recreate the heap with
                 * one less element. Updates heap and heap_len.
                 */
                #define pqremove(s, tree, top) \
                {\
                    top = s->heap[SMALLEST]; \
                    s->heap[SMALLEST] = s->heap[s->heap_len--]; \
                    pqdownheap(s, tree, SMALLEST); \
                }
                
                /* ===========================================================================
                 * Compares to subtrees, using the tree depth as tie breaker when
                 * the subtrees have equal frequency. This minimizes the worst case length.
                 */
                #define smaller(tree, n, m, depth) \
                   (tree[n].Freq < tree[m].Freq || \
                   (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))
                
                /* ===========================================================================
                 * Restore the heap property by moving down the tree starting at node k,
                 * exchanging a node with the smallest of its two sons if necessary, stopping
                 * when the heap property is re-established (each father smaller than its
                 * two sons).
                 */
                local void pqdownheap(s, tree, k)
                    deflate_state *s;
                    ct_data *tree;  /* the tree to restore */
                    int k;               /* node to move down */
     1293598 -> {
                    int v = s->heap[k];
                    int j = k << 1;  /* left son of k */
                    while (j <= s->heap_len) {
                        /* Set j to the smallest of the two sons: */
                        if (j < s->heap_len &&
                            smaller(tree, s->heap[j+1], s->heap[j], s->depth)) {
                            j++;
                        }
                        /* Exit if v is smaller than both sons */
                        if (smaller(tree, v, s->heap[j], s->depth)) break;
                
                        /* Exchange v with the smallest son */
                        s->heap[k] = s->heap[j];  k = j;
                
                        /* And continue down the tree, setting j to the left son of k */
                        j <<= 1;
                    }
                    s->heap[k] = v;
                }
                
                /* ===========================================================================
                 * Compute the optimal bit lengths for a tree and update the total bit length
                 * for the current block.
                 * IN assertion: the fields freq and dad are set, heap[heap_max] and
                 *    above are the tree nodes sorted by increasing frequency.
                 * OUT assertions: the field len is set to the optimal bit length, the
                 *     array bl_count contains the frequencies for each bit length.
                 *     The length opt_len is updated; static_len is also updated if stree is
                 *     not null.
                 */
                local void gen_bitlen(s, desc)
                    deflate_state *s;
                    tree_desc *desc;    /* the tree descriptor */
       16962 -> {
                    ct_data *tree        = desc->dyn_tree;
                    int max_code         = desc->max_code;
                    const ct_data *stree = desc->stat_desc->static_tree;
                    const intf *extra    = desc->stat_desc->extra_bits;
                    int base             = desc->stat_desc->extra_base;
                    int max_length       = desc->stat_desc->max_length;
                    int h;              /* heap index */
                    int n, m;           /* iterate over the tree elements */
                    int bits;           /* bit length */
                    int xbits;          /* extra bits */
                    ush f;              /* frequency */
                    int overflow = 0;   /* number of elements with bit length too large */
                
                    for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;
                
                    /* In a first pass, compute the optimal bit lengths (which may
                     * overflow in the case of the bit length tree).
                     */
                    tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */
                
                    for (h = s->heap_max+1; h < HEAP_SIZE; h++) {
                        n = s->heap[h];
                        bits = tree[tree[n].Dad].Len + 1;
                        if (bits > max_length) bits = max_length, overflow++;
                        tree[n].Len = (ush)bits;
                        /* We overwrite tree[n].Dad which is no longer needed */
                
                        if (n > max_code) continue; /* not a leaf node */
                
                        s->bl_count[bits]++;
                        xbits = 0;
                        if (n >= base) xbits = extra[n-base];
                        f = tree[n].Freq;
                        s->opt_len += (ulg)f * (unsigned)(bits + xbits);
                        if (stree) s->static_len += (ulg)f * (unsigned)(stree[n].Len + xbits);
                    }
                    if (overflow == 0) return;
                
                    Tracev((stderr,"\nbit length overflow\n"));
                    /* This happens for example on obj2 and pic of the Calgary corpus */
                
                    /* Find the first bit length which could increase: */
                    do {
                        bits = max_length-1;
                        while (s->bl_count[bits] == 0) bits--;
                        s->bl_count[bits]--;      /* move one leaf down the tree */
                        s->bl_count[bits+1] += 2; /* move one overflow item as its brother */
                        s->bl_count[max_length]--;
                        /* The brother of the overflow item also moves one step up,
                         * but this does not affect bl_count[max_length]
                         */
                        overflow -= 2;
                    } while (overflow > 0);
                
                    /* Now recompute all bit lengths, scanning in increasing frequency.
                     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
                     * lengths instead of fixing only the wrong ones. This idea is taken
                     * from 'ar' written by Haruhiko Okumura.)
                     */
                    for (bits = max_length; bits != 0; bits--) {
                        n = s->bl_count[bits];
                        while (n != 0) {
                            m = s->heap[--h];
                            if (m > max_code) continue;
                            if ((unsigned) tree[m].Len != (unsigned) bits) {
                                Tracev((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
                                s->opt_len += ((ulg)bits - tree[m].Len) * tree[m].Freq;
                                tree[m].Len = (ush)bits;
                            }
                            n--;
                        }
                    }
                }
                
                /* ===========================================================================
                 * Generate the codes for a given tree and bit counts (which need not be
                 * optimal).
                 * IN assertion: the array bl_count contains the bit length statistics for
                 * the given tree and the field len is set for all tree elements.
                 * OUT assertion: the field code is set for all tree elements of non
                 *     zero code length.
                 */
                local void gen_codes (tree, max_code, bl_count)
                    ct_data *tree;             /* the tree to decorate */
                    int max_code;              /* largest code with non zero frequency */
                    ushf *bl_count;            /* number of codes at each bit length */
       16962 -> {
                    ush next_code[MAX_BITS+1]; /* next code value for each bit length */
                    unsigned code = 0;         /* running code value */
                    int bits;                  /* bit index */
                    int n;                     /* code index */
                
                    /* The distribution counts are first used to generate the code values
                     * without bit reversal.
                     */
                    for (bits = 1; bits <= MAX_BITS; bits++) {
                        code = (code + bl_count[bits-1]) << 1;
                        next_code[bits] = (ush)code;
                    }
                    /* Check that the bit counts in bl_count are consistent. The last code
                     * must be all ones.
                     */
                    Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
                            "inconsistent bit counts");
                    Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
                
                    for (n = 0;  n <= max_code; n++) {
                        int len = tree[n].Len;
                        if (len == 0) continue;
                        /* Now reverse the bits */
                        tree[n].Code = (ush)bi_reverse(next_code[len]++, len);
                
                        Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
                             n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
                    }
                }
                
                /* ===========================================================================
                 * Construct one Huffman tree and assigns the code bit strings and lengths.
                 * Update the total bit length for the current block.
                 * IN assertion: the field freq is set for all tree elements.
                 * OUT assertions: the fields len and code are set to the optimal bit length
                 *     and corresponding code. The length opt_len is updated; static_len is
                 *     also updated if stree is not null. The field max_code is set.
                 */
                local void build_tree(s, desc)
                    deflate_state *s;
                    tree_desc *desc; /* the tree descriptor */
       16962 -> {
                    ct_data *tree         = desc->dyn_tree;
                    const ct_data *stree  = desc->stat_desc->static_tree;
                    int elems             = desc->stat_desc->elems;
                    int n, m;          /* iterate over heap elements */
                    int max_code = -1; /* largest code with non zero frequency */
                    int node;          /* new node being created */
                
                    /* Construct the initial heap, with least frequent element in
                     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
                     * heap[0] is not used.
                     */
                    s->heap_len = 0, s->heap_max = HEAP_SIZE;
                
                    for (n = 0; n < elems; n++) {
                        if (tree[n].Freq != 0) {
                            s->heap[++(s->heap_len)] = max_code = n;
                            s->depth[n] = 0;
                        } else {
                            tree[n].Len = 0;
                        }
                    }
                
                    /* The pkzip format requires that at least one distance code exists,
                     * and that at least one bit should be sent even if there is only one
                     * possible code. So to avoid special checks later on we force at least
                     * two codes of non zero frequency.
                     */
                    while (s->heap_len < 2) {
                        node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);
                        tree[node].Freq = 1;
                        s->depth[node] = 0;
                        s->opt_len--; if (stree) s->static_len -= stree[node].Len;
                        /* node is 0 or 1 so it does not have extra bits */
                    }
                    desc->max_code = max_code;
                
                    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
                     * establish sub-heaps of increasing lengths:
                     */
                    for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);
                
                    /* Construct the Huffman tree by repeatedly combining the least two
                     * frequent nodes.
                     */
                    node = elems;              /* next internal node of the tree */
                    do {
                        pqremove(s, tree, n);  /* n = node of least frequency */
                        m = s->heap[SMALLEST]; /* m = node of next least frequency */
                
                        s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */
                        s->heap[--(s->heap_max)] = m;
                
                        /* Create a new node father of n and m */
                        tree[node].Freq = tree[n].Freq + tree[m].Freq;
                        s->depth[node] = (uch)((s->depth[n] >= s->depth[m] ?
                                                s->depth[n] : s->depth[m]) + 1);
                        tree[n].Dad = tree[m].Dad = (ush)node;
                #ifdef DUMP_BL_TREE
                        if (tree == s->bl_tree) {
                            fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
                                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
                        }
                #endif
                        /* and insert the new node in the heap */
                        s->heap[SMALLEST] = node++;
                        pqdownheap(s, tree, SMALLEST);
                
                    } while (s->heap_len >= 2);
                
                    s->heap[--(s->heap_max)] = s->heap[SMALLEST];
                
                    /* At this point, the fields freq and dad are set. We can now
                     * generate the bit lengths.
                     */
                    gen_bitlen(s, (tree_desc *)desc);
                
                    /* The field len is now set, we can generate the bit codes */
                    gen_codes ((ct_data *)tree, max_code, s->bl_count);
                }
                
                /* ===========================================================================
                 * Scan a literal or distance tree to determine the frequencies of the codes
                 * in the bit length tree.
                 */
                local void scan_tree (s, tree, max_code)
                    deflate_state *s;
                    ct_data *tree;   /* the tree to be scanned */
                    int max_code;    /* and its largest code of non zero frequency */
       11308 -> {
                    int n;                     /* iterates over all tree elements */
                    int prevlen = -1;          /* last emitted length */
                    int curlen;                /* length of current code */
                    int nextlen = tree[0].Len; /* length of next code */
                    int count = 0;             /* repeat count of the current code */
                    int max_count = 7;         /* max repeat count */
                    int min_count = 4;         /* min repeat count */
                
                    if (nextlen == 0) max_count = 138, min_count = 3;
                    tree[max_code+1].Len = (ush)0xffff; /* guard */
                
                    for (n = 0; n <= max_code; n++) {
                        curlen = nextlen; nextlen = tree[n+1].Len;
                        if (++count < max_count && curlen == nextlen) {
                            continue;
                        } else if (count < min_count) {
                            s->bl_tree[curlen].Freq += count;
                        } else if (curlen != 0) {
                            if (curlen != prevlen) s->bl_tree[curlen].Freq++;
                            s->bl_tree[REP_3_6].Freq++;
                        } else if (count <= 10) {
                            s->bl_tree[REPZ_3_10].Freq++;
                        } else {
                            s->bl_tree[REPZ_11_138].Freq++;
                        }
                        count = 0; prevlen = curlen;
                        if (nextlen == 0) {
                            max_count = 138, min_count = 3;
                        } else if (curlen == nextlen) {
                            max_count = 6, min_count = 3;
                        } else {
                            max_count = 7, min_count = 4;
                        }
                    }
                }
                
                /* ===========================================================================
                 * Send a literal or distance tree in compressed form, using the codes in
                 * bl_tree.
                 */
                local void send_tree (s, tree, max_code)
                    deflate_state *s;
                    ct_data *tree; /* the tree to be scanned */
                    int max_code;       /* and its largest code of non zero frequency */
       11308 -> {
                    int n;                     /* iterates over all tree elements */
                    int prevlen = -1;          /* last emitted length */
                    int curlen;                /* length of current code */
                    int nextlen = tree[0].Len; /* length of next code */
                    int count = 0;             /* repeat count of the current code */
                    int max_count = 7;         /* max repeat count */
                    int min_count = 4;         /* min repeat count */
                
                    /* tree[max_code+1].Len = -1; */  /* guard already set */
                    if (nextlen == 0) max_count = 138, min_count = 3;
                
                    for (n = 0; n <= max_code; n++) {
                        curlen = nextlen; nextlen = tree[n+1].Len;
                        if (++count < max_count && curlen == nextlen) {
                            continue;
                        } else if (count < min_count) {
                            do { send_code(s, curlen, s->bl_tree); } while (--count != 0);
                
                        } else if (curlen != 0) {
                            if (curlen != prevlen) {
                                send_code(s, curlen, s->bl_tree); count--;
                            }
                            Assert(count >= 3 && count <= 6, " 3_6?");
                            send_code(s, REP_3_6, s->bl_tree); send_bits(s, count-3, 2);
                
                        } else if (count <= 10) {
                            send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count-3, 3);
                
                        } else {
                            send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count-11, 7);
                        }
                        count = 0; prevlen = curlen;
                        if (nextlen == 0) {
                            max_count = 138, min_count = 3;
                        } else if (curlen == nextlen) {
                            max_count = 6, min_count = 3;
                        } else {
                            max_count = 7, min_count = 4;
                        }
                    }
                }
                
                /* ===========================================================================
                 * Construct the Huffman tree for the bit lengths and return the index in
                 * bl_order of the last bit length code to send.
                 */
                local int build_bl_tree(s)
                    deflate_state *s;
        5654 -> {
                    int max_blindex;  /* index of last bit length code of non zero freq */
                
                    /* Determine the bit length frequencies for literal and distance trees */
                    scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);
                    scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);
                
                    /* Build the bit length tree: */
                    build_tree(s, (tree_desc *)(&(s->bl_desc)));
                    /* opt_len now includes the length of the tree representations, except
                     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
                     */
                
                    /* Determine the number of bit length codes to send. The pkzip format
                     * requires that at least 4 bit length codes be sent. (appnote.txt says
                     * 3 but the actual value used is 4.)
                     */
                    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
                        if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;
                    }
                    /* Update opt_len to include the bit length tree and counts */
                    s->opt_len += 3*((ulg)max_blindex+1) + 5+5+4;
                    Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
                            s->opt_len, s->static_len));
                
                    return max_blindex;
                }
                
                /* ===========================================================================
                 * Send the header for a block using dynamic Huffman trees: the counts, the
                 * lengths of the bit length codes, the literal tree and the distance tree.
                 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
                 */
                local void send_all_trees(s, lcodes, dcodes, blcodes)
                    deflate_state *s;
                    int lcodes, dcodes, blcodes; /* number of codes for each tree */
        5654 -> {
                    int rank;                    /* index in bl_order */
                
                    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
                    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
                            "too many codes");
                    Tracev((stderr, "\nbl counts: "));
                    send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */
                    send_bits(s, dcodes-1,   5);
                    send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */
                    for (rank = 0; rank < blcodes; rank++) {
                        Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
                        send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);
                    }
                    Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));
                
                    send_tree(s, (ct_data *)s->dyn_ltree, lcodes-1); /* literal tree */
                    Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
                
                    send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1); /* distance tree */
                    Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
                }
                
                /* ===========================================================================
                 * Send a stored block
                 */
                void ZLIB_INTERNAL _tr_stored_block(s, buf, stored_len, last)
                    deflate_state *s;
                    charf *buf;       /* input block */
                    ulg stored_len;   /* length of input block */
                    int last;         /* one if this is the last block for a file */
       ##### -> {
                    send_bits(s, (STORED_BLOCK<<1)+last, 3);    /* send block type */
                    bi_windup(s);        /* align on byte boundary */
                    put_short(s, (ush)stored_len);
                    put_short(s, (ush)~stored_len);
                    zmemcpy(s->pending_buf + s->pending, (Bytef *)buf, stored_len);
                    s->pending += stored_len;
                #ifdef ZLIB_DEBUG
                    s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
                    s->compressed_len += (stored_len + 4) << 3;
                    s->bits_sent += 2*16;
                    s->bits_sent += stored_len<<3;
                #endif
                }
                
                /* ===========================================================================
                 * Flush the bits in the bit buffer to pending output (leaves at most 7 bits)
                 */
                void ZLIB_INTERNAL _tr_flush_bits(s)
                    deflate_state *s;
       25788 -> {
                    bi_flush(s);
                }
                
                /* ===========================================================================
                 * Send one empty static block to give enough lookahead for inflate.
                 * This takes 10 bits, of which 7 may remain in the bit buffer.
                 */
                void ZLIB_INTERNAL _tr_align(s)
                    deflate_state *s;
       ##### -> {
                    send_bits(s, STATIC_TREES<<1, 3);
                    send_code(s, END_BLOCK, static_ltree);
                #ifdef ZLIB_DEBUG
                    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
                #endif
                    bi_flush(s);
                }
                
                /* ===========================================================================
                 * Determine the best encoding for the current block: dynamic trees, static
                 * trees or store, and write out the encoded block.
                 */
                void ZLIB_INTERNAL _tr_flush_block(s, buf, stored_len, last)
                    deflate_state *s;
                    charf *buf;       /* input block, or NULL if too old */
                    ulg stored_len;   /* length of input block */
                    int last;         /* one if this is the last block for a file */
        5654 -> {
                    ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
                    int max_blindex = 0;  /* index of last bit length code of non zero freq */
                
                    /* Build the Huffman trees unless a stored block is forced */
                    if (s->level > 0) {
                
                        /* Check if the file is binary or text */
                        if (s->strm->data_type == Z_UNKNOWN)
                            s->strm->data_type = detect_data_type(s);
                
                        /* Construct the literal and distance trees */
                        build_tree(s, (tree_desc *)(&(s->l_desc)));
                        Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
                                s->static_len));
                
                        build_tree(s, (tree_desc *)(&(s->d_desc)));
                        Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
                                s->static_len));
                        /* At this point, opt_len and static_len are the total bit lengths of
                         * the compressed block data, excluding the tree representations.
                         */
                
                        /* Build the bit length tree for the above two trees, and get the index
                         * in bl_order of the last bit length code to send.
                         */
                        max_blindex = build_bl_tree(s);
                
                        /* Determine the best encoding. Compute the block lengths in bytes. */
                        opt_lenb = (s->opt_len+3+7)>>3;
                        static_lenb = (s->static_len+3+7)>>3;
                
                        Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
                                opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
                                s->last_lit));
                
                        if (static_lenb <= opt_lenb) opt_lenb = static_lenb;
                
                    } else {
                        Assert(buf != (char*)0, "lost buf");
                        opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
                    }
                
                #ifdef FORCE_STORED
                    if (buf != (char*)0) { /* force stored block */
                #else
                    if (stored_len+4 <= opt_lenb && buf != (char*)0) {
                                       /* 4: two words for the lengths */
                #endif
                        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
                         * Otherwise we can't have processed more than WSIZE input bytes since
                         * the last block flush, because compression would have been
                         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
                         * transform a block into a stored block.
                         */
                        _tr_stored_block(s, buf, stored_len, last);
                
                #ifdef FORCE_STATIC
                    } else if (static_lenb >= 0) { /* force static trees */
                #else
                    } else if (s->strategy == Z_FIXED || static_lenb == opt_lenb) {
                #endif
                        send_bits(s, (STATIC_TREES<<1)+last, 3);
                        compress_block(s, (const ct_data *)static_ltree,
                                       (const ct_data *)static_dtree);
                #ifdef ZLIB_DEBUG
                        s->compressed_len += 3 + s->static_len;
                #endif
                    } else {
                        send_bits(s, (DYN_TREES<<1)+last, 3);
                        send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,
                                       max_blindex+1);
                        compress_block(s, (const ct_data *)s->dyn_ltree,
                                       (const ct_data *)s->dyn_dtree);
                #ifdef ZLIB_DEBUG
                        s->compressed_len += 3 + s->opt_len;
                #endif
                    }
                    Assert (s->compressed_len == s->bits_sent, "bad compressed size");
                    /* The above check is made mod 2^32, for files larger than 512 MB
                     * and uLong implemented on 32 bits.
                     */
                    init_block(s);
                
                    if (last) {
                        bi_windup(s);
                #ifdef ZLIB_DEBUG
                        s->compressed_len += 7;  /* align on byte boundary */
                #endif
                    }
                    Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
                           s->compressed_len-7*last));
                }
                
                /* ===========================================================================
                 * Save the match info and tally the frequency counts. Return true if
                 * the current block must be flushed.
                 */
                int ZLIB_INTERNAL _tr_tally (s, dist, lc)
                    deflate_state *s;
                    unsigned dist;  /* distance of matched string */
                    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
    92616228 -> {
                    s->d_buf[s->last_lit] = (ush)dist;
                    s->l_buf[s->last_lit++] = (uch)lc;
                    if (dist == 0) {
                        /* lc is the unmatched char */
                        s->dyn_ltree[lc].Freq++;
                    } else {
                        s->matches++;
                        /* Here, lc is the match length - MIN_MATCH */
                        dist--;             /* dist = match distance - 1 */
                        Assert((ush)dist < (ush)MAX_DIST(s) &&
                               (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
                               (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");
                
                        s->dyn_ltree[_length_code[lc]+LITERALS+1].Freq++;
                        s->dyn_dtree[d_code(dist)].Freq++;
                    }
                
                #ifdef TRUNCATE_BLOCK
                    /* Try to guess if it is profitable to stop the current block here */
                    if ((s->last_lit & 0x1fff) == 0 && s->level > 2) {
                        /* Compute an upper bound for the compressed length */
                        ulg out_length = (ulg)s->last_lit*8L;
                        ulg in_length = (ulg)((long)s->strstart - s->block_start);
                        int dcode;
                        for (dcode = 0; dcode < D_CODES; dcode++) {
                            out_length += (ulg)s->dyn_dtree[dcode].Freq *
                                (5L+extra_dbits[dcode]);
                        }
                        out_length >>= 3;
                        Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
                               s->last_lit, in_length, out_length,
                               100L - out_length*100L/in_length));
                        if (s->matches < s->last_lit/2 && out_length < in_length/2) return 1;
                    }
                #endif
                    return (s->last_lit == s->lit_bufsize-1);
                    /* We avoid equality with lit_bufsize because of wraparound at 64K
                     * on 16 bit machines and because stored blocks are restricted to
                     * 64K-1 bytes.
                     */
                }
                
                /* ===========================================================================
                 * Send the block data compressed using the given Huffman trees
                 */
                local void compress_block(s, ltree, dtree)
                    deflate_state *s;
                    const ct_data *ltree; /* literal tree */
                    const ct_data *dtree; /* distance tree */
        5654 -> {
                    unsigned dist;      /* distance of matched string */
                    int lc;             /* match length or unmatched char (if dist == 0) */
                    unsigned lx = 0;    /* running index in l_buf */
                    unsigned code;      /* the code to send */
                    int extra;          /* number of extra bits to send */
                
                    if (s->last_lit != 0) do {
                        dist = s->d_buf[lx];
                        lc = s->l_buf[lx++];
                        if (dist == 0) {
                            send_code(s, lc, ltree); /* send a literal byte */
                            Tracecv(isgraph(lc), (stderr," '%c' ", lc));
                        } else {
                            /* Here, lc is the match length - MIN_MATCH */
                            code = _length_code[lc];
                            send_code(s, code+LITERALS+1, ltree); /* send the length code */
                            extra = extra_lbits[code];
                            if (extra != 0) {
                                lc -= base_length[code];
                                send_bits(s, lc, extra);       /* send the extra length bits */
                            }
                            dist--; /* dist is now the match distance - 1 */
                            code = d_code(dist);
                            Assert (code < D_CODES, "bad d_code");
                
                            send_code(s, code, dtree);       /* send the distance code */
                            extra = extra_dbits[code];
                            if (extra != 0) {
                                dist -= (unsigned)base_dist[code];
                                send_bits(s, dist, extra);   /* send the extra distance bits */
                            }
                        } /* literal or match pair ? */
                
                        /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
                        Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
                               "pendingBuf overflow");
                
                    } while (lx < s->last_lit);
                
                    send_code(s, END_BLOCK, ltree);
                }
                
                /* ===========================================================================
                 * Check if the data type is TEXT or BINARY, using the following algorithm:
                 * - TEXT if the two conditions below are satisfied:
                 *    a) There are no non-portable control characters belonging to the
                 *       "black list" (0..6, 14..25, 28..31).
                 *    b) There is at least one printable character belonging to the
                 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
                 * - BINARY otherwise.
                 * - The following partially-portable control characters form a
                 *   "gray list" that is ignored in this detection algorithm:
                 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
                 * IN assertion: the fields Freq of dyn_ltree are set.
                 */
                local int detect_data_type(s)
                    deflate_state *s;
           1 -> {
                    /* black_mask is the bit mask of black-listed bytes
                     * set bits 0..6, 14..25, and 28..31
                     * 0xf3ffc07f = binary 11110011111111111100000001111111
                     */
                    unsigned long black_mask = 0xf3ffc07fUL;
                    int n;
                
                    /* Check for non-textual ("black-listed") bytes. */
                    for (n = 0; n <= 31; n++, black_mask >>= 1)
                        if ((black_mask & 1) && (s->dyn_ltree[n].Freq != 0))
                            return Z_BINARY;
                
                    /* Check for textual ("white-listed") bytes. */
                    if (s->dyn_ltree[9].Freq != 0 || s->dyn_ltree[10].Freq != 0
                            || s->dyn_ltree[13].Freq != 0)
                        return Z_TEXT;
                    for (n = 32; n < LITERALS; n++)
                        if (s->dyn_ltree[n].Freq != 0)
                            return Z_TEXT;
                
                    /* There are no "black-listed" or "white-listed" bytes:
                     * this stream either is empty or has tolerated ("gray-listed") bytes only.
                     */
                    return Z_BINARY;
                }
                
                /* ===========================================================================
                 * Reverse the first len bits of a code, using straightforward code (a faster
                 * method would use a table)
                 * IN assertion: 1 <= len <= 15
                 */
                local unsigned bi_reverse(code, len)
                    unsigned code; /* the value to invert */
                    int len;       /* its bit length */
      533003 -> {
                    register unsigned res = 0;
                    do {
                        res |= code & 1;
                        code >>= 1, res <<= 1;
                    } while (--len > 0);
                    return res >> 1;
                }
                
                /* ===========================================================================
                 * Flush the bit buffer, keeping at most 7 bits in it.
                 */
                local void bi_flush(s)
                    deflate_state *s;
       25788 -> {
                    if (s->bi_valid == 16) {
                        put_short(s, s->bi_buf);
                        s->bi_buf = 0;
                        s->bi_valid = 0;
                    } else if (s->bi_valid >= 8) {
                        put_byte(s, (Byte)s->bi_buf);
                        s->bi_buf >>= 8;
                        s->bi_valid -= 8;
                    }
                }
                
                /* ===========================================================================
                 * Flush the bit buffer and align the output on a byte boundary
                 */
                local void bi_windup(s)
                    deflate_state *s;
           1 -> {
                    if (s->bi_valid > 8) {
                        put_short(s, s->bi_buf);
                    } else if (s->bi_valid > 0) {
                        put_byte(s, (Byte)s->bi_buf);
                    }
                    s->bi_buf = 0;
                    s->bi_valid = 0;
                #ifdef ZLIB_DEBUG
                    s->bits_sent = (s->bits_sent+7) & ~7;
                #endif
                }


Top 10 Lines:

     Line      Count

      190  230241616
     1018   92616228
      455    1293598
     1161     533003
      888      25788
     1175      25788
      489      16962
      576      16962
      618      16962
      707      11308

Execution Summary:

       22   Executable lines in this file
       22   Lines executed
   100.00   Percent of the file executed

324837801   Total number of line executions
14765354.59   Average executions per line


*** File /home/chaos/git_reposity/zlib/inflate.c:
                /* inflate.c -- zlib decompression
                 * Copyright (C) 1995-2016 Mark Adler
                 * For conditions of distribution and use, see copyright notice in zlib.h
                 */
                
                /*
                 * Change history:
                 *
                 * 1.2.beta0    24 Nov 2002
                 * - First version -- complete rewrite of inflate to simplify code, avoid
                 *   creation of window when not needed, minimize use of window when it is
                 *   needed, make inffast.c even faster, implement gzip decoding, and to
                 *   improve code readability and style over the previous zlib inflate code
                 *
                 * 1.2.beta1    25 Nov 2002
                 * - Use pointers for available input and output checking in inffast.c
                 * - Remove input and output counters in inffast.c
                 * - Change inffast.c entry and loop from avail_in >= 7 to >= 6
                 * - Remove unnecessary second byte pull from length extra in inffast.c
                 * - Unroll direct copy to three copies per loop in inffast.c
                 *
                 * 1.2.beta2    4 Dec 2002
                 * - Change external routine names to reduce potential conflicts
                 * - Correct filename to inffixed.h for fixed tables in inflate.c
                 * - Make hbuf[] unsigned char to match parameter type in inflate.c
                 * - Change strm->next_out[-state->offset] to *(strm->next_out - state->offset)
                 *   to avoid negation problem on Alphas (64 bit) in inflate.c
                 *
                 * 1.2.beta3    22 Dec 2002
                 * - Add comments on state->bits assertion in inffast.c
                 * - Add comments on op field in inftrees.h
                 * - Fix bug in reuse of allocated window after inflateReset()
                 * - Remove bit fields--back to byte structure for speed
                 * - Remove distance extra == 0 check in inflate_fast()--only helps for lengths
                 * - Change post-increments to pre-increments in inflate_fast(), PPC biased?
                 * - Add compile time option, POSTINC, to use post-increments instead (Intel?)
                 * - Make MATCH copy in inflate() much faster for when inflate_fast() not used
                 * - Use local copies of stream next and avail values, as well as local bit
                 *   buffer and bit count in inflate()--for speed when inflate_fast() not used
                 *
                 * 1.2.beta4    1 Jan 2003
                 * - Split ptr - 257 statements in inflate_table() to avoid compiler warnings
                 * - Move a comment on output buffer sizes from inffast.c to inflate.c
                 * - Add comments in inffast.c to introduce the inflate_fast() routine
                 * - Rearrange window copies in inflate_fast() for speed and simplification
                 * - Unroll last copy for window match in inflate_fast()
                 * - Use local copies of window variables in inflate_fast() for speed
                 * - Pull out common wnext == 0 case for speed in inflate_fast()
                 * - Make op and len in inflate_fast() unsigned for consistency
                 * - Add FAR to lcode and dcode declarations in inflate_fast()
                 * - Simplified bad distance check in inflate_fast()
                 * - Added inflateBackInit(), inflateBack(), and inflateBackEnd() in new
                 *   source file infback.c to provide a call-back interface to inflate for
                 *   programs like gzip and unzip -- uses window as output buffer to avoid
                 *   window copying
                 *
                 * 1.2.beta5    1 Jan 2003
                 * - Improved inflateBack() interface to allow the caller to provide initial
                 *   input in strm.
                 * - Fixed stored blocks bug in inflateBack()
                 *
                 * 1.2.beta6    4 Jan 2003
                 * - Added comments in inffast.c on effectiveness of POSTINC
                 * - Typecasting all around to reduce compiler warnings
                 * - Changed loops from while (1) or do {} while (1) to for (;;), again to
                 *   make compilers happy
                 * - Changed type of window in inflateBackInit() to unsigned char *
                 *
                 * 1.2.beta7    27 Jan 2003
                 * - Changed many types to unsigned or unsigned short to avoid warnings
                 * - Added inflateCopy() function
                 *
                 * 1.2.0        9 Mar 2003
                 * - Changed inflateBack() interface to provide separate opaque descriptors
                 *   for the in() and out() functions
                 * - Changed inflateBack() argument and in_func typedef to swap the length
                 *   and buffer address return values for the input function
                 * - Check next_in and next_out for Z_NULL on entry to inflate()
                 *
                 * The history for versions after 1.2.0 are in ChangeLog in zlib distribution.
                 */
                
                #include "zutil.h"
                #include "inftrees.h"
                #include "inflate.h"
                #include "inffast.h"
                
                #ifdef MAKEFIXED
                #  ifndef BUILDFIXED
                #    define BUILDFIXED
                #  endif
                #endif
                
                /* function prototypes */
                local int inflateStateCheck OF((z_streamp strm));
                local void fixedtables OF((struct inflate_state FAR *state));
                local int updatewindow OF((z_streamp strm, const unsigned char FAR *end,
                                           unsigned copy));
                #ifdef BUILDFIXED
                   void makefixed OF((void));
                #endif
                local unsigned syncsearch OF((unsigned FAR *have, const unsigned char FAR *buf,
                                              unsigned len));
                
                local int inflateStateCheck(strm)
                z_streamp strm;
       85311 -> {
                    struct inflate_state FAR *state;
                    if (strm == Z_NULL ||
                        strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)
                        return 1;
                    state = (struct inflate_state FAR *)strm->state;
                    if (state == Z_NULL || state->strm != strm ||
                        state->mode < HEAD || state->mode > SYNC)
                        return 1;
                    return 0;
                }
                
                int ZEXPORT inflateResetKeep(strm)
                z_streamp strm;
          28 -> {
                    struct inflate_state FAR *state;
                
                    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
                    state = (struct inflate_state FAR *)strm->state;
                    strm->total_in = strm->total_out = state->total = 0;
                    strm->msg = Z_NULL;
                    if (state->wrap)        /* to support ill-conceived Java test suite */
                        strm->adler = state->wrap & 1;
                    state->mode = HEAD;
                    state->last = 0;
                    state->havedict = 0;
                    state->dmax = 32768U;
                    state->head = Z_NULL;
                    state->hold = 0;
                    state->bits = 0;
                    state->lencode = state->distcode = state->next = state->codes;
                    state->sane = 1;
                    state->back = -1;
                    Tracev((stderr, "inflate: reset\n"));
                    return Z_OK;
                }
                
                int ZEXPORT inflateReset(strm)
                z_streamp strm;
          28 -> {
                    struct inflate_state FAR *state;
                
                    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
                    state = (struct inflate_state FAR *)strm->state;
                    state->wsize = 0;
                    state->whave = 0;
                    state->wnext = 0;
                    return inflateResetKeep(strm);
                }
                
                int ZEXPORT inflateReset2(strm, windowBits)
                z_streamp strm;
                int windowBits;
           1 -> {
                    int wrap;
                    struct inflate_state FAR *state;
                
                    /* get the state */
                    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
                    state = (struct inflate_state FAR *)strm->state;
                
                    /* extract wrap request from windowBits parameter */
                    if (windowBits < 0) {
                        wrap = 0;
                        windowBits = -windowBits;
                    }
                    else {
                        wrap = (windowBits >> 4) + 5;
                #ifdef GUNZIP
                        if (windowBits < 48)
                            windowBits &= 15;
                #endif
                    }
                
                    /* set number of window bits, free window if different */
                    if (windowBits && (windowBits < 8 || windowBits > 15))
                        return Z_STREAM_ERROR;
                    if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {
                        ZFREE(strm, state->window);
                        state->window = Z_NULL;
                    }
                
                    /* update state and reset the rest of it */
                    state->wrap = wrap;
                    state->wbits = (unsigned)windowBits;
                    return inflateReset(strm);
                }
                
                int ZEXPORT inflateInit2_(strm, windowBits, version, stream_size)
                z_streamp strm;
                int windowBits;
                const char *version;
                int stream_size;
           1 -> {
                    int ret;
                    struct inflate_state FAR *state;
                
                    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
                        stream_size != (int)(sizeof(z_stream)))
                        return Z_VERSION_ERROR;
                    if (strm == Z_NULL) return Z_STREAM_ERROR;
                    strm->msg = Z_NULL;                 /* in case we return an error */
                    if (strm->zalloc == (alloc_func)0) {
                #ifdef Z_SOLO
                        return Z_STREAM_ERROR;
                #else
                        strm->zalloc = zcalloc;
                        strm->opaque = (voidpf)0;
                #endif
                    }
                    if (strm->zfree == (free_func)0)
                #ifdef Z_SOLO
                        return Z_STREAM_ERROR;
                #else
                        strm->zfree = zcfree;
                #endif
                    state = (struct inflate_state FAR *)
                            ZALLOC(strm, 1, sizeof(struct inflate_state));
                    if (state == Z_NULL) return Z_MEM_ERROR;
                    Tracev((stderr, "inflate: allocated\n"));
                    strm->state = (struct internal_state FAR *)state;
                    state->strm = strm;
                    state->window = Z_NULL;
                    state->mode = HEAD;     /* to pass state test in inflateReset2() */
                    ret = inflateReset2(strm, windowBits);
                    if (ret != Z_OK) {
                        ZFREE(strm, state);
                        strm->state = Z_NULL;
                    }
                    return ret;
                }
                
                int ZEXPORT inflateInit_(strm, version, stream_size)
                z_streamp strm;
                const char *version;
                int stream_size;
       ##### -> {
                    return inflateInit2_(strm, DEF_WBITS, version, stream_size);
                }
                
                int ZEXPORT inflatePrime(strm, bits, value)
                z_streamp strm;
                int bits;
                int value;
       ##### -> {
                    struct inflate_state FAR *state;
                
                    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
                    state = (struct inflate_state FAR *)strm->state;
                    if (bits < 0) {
                        state->hold = 0;
                        state->bits = 0;
                        return Z_OK;
                    }
                    if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;
                    value &= (1L << bits) - 1;
                    state->hold += (unsigned)value << state->bits;
                    state->bits += (uInt)bits;
                    return Z_OK;
                }
                
                /*
                   Return state with length and distance decoding tables and index sizes set to
                   fixed code decoding.  Normally this returns fixed tables from inffixed.h.
                   If BUILDFIXED is defined, then instead this routine builds the tables the
                   first time it's called, and returns those tables the first time and
                   thereafter.  This reduces the size of the code by about 2K bytes, in
                   exchange for a little execution time.  However, BUILDFIXED should not be
                   used for threaded applications, since the rewriting of the tables and virgin
                   may not be thread-safe.
                 */
                local void fixedtables(state)
                struct inflate_state FAR *state;
        2480 -> {
                #ifdef BUILDFIXED
                    static int virgin = 1;
                    static code *lenfix, *distfix;
                    static code fixed[544];
                
                    /* build fixed huffman tables if first call (may not be thread safe) */
                    if (virgin) {
                        unsigned sym, bits;
                        static code *next;
                
                        /* literal/length table */
                        sym = 0;
                        while (sym < 144) state->lens[sym++] = 8;
                        while (sym < 256) state->lens[sym++] = 9;
                        while (sym < 280) state->lens[sym++] = 7;
                        while (sym < 288) state->lens[sym++] = 8;
                        next = fixed;
                        lenfix = next;
                        bits = 9;
                        inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
                
                        /* distance table */
                        sym = 0;
                        while (sym < 32) state->lens[sym++] = 5;
                        distfix = next;
                        bits = 5;
                        inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
                
                        /* do this just once */
                        virgin = 0;
                    }
                #else /* !BUILDFIXED */
                #   include "inffixed.h"
                #endif /* BUILDFIXED */
                    state->lencode = lenfix;
                    state->lenbits = 9;
                    state->distcode = distfix;
                    state->distbits = 5;
                }
                
                #ifdef MAKEFIXED
                #include <stdio.h>
                
                /*
                   Write out the inffixed.h that is #include'd above.  Defining MAKEFIXED also
                   defines BUILDFIXED, so the tables are built on the fly.  makefixed() writes
                   those tables to stdout, which would be piped to inffixed.h.  A small program
                   can simply call makefixed to do this:
                
                    void makefixed(void);
                
                    int main(void)
                    {
                        makefixed();
                        return 0;
                    }
                
                   Then that can be linked with zlib built with MAKEFIXED defined and run:
                
                    a.out > inffixed.h
                 */
                void makefixed()
                {
                    unsigned low, size;
                    struct inflate_state state;
                
                    fixedtables(&state);
                    puts("    /* inffixed.h -- table for decoding fixed codes");
                    puts("     * Generated automatically by makefixed().");
                    puts("     */");
                    puts("");
                    puts("    /* WARNING: this file should *not* be used by applications.");
                    puts("       It is part of the implementation of this library and is");
                    puts("       subject to change. Applications should only use zlib.h.");
                    puts("     */");
                    puts("");
                    size = 1U << 9;
                    printf("    static const code lenfix[%u] = {", size);
                    low = 0;
                    for (;;) {
                        if ((low % 7) == 0) printf("\n        ");
                        printf("{%u,%u,%d}", (low & 127) == 99 ? 64 : state.lencode[low].op,
                               state.lencode[low].bits, state.lencode[low].val);
                        if (++low == size) break;
                        putchar(',');
                    }
                    puts("\n    };");
                    size = 1U << 5;
                    printf("\n    static const code distfix[%u] = {", size);
                    low = 0;
                    for (;;) {
                        if ((low % 6) == 0) printf("\n        ");
                        printf("{%u,%u,%d}", state.distcode[low].op, state.distcode[low].bits,
                               state.distcode[low].val);
                        if (++low == size) break;
                        putchar(',');
                    }
                    puts("\n    };");
                }
                #endif /* MAKEFIXED */
                
                /*
                   Update the window with the last wsize (normally 32K) bytes written before
                   returning.  If window does not exist yet, create it.  This is only called
                   when a window is already in use, or when output has been written during this
                   inflate call, but the end of the deflate stream has not been reached yet.
                   It is also called to create a window for dictionary data when a dictionary
                   is loaded.
                
                   Providing output buffers larger than 32K to inflate() should provide a speed
                   advantage, since only the last 32K of output is copied to the sliding window
                   upon return from inflate(), and since all distances after the first 32K of
                   output will fall in the output data, making match copies simpler and faster.
                   The advantage may be dependent on the size of the processor's data caches.
                 */
                local int updatewindow(strm, end, copy)
                z_streamp strm;
                const Bytef *end;
                unsigned copy;
       85252 -> {
                    struct inflate_state FAR *state;
                    unsigned dist;
                
                    state = (struct inflate_state FAR *)strm->state;
                
                    /* if it hasn't been done already, allocate space for the window */
                    if (state->window == Z_NULL) {
                        state->window = (unsigned char FAR *)
                                        ZALLOC(strm, 1U << state->wbits,
                                               sizeof(unsigned char));
                        if (state->window == Z_NULL) return 1;
                    }
                
                    /* if window not in use yet, initialize */
                    if (state->wsize == 0) {
                        state->wsize = 1U << state->wbits;
                        state->wnext = 0;
                        state->whave = 0;
                    }
                
                    /* copy state->wsize or less output bytes into the circular window */
                    if (copy >= state->wsize) {
                        zmemcpy(state->window, end - state->wsize, state->wsize);
                        state->wnext = 0;
                        state->whave = state->wsize;
                    }
                    else {
                        dist = state->wsize - state->wnext;
                        if (dist > copy) dist = copy;
                        zmemcpy(state->window + state->wnext, end - copy, dist);
                        copy -= dist;
                        if (copy) {
                            zmemcpy(state->window, end - copy, copy);
                            state->wnext = copy;
                            state->whave = state->wsize;
                        }
                        else {
                            state->wnext += dist;
                            if (state->wnext == state->wsize) state->wnext = 0;
                            if (state->whave < state->wsize) state->whave += dist;
                        }
                    }
                    return 0;
                }
                
                /* Macros for inflate(): */
                
                /* check function to use adler32() for zlib or crc32() for gzip */
                #ifdef GUNZIP
                #  define UPDATE(check, buf, len) \
                    (state->flags ? crc32(check, buf, len) : adler32(check, buf, len))
                #else
                #  define UPDATE(check, buf, len) adler32(check, buf, len)
                #endif
                
                /* check macros for header crc */
                #ifdef GUNZIP
                #  define CRC2(check, word) \
                    do { \
                        hbuf[0] = (unsigned char)(word); \
                        hbuf[1] = (unsigned char)((word) >> 8); \
                        check = crc32(check, hbuf, 2); \
                    } while (0)
                
                #  define CRC4(check, word) \
                    do { \
                        hbuf[0] = (unsigned char)(word); \
                        hbuf[1] = (unsigned char)((word) >> 8); \
                        hbuf[2] = (unsigned char)((word) >> 16); \
                        hbuf[3] = (unsigned char)((word) >> 24); \
                        check = crc32(check, hbuf, 4); \
                    } while (0)
                #endif
                
                /* Load registers with state in inflate() for speed */
                #define LOAD() \
                    do { \
                        put = strm->next_out; \
                        left = strm->avail_out; \
                        next = strm->next_in; \
                        have = strm->avail_in; \
                        hold = state->hold; \
                        bits = state->bits; \
                    } while (0)
                
                /* Restore state from registers in inflate() */
                #define RESTORE() \
                    do { \
                        strm->next_out = put; \
                        strm->avail_out = left; \
                        strm->next_in = next; \
                        strm->avail_in = have; \
                        state->hold = hold; \
                        state->bits = bits; \
                    } while (0)
                
                /* Clear the input bit accumulator */
                #define INITBITS() \
                    do { \
                        hold = 0; \
                        bits = 0; \
                    } while (0)
                
                /* Get a byte of input into the bit accumulator, or return from inflate()
                   if there is no input available. */
                #define PULLBYTE() \
                    do { \
                        if (have == 0) goto inf_leave; \
                        have--; \
                        hold += (unsigned long)(*next++) << bits; \
                        bits += 8; \
                    } while (0)
                
                /* Assure that there are at least n bits in the bit accumulator.  If there is
                   not enough available input to do that, then return from inflate(). */
                #define NEEDBITS(n) \
                    do { \
                        while (bits < (unsigned)(n)) \
                            PULLBYTE(); \
                    } while (0)
                
                /* Return the low n bits of the bit accumulator (n < 16) */
                #define BITS(n) \
                    ((unsigned)hold & ((1U << (n)) - 1))
                
                /* Remove n bits from the bit accumulator */
                #define DROPBITS(n) \
                    do { \
                        hold >>= (n); \
                        bits -= (unsigned)(n); \
                    } while (0)
                
                /* Remove zero to seven bits as needed to go to a byte boundary */
                #define BYTEBITS() \
                    do { \
                        hold >>= bits & 7; \
                        bits -= bits & 7; \
                    } while (0)
                
                /*
                   inflate() uses a state machine to process as much input data and generate as
                   much output data as possible before returning.  The state machine is
                   structured roughly as follows:
                
                    for (;;) switch (state) {
                    ...
                    case STATEn:
                        if (not enough input data or output space to make progress)
                            return;
                        ... make progress ...
                        state = STATEm;
                        break;
                    ...
                    }
                
                   so when inflate() is called again, the same case is attempted again, and
                   if the appropriate resources are provided, the machine proceeds to the
                   next state.  The NEEDBITS() macro is usually the way the state evaluates
                   whether it can proceed or should return.  NEEDBITS() does the return if
                   the requested bits are not available.  The typical use of the BITS macros
                   is:
                
                        NEEDBITS(n);
                        ... do something with BITS(n) ...
                        DROPBITS(n);
                
                   where NEEDBITS(n) either returns from inflate() if there isn't enough
                   input left to load n bits into the accumulator, or it continues.  BITS(n)
                   gives the low n bits in the accumulator.  When done, DROPBITS(n) drops
                   the low n bits off the accumulator.  INITBITS() clears the accumulator
                   and sets the number of available bits to zero.  BYTEBITS() discards just
                   enough bits to put the accumulator on a byte boundary.  After BYTEBITS()
                   and a NEEDBITS(8), then BITS(8) would return the next byte in the stream.
                
                   NEEDBITS(n) uses PULLBYTE() to get an available byte of input, or to return
                   if there is no input available.  The decoding of variable length codes uses
                   PULLBYTE() directly in order to pull just enough bytes to decode the next
                   code, and no more.
                
                   Some states loop until they get enough input, making sure that enough
                   state information is maintained to continue the loop where it left off
                   if NEEDBITS() returns in the loop.  For example, want, need, and keep
                   would all have to actually be part of the saved state in case NEEDBITS()
                   returns:
                
                    case STATEw:
                        while (want < need) {
                            NEEDBITS(n);
                            keep[want++] = BITS(n);
                            DROPBITS(n);
                        }
                        state = STATEx;
                    case STATEx:
                
                   As shown above, if the next state is also the next case, then the break
                   is omitted.
                
                   A state may also return if there is not enough output space available to
                   complete that state.  Those states are copying stored data, writing a
                   literal byte, and copying a matching string.
                
                   When returning, a "goto inf_leave" is used to update the total counters,
                   update the check value, and determine whether any progress has been made
                   during that inflate() call in order to return the proper return code.
                   Progress is defined as a change in either strm->avail_in or strm->avail_out.
                   When there is a window, goto inf_leave will update the window with the last
                   output written.  If a goto inf_leave occurs in the middle of decompression
                   and there is no window currently, goto inf_leave will create one and copy
                   output to the window for the next call of inflate().
                
                   In this implementation, the flush parameter of inflate() only affects the
                   return code (per zlib.h).  inflate() always writes as much as possible to
                   strm->next_out, given the space available and the provided input--the effect
                   documented in zlib.h of Z_SYNC_FLUSH.  Furthermore, inflate() always defers
                   the allocation of and copying into a sliding window until necessary, which
                   provides the effect documented in zlib.h for Z_FINISH when the entire input
                   stream available.  So the only thing the flush parameter actually does is:
                   when flush is set to Z_FINISH, inflate() cannot return Z_OK.  Instead it
                   will return Z_BUF_ERROR if it has not reached the end of the stream.
                 */
                
                int ZEXPORT inflate(strm, flush)
                z_streamp strm;
                int flush;
       85253 -> {
                    struct inflate_state FAR *state;
                    z_const unsigned char FAR *next;    /* next input */
                    unsigned char FAR *put;     /* next output */
                    unsigned have, left;        /* available input and output */
                    unsigned long hold;         /* bit buffer */
                    unsigned bits;              /* bits in bit buffer */
                    unsigned in, out;           /* save starting available input and output */
                    unsigned copy;              /* number of stored or match bytes to copy */
                    unsigned char FAR *from;    /* where to copy match bytes from */
                    code here;                  /* current decoding table entry */
                    code last;                  /* parent table entry */
                    unsigned len;               /* length to copy for repeats, bits to drop */
                    int ret;                    /* return code */
                #ifdef GUNZIP
                    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
                #endif
                    static const unsigned short order[19] = /* permutation of code lengths */
                        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
                
                    if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||
                        (strm->next_in == Z_NULL && strm->avail_in != 0))
                        return Z_STREAM_ERROR;
                
                    state = (struct inflate_state FAR *)strm->state;
                    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
                    LOAD();
                    in = have;
                    out = left;
                    ret = Z_OK;
                    for (;;)
                        switch (state->mode) {
                        case HEAD:
                            if (state->wrap == 0) {
                                state->mode = TYPEDO;
                                break;
                            }
                            NEEDBITS(16);
                #ifdef GUNZIP
                            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
                                if (state->wbits == 0)
                                    state->wbits = 15;
                                state->check = crc32(0L, Z_NULL, 0);
                                CRC2(state->check, hold);
                                INITBITS();
                                state->mode = FLAGS;
                                break;
                            }
                            state->flags = 0;           /* expect zlib header */
                            if (state->head != Z_NULL)
                                state->head->done = -1;
                            if (!(state->wrap & 1) ||   /* check if zlib header allowed */
                #else
                            if (
                #endif
                                ((BITS(8) << 8) + (hold >> 8)) % 31) {
                                strm->msg = (char *)"incorrect header check";
                                state->mode = BAD;
                                break;
                            }
                            if (BITS(4) != Z_DEFLATED) {
                                strm->msg = (char *)"unknown compression method";
                                state->mode = BAD;
                                break;
                            }
                            DROPBITS(4);
                            len = BITS(4) + 8;
                            if (state->wbits == 0)
                                state->wbits = len;
                            if (len > 15 || len > state->wbits) {
                                strm->msg = (char *)"invalid window size";
                                state->mode = BAD;
                                break;
                            }
                            state->dmax = 1U << len;
                            Tracev((stderr, "inflate:   zlib header ok\n"));
                            strm->adler = state->check = adler32(0L, Z_NULL, 0);
                            state->mode = hold & 0x200 ? DICTID : TYPE;
                            INITBITS();
                            break;
                #ifdef GUNZIP
                        case FLAGS:
                            NEEDBITS(16);
                            state->flags = (int)(hold);
                            if ((state->flags & 0xff) != Z_DEFLATED) {
                                strm->msg = (char *)"unknown compression method";
                                state->mode = BAD;
                                break;
                            }
                            if (state->flags & 0xe000) {
                                strm->msg = (char *)"unknown header flags set";
                                state->mode = BAD;
                                break;
                            }
                            if (state->head != Z_NULL)
                                state->head->text = (int)((hold >> 8) & 1);
                            if ((state->flags & 0x0200) && (state->wrap & 4))
                                CRC2(state->check, hold);
                            INITBITS();
                            state->mode = TIME;
                        case TIME:
                            NEEDBITS(32);
                            if (state->head != Z_NULL)
                                state->head->time = hold;
                            if ((state->flags & 0x0200) && (state->wrap & 4))
                                CRC4(state->check, hold);
                            INITBITS();
                            state->mode = OS;
                        case OS:
                            NEEDBITS(16);
                            if (state->head != Z_NULL) {
                                state->head->xflags = (int)(hold & 0xff);
                                state->head->os = (int)(hold >> 8);
                            }
                            if ((state->flags & 0x0200) && (state->wrap & 4))
                                CRC2(state->check, hold);
                            INITBITS();
                            state->mode = EXLEN;
                        case EXLEN:
                            if (state->flags & 0x0400) {
                                NEEDBITS(16);
                                state->length = (unsigned)(hold);
                                if (state->head != Z_NULL)
                                    state->head->extra_len = (unsigned)hold;
                                if ((state->flags & 0x0200) && (state->wrap & 4))
                                    CRC2(state->check, hold);
                                INITBITS();
                            }
                            else if (state->head != Z_NULL)
                                state->head->extra = Z_NULL;
                            state->mode = EXTRA;
                        case EXTRA:
                            if (state->flags & 0x0400) {
                                copy = state->length;
                                if (copy > have) copy = have;
                                if (copy) {
                                    if (state->head != Z_NULL &&
                                        state->head->extra != Z_NULL) {
                                        len = state->head->extra_len - state->length;
                                        zmemcpy(state->head->extra + len, next,
                                                len + copy > state->head->extra_max ?
                                                state->head->extra_max - len : copy);
                                    }
                                    if ((state->flags & 0x0200) && (state->wrap & 4))
                                        state->check = crc32(state->check, next, copy);
                                    have -= copy;
                                    next += copy;
                                    state->length -= copy;
                                }
                                if (state->length) goto inf_leave;
                            }
                            state->length = 0;
                            state->mode = NAME;
                        case NAME:
                            if (state->flags & 0x0800) {
                                if (have == 0) goto inf_leave;
                                copy = 0;
                                do {
                                    len = (unsigned)(next[copy++]);
                                    if (state->head != Z_NULL &&
                                            state->head->name != Z_NULL &&
                                            state->length < state->head->name_max)
                                        state->head->name[state->length++] = (Bytef)len;
                                } while (len && copy < have);
                                if ((state->flags & 0x0200) && (state->wrap & 4))
                                    state->check = crc32(state->check, next, copy);
                                have -= copy;
                                next += copy;
                                if (len) goto inf_leave;
                            }
                            else if (state->head != Z_NULL)
                                state->head->name = Z_NULL;
                            state->length = 0;
                            state->mode = COMMENT;
                        case COMMENT:
                            if (state->flags & 0x1000) {
                                if (have == 0) goto inf_leave;
                                copy = 0;
                                do {
                                    len = (unsigned)(next[copy++]);
                                    if (state->head != Z_NULL &&
                                            state->head->comment != Z_NULL &&
                                            state->length < state->head->comm_max)
                                        state->head->comment[state->length++] = (Bytef)len;
                                } while (len && copy < have);
                                if ((state->flags & 0x0200) && (state->wrap & 4))
                                    state->check = crc32(state->check, next, copy);
                                have -= copy;
                                next += copy;
                                if (len) goto inf_leave;
                            }
                            else if (state->head != Z_NULL)
                                state->head->comment = Z_NULL;
                            state->mode = HCRC;
                        case HCRC:
                            if (state->flags & 0x0200) {
                                NEEDBITS(16);
                                if ((state->wrap & 4) && hold != (state->check & 0xffff)) {
                                    strm->msg = (char *)"header crc mismatch";
                                    state->mode = BAD;
                                    break;
                                }
                                INITBITS();
                            }
                            if (state->head != Z_NULL) {
                                state->head->hcrc = (int)((state->flags >> 9) & 1);
                                state->head->done = 1;
                            }
                            strm->adler = state->check = crc32(0L, Z_NULL, 0);
                            state->mode = TYPE;
                            break;
                #endif
                        case DICTID:
                            NEEDBITS(32);
                            strm->adler = state->check = ZSWAP32(hold);
                            INITBITS();
                            state->mode = DICT;
                        case DICT:
                            if (state->havedict == 0) {
                                RESTORE();
                                return Z_NEED_DICT;
                            }
                            strm->adler = state->check = adler32(0L, Z_NULL, 0);
                            state->mode = TYPE;
                        case TYPE:
                            if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;
                        case TYPEDO:
                            if (state->last) {
                                BYTEBITS();
                                state->mode = CHECK;
                                break;
                            }
                            NEEDBITS(3);
                            state->last = BITS(1);
                            DROPBITS(1);
                            switch (BITS(2)) {
                            case 0:                             /* stored block */
                                Tracev((stderr, "inflate:     stored block%s\n",
                                        state->last ? " (last)" : ""));
                                state->mode = STORED;
                                break;
                            case 1:                             /* fixed block */
                                fixedtables(state);
                                Tracev((stderr, "inflate:     fixed codes block%s\n",
                                        state->last ? " (last)" : ""));
                                state->mode = LEN_;             /* decode codes */
                                if (flush == Z_TREES) {
                                    DROPBITS(2);
                                    goto inf_leave;
                                }
                                break;
                            case 2:                             /* dynamic block */
                                Tracev((stderr, "inflate:     dynamic codes block%s\n",
                                        state->last ? " (last)" : ""));
                                state->mode = TABLE;
                                break;
                            case 3:
                                strm->msg = (char *)"invalid block type";
                                state->mode = BAD;
                            }
                            DROPBITS(2);
                            break;
                        case STORED:
                            BYTEBITS();                         /* go to byte boundary */
                            NEEDBITS(32);
                            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
                                strm->msg = (char *)"invalid stored block lengths";
                                state->mode = BAD;
                                break;
                            }
                            state->length = (unsigned)hold & 0xffff;
                            Tracev((stderr, "inflate:       stored length %u\n",
                                    state->length));
                            INITBITS();
                            state->mode = COPY_;
                            if (flush == Z_TREES) goto inf_leave;
                        case COPY_:
                            state->mode = COPY;
                        case COPY:
                            copy = state->length;
                            if (copy) {
                                if (copy > have) copy = have;
                                if (copy > left) copy = left;
                                if (copy == 0) goto inf_leave;
                                zmemcpy(put, next, copy);
                                have -= copy;
                                next += copy;
                                left -= copy;
                                put += copy;
                                state->length -= copy;
                                break;
                            }
                            Tracev((stderr, "inflate:       stored end\n"));
                            state->mode = TYPE;
                            break;
                        case TABLE:
                            NEEDBITS(14);
                            state->nlen = BITS(5) + 257;
                            DROPBITS(5);
                            state->ndist = BITS(5) + 1;
                            DROPBITS(5);
                            state->ncode = BITS(4) + 4;
                            DROPBITS(4);
                #ifndef PKZIP_BUG_WORKAROUND
                            if (state->nlen > 286 || state->ndist > 30) {
                                strm->msg = (char *)"too many length or distance symbols";
                                state->mode = BAD;
                                break;
                            }
                #endif
                            Tracev((stderr, "inflate:       table sizes ok\n"));
                            state->have = 0;
                            state->mode = LENLENS;
                        case LENLENS:
                            while (state->have < state->ncode) {
                                NEEDBITS(3);
                                state->lens[order[state->have++]] = (unsigned short)BITS(3);
                                DROPBITS(3);
                            }
                            while (state->have < 19)
                                state->lens[order[state->have++]] = 0;
                            state->next = state->codes;
                            state->lencode = (const code FAR *)(state->next);
                            state->lenbits = 7;
                            ret = inflate_table(CODES, state->lens, 19, &(state->next),
                                                &(state->lenbits), state->work);
                            if (ret) {
                                strm->msg = (char *)"invalid code lengths set";
                                state->mode = BAD;
                                break;
                            }
                            Tracev((stderr, "inflate:       code lengths ok\n"));
                            state->have = 0;
                            state->mode = CODELENS;
                        case CODELENS:
                            while (state->have < state->nlen + state->ndist) {
                                for (;;) {
                                    here = state->lencode[BITS(state->lenbits)];
                                    if ((unsigned)(here.bits) <= bits) break;
                                    PULLBYTE();
                                }
                                if (here.val < 16) {
                                    DROPBITS(here.bits);
                                    state->lens[state->have++] = here.val;
                                }
                                else {
                                    if (here.val == 16) {
                                        NEEDBITS(here.bits + 2);
                                        DROPBITS(here.bits);
                                        if (state->have == 0) {
                                            strm->msg = (char *)"invalid bit length repeat";
                                            state->mode = BAD;
                                            break;
                                        }
                                        len = state->lens[state->have - 1];
                                        copy = 3 + BITS(2);
                                        DROPBITS(2);
                                    }
                                    else if (here.val == 17) {
                                        NEEDBITS(here.bits + 3);
                                        DROPBITS(here.bits);
                                        len = 0;
                                        copy = 3 + BITS(3);
                                        DROPBITS(3);
                                    }
                                    else {
                                        NEEDBITS(here.bits + 7);
                                        DROPBITS(here.bits);
                                        len = 0;
                                        copy = 11 + BITS(7);
                                        DROPBITS(7);
                                    }
                                    if (state->have + copy > state->nlen + state->ndist) {
                                        strm->msg = (char *)"invalid bit length repeat";
                                        state->mode = BAD;
                                        break;
                                    }
                                    while (copy--)
                                        state->lens[state->have++] = (unsigned short)len;
                                }
                            }
                
                            /* handle error breaks in while */
                            if (state->mode == BAD) break;
                
                            /* check for end-of-block code (better have one) */
                            if (state->lens[256] == 0) {
                                strm->msg = (char *)"invalid code -- missing end-of-block";
                                state->mode = BAD;
                                break;
                            }
                
                            /* build code tables -- note: do not change the lenbits or distbits
                               values here (9 and 6) without reading the comments in inftrees.h
                               concerning the ENOUGH constants, which depend on those values */
                            state->next = state->codes;
                            state->lencode = (const code FAR *)(state->next);
                            state->lenbits = 9;
                            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
                                                &(state->lenbits), state->work);
                            if (ret) {
                                strm->msg = (char *)"invalid literal/lengths set";
                                state->mode = BAD;
                                break;
                            }
                            state->distcode = (const code FAR *)(state->next);
                            state->distbits = 6;
                            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
                                            &(state->next), &(state->distbits), state->work);
                            if (ret) {
                                strm->msg = (char *)"invalid distances set";
                                state->mode = BAD;
                                break;
                            }
                            Tracev((stderr, "inflate:       codes ok\n"));
                            state->mode = LEN_;
                            if (flush == Z_TREES) goto inf_leave;
                        case LEN_:
                            state->mode = LEN;
                        case LEN:
                            if (have >= 6 && left >= 258) {
                                RESTORE();
                                inflate_fast(strm, out);
                                LOAD();
                                if (state->mode == TYPE)
                                    state->back = -1;
                                break;
                            }
                            state->back = 0;
                            for (;;) {
                                here = state->lencode[BITS(state->lenbits)];
                                if ((unsigned)(here.bits) <= bits) break;
                                PULLBYTE();
                            }
                            if (here.op && (here.op & 0xf0) == 0) {
                                last = here;
                                for (;;) {
                                    here = state->lencode[last.val +
                                            (BITS(last.bits + last.op) >> last.bits)];
                                    if ((unsigned)(last.bits + here.bits) <= bits) break;
                                    PULLBYTE();
                                }
                                DROPBITS(last.bits);
                                state->back += last.bits;
                            }
                            DROPBITS(here.bits);
                            state->back += here.bits;
                            state->length = (unsigned)here.val;
                            if ((int)(here.op) == 0) {
                                Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                                        "inflate:         literal '%c'\n" :
                                        "inflate:         literal 0x%02x\n", here.val));
                                state->mode = LIT;
                                break;
                            }
                            if (here.op & 32) {
                                Tracevv((stderr, "inflate:         end of block\n"));
                                state->back = -1;
                                state->mode = TYPE;
                                break;
                            }
                            if (here.op & 64) {
                                strm->msg = (char *)"invalid literal/length code";
                                state->mode = BAD;
                                break;
                            }
                            state->extra = (unsigned)(here.op) & 15;
                            state->mode = LENEXT;
                        case LENEXT:
                            if (state->extra) {
                                NEEDBITS(state->extra);
                                state->length += BITS(state->extra);
                                DROPBITS(state->extra);
                                state->back += state->extra;
                            }
                            Tracevv((stderr, "inflate:         length %u\n", state->length));
                            state->was = state->length;
                            state->mode = DIST;
                        case DIST:
                            for (;;) {
                                here = state->distcode[BITS(state->distbits)];
                                if ((unsigned)(here.bits) <= bits) break;
                                PULLBYTE();
                            }
                            if ((here.op & 0xf0) == 0) {
                                last = here;
                                for (;;) {
                                    here = state->distcode[last.val +
                                            (BITS(last.bits + last.op) >> last.bits)];
                                    if ((unsigned)(last.bits + here.bits) <= bits) break;
                                    PULLBYTE();
                                }
                                DROPBITS(last.bits);
                                state->back += last.bits;
                            }
                            DROPBITS(here.bits);
                            state->back += here.bits;
                            if (here.op & 64) {
                                strm->msg = (char *)"invalid distance code";
                                state->mode = BAD;
                                break;
                            }
                            state->offset = (unsigned)here.val;
                            state->extra = (unsigned)(here.op) & 15;
                            state->mode = DISTEXT;
                        case DISTEXT:
                            if (state->extra) {
                                NEEDBITS(state->extra);
                                state->offset += BITS(state->extra);
                                DROPBITS(state->extra);
                                state->back += state->extra;
                            }
                #ifdef INFLATE_STRICT
                            if (state->offset > state->dmax) {
                                strm->msg = (char *)"invalid distance too far back";
                                state->mode = BAD;
                                break;
                            }
                #endif
                            Tracevv((stderr, "inflate:         distance %u\n", state->offset));
                            state->mode = MATCH;
                        case MATCH:
                            if (left == 0) goto inf_leave;
                            copy = out - left;
                            if (state->offset > copy) {         /* copy from window */
                                copy = state->offset - copy;
                                if (copy > state->whave) {
                                    if (state->sane) {
                                        strm->msg = (char *)"invalid distance too far back";
                                        state->mode = BAD;
                                        break;
                                    }
                #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                                    Trace((stderr, "inflate.c too far\n"));
                                    copy -= state->whave;
                                    if (copy > state->length) copy = state->length;
                                    if (copy > left) copy = left;
                                    left -= copy;
                                    state->length -= copy;
                                    do {
                                        *put++ = 0;
                                    } while (--copy);
                                    if (state->length == 0) state->mode = LEN;
                                    break;
                #endif
                                }
                                if (copy > state->wnext) {
                                    copy -= state->wnext;
                                    from = state->window + (state->wsize - copy);
                                }
                                else
                                    from = state->window + (state->wnext - copy);
                                if (copy > state->length) copy = state->length;
                            }
                            else {                              /* copy from output */
                                from = put - state->offset;
                                copy = state->length;
                            }
                            if (copy > left) copy = left;
                            left -= copy;
                            state->length -= copy;
                            do {
                                *put++ = *from++;
                            } while (--copy);
                            if (state->length == 0) state->mode = LEN;
                            break;
                        case LIT:
                            if (left == 0) goto inf_leave;
                            *put++ = (unsigned char)(state->length);
                            left--;
                            state->mode = LEN;
                            break;
                        case CHECK:
                            if (state->wrap) {
                                NEEDBITS(32);
                                out -= left;
                                strm->total_out += out;
                                state->total += out;
                                if ((state->wrap & 4) && out)
                                    strm->adler = state->check =
                                        UPDATE(state->check, put - out, out);
                                out = left;
                                if ((state->wrap & 4) && (
                #ifdef GUNZIP
                                     state->flags ? hold :
                #endif
                                     ZSWAP32(hold)) != state->check) {
                                    strm->msg = (char *)"incorrect data check";
                                    state->mode = BAD;
                                    break;
                                }
                                INITBITS();
                                Tracev((stderr, "inflate:   check matches trailer\n"));
                            }
                #ifdef GUNZIP
                            state->mode = LENGTH;
                        case LENGTH:
                            if (state->wrap && state->flags) {
                                NEEDBITS(32);
                                if (hold != (state->total & 0xffffffffUL)) {
                                    strm->msg = (char *)"incorrect length check";
                                    state->mode = BAD;
                                    break;
                                }
                                INITBITS();
                                Tracev((stderr, "inflate:   length matches trailer\n"));
                            }
                #endif
                            state->mode = DONE;
                        case DONE:
                            ret = Z_STREAM_END;
                            goto inf_leave;
                        case BAD:
                            ret = Z_DATA_ERROR;
                            goto inf_leave;
                        case MEM:
                            return Z_MEM_ERROR;
                        case SYNC:
                        default:
                            return Z_STREAM_ERROR;
                        }
                
                    /*
                       Return from inflate(), updating the total counts and the check value.
                       If there was no progress during the inflate() call, return a buffer
                       error.  Call updatewindow() to create and/or update the window state.
                       Note: a memory error from inflate() is non-recoverable.
                     */
                  inf_leave:
                    RESTORE();
                    if (state->wsize || (out != strm->avail_out && state->mode < BAD &&
                            (state->mode < CHECK || flush != Z_FINISH)))
                        if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {
                            state->mode = MEM;
                            return Z_MEM_ERROR;
                        }
                    in -= strm->avail_in;
                    out -= strm->avail_out;
                    strm->total_in += in;
                    strm->total_out += out;
                    state->total += out;
                    if ((state->wrap & 4) && out)
                        strm->adler = state->check =
                            UPDATE(state->check, strm->next_out - out, out);
                    strm->data_type = (int)state->bits + (state->last ? 64 : 0) +
                                      (state->mode == TYPE ? 128 : 0) +
                                      (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
                    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
                        ret = Z_BUF_ERROR;
                    return ret;
                }
                
                int ZEXPORT inflateEnd(strm)
                z_streamp strm;
           1 -> {
                    struct inflate_state FAR *state;
                    if (inflateStateCheck(strm))
                        return Z_STREAM_ERROR;
                    state = (struct inflate_state FAR *)strm->state;
                    if (state->window != Z_NULL) ZFREE(strm, state->window);
                    ZFREE(strm, strm->state);
                    strm->state = Z_NULL;
                    Tracev((stderr, "inflate: end\n"));
                    return Z_OK;
                }
                
                int ZEXPORT inflateGetDictionary(strm, dictionary, dictLength)
                z_streamp strm;
                Bytef *dictionary;
                uInt *dictLength;
       ##### -> {
                    struct inflate_state FAR *state;
                
                    /* check state */
                    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
                    state = (struct inflate_state FAR *)strm->state;
                
                    /* copy dictionary */
                    if (state->whave && dictionary != Z_NULL) {
                        zmemcpy(dictionary, state->window + state->wnext,
                                state->whave - state->wnext);
                        zmemcpy(dictionary + state->whave - state->wnext,
                                state->window, state->wnext);
                    }
                    if (dictLength != Z_NULL)
                        *dictLength = state->whave;
                    return Z_OK;
                }
                
                int ZEXPORT inflateSetDictionary(strm, dictionary, dictLength)
                z_streamp strm;
                const Bytef *dictionary;
                uInt dictLength;
       ##### -> {
                    struct inflate_state FAR *state;
                    unsigned long dictid;
                    int ret;
                
                    /* check state */
                    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
                    state = (struct inflate_state FAR *)strm->state;
                    if (state->wrap != 0 && state->mode != DICT)
                        return Z_STREAM_ERROR;
                
                    /* check for correct dictionary identifier */
                    if (state->mode == DICT) {
                        dictid = adler32(0L, Z_NULL, 0);
                        dictid = adler32(dictid, dictionary, dictLength);
                        if (dictid != state->check)
                            return Z_DATA_ERROR;
                    }
                
                    /* copy dictionary to window using updatewindow(), which will amend the
                       existing dictionary if appropriate */
                    ret = updatewindow(strm, dictionary + dictLength, dictLength);
                    if (ret) {
                        state->mode = MEM;
                        return Z_MEM_ERROR;
                    }
                    state->havedict = 1;
                    Tracev((stderr, "inflate:   dictionary set\n"));
                    return Z_OK;
                }
                
                int ZEXPORT inflateGetHeader(strm, head)
                z_streamp strm;
                gz_headerp head;
       ##### -> {
                    struct inflate_state FAR *state;
                
                    /* check state */
                    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
                    state = (struct inflate_state FAR *)strm->state;
                    if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;
                
                    /* save header structure */
                    state->head = head;
                    head->done = 0;
                    return Z_OK;
                }
                
                /*
                   Search buf[0..len-1] for the pattern: 0, 0, 0xff, 0xff.  Return when found
                   or when out of input.  When called, *have is the number of pattern bytes
                   found in order so far, in 0..3.  On return *have is updated to the new
                   state.  If on return *have equals four, then the pattern was found and the
                   return value is how many bytes were read including the last byte of the
                   pattern.  If *have is less than four, then the pattern has not been found
                   yet and the return value is len.  In the latter case, syncsearch() can be
                   called again with more data and the *have state.  *have is initialized to
                   zero for the first call.
                 */
                local unsigned syncsearch(have, buf, len)
                unsigned FAR *have;
                const unsigned char FAR *buf;
                unsigned len;
       ##### -> {
                    unsigned got;
                    unsigned next;
                
                    got = *have;
                    next = 0;
                    while (next < len && got < 4) {
                        if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))
                            got++;
                        else if (buf[next])
                            got = 0;
                        else
                            got = 4 - got;
                        next++;
                    }
                    *have = got;
                    return next;
                }
                
                int ZEXPORT inflateSync(strm)
                z_streamp strm;
       ##### -> {
                    unsigned len;               /* number of bytes to look at or looked at */
                    unsigned long in, out;      /* temporary to save total_in and total_out */
                    unsigned char buf[4];       /* to restore bit buffer to byte string */
                    struct inflate_state FAR *state;
                
                    /* check parameters */
                    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
                    state = (struct inflate_state FAR *)strm->state;
                    if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;
                
                    /* if first time, start search in bit buffer */
                    if (state->mode != SYNC) {
                        state->mode = SYNC;
                        state->hold <<= state->bits & 7;
                        state->bits -= state->bits & 7;
                        len = 0;
                        while (state->bits >= 8) {
                            buf[len++] = (unsigned char)(state->hold);
                            state->hold >>= 8;
                            state->bits -= 8;
                        }
                        state->have = 0;
                        syncsearch(&(state->have), buf, len);
                    }
                
                    /* search available input */
                    len = syncsearch(&(state->have), strm->next_in, strm->avail_in);
                    strm->avail_in -= len;
                    strm->next_in += len;
                    strm->total_in += len;
                
                    /* return no joy or set up to restart inflate() on a new block */
                    if (state->have != 4) return Z_DATA_ERROR;
                    in = strm->total_in;  out = strm->total_out;
                    inflateReset(strm);
                    strm->total_in = in;  strm->total_out = out;
                    state->mode = TYPE;
                    return Z_OK;
                }
                
                /*
                   Returns true if inflate is currently at the end of a block generated by
                   Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
                   implementation to provide an additional safety check. PPP uses
                   Z_SYNC_FLUSH but removes the length bytes of the resulting empty stored
                   block. When decompressing, PPP checks that at the end of input packet,
                   inflate is waiting for these length bytes.
                 */
                int ZEXPORT inflateSyncPoint(strm)
                z_streamp strm;
       ##### -> {
                    struct inflate_state FAR *state;
                
                    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
                    state = (struct inflate_state FAR *)strm->state;
                    return state->mode == STORED && state->bits == 0;
                }
                
                int ZEXPORT inflateCopy(dest, source)
                z_streamp dest;
                z_streamp source;
       ##### -> {
                    struct inflate_state FAR *state;
                    struct inflate_state FAR *copy;
                    unsigned char FAR *window;
                    unsigned wsize;
                
                    /* check input */
                    if (inflateStateCheck(source) || dest == Z_NULL)
                        return Z_STREAM_ERROR;
                    state = (struct inflate_state FAR *)source->state;
                
                    /* allocate space */
                    copy = (struct inflate_state FAR *)
                           ZALLOC(source, 1, sizeof(struct inflate_state));
                    if (copy == Z_NULL) return Z_MEM_ERROR;
                    window = Z_NULL;
                    if (state->window != Z_NULL) {
                        window = (unsigned char FAR *)
                                 ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));
                        if (window == Z_NULL) {
                            ZFREE(source, copy);
                            return Z_MEM_ERROR;
                        }
                    }
                
                    /* copy state */
                    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));
                    zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));
                    copy->strm = dest;
                    if (state->lencode >= state->codes &&
                        state->lencode <= state->codes + ENOUGH - 1) {
                        copy->lencode = copy->codes + (state->lencode - state->codes);
                        copy->distcode = copy->codes + (state->distcode - state->codes);
                    }
                    copy->next = copy->codes + (state->next - state->codes);
                    if (window != Z_NULL) {
                        wsize = 1U << state->wbits;
                        zmemcpy(window, state->window, wsize);
                    }
                    copy->window = window;
                    dest->state = (struct internal_state FAR *)copy;
                    return Z_OK;
                }
                
                int ZEXPORT inflateUndermine(strm, subvert)
                z_streamp strm;
                int subvert;
       ##### -> {
                    struct inflate_state FAR *state;
                
                    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
                    state = (struct inflate_state FAR *)strm->state;
                #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                    state->sane = !subvert;
                    return Z_OK;
                #else
                    (void)subvert;
                    state->sane = 1;
                    return Z_DATA_ERROR;
                #endif
                }
                
                int ZEXPORT inflateValidate(strm, check)
                z_streamp strm;
                int check;
       ##### -> {
                    struct inflate_state FAR *state;
                
                    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
                    state = (struct inflate_state FAR *)strm->state;
                    if (check)
                        state->wrap |= 4;
                    else
                        state->wrap &= ~4;
                    return Z_OK;
                }
                
                long ZEXPORT inflateMark(strm)
                z_streamp strm;
       ##### -> {
                    struct inflate_state FAR *state;
                
                    if (inflateStateCheck(strm))
                        return -(1L << 16);
                    state = (struct inflate_state FAR *)strm->state;
                    return (long)(((unsigned long)((long)state->back)) << 16) +
                        (state->mode == COPY ? state->length :
                            (state->mode == MATCH ? state->was - state->length : 0));
                }
                
                unsigned long ZEXPORT inflateCodesUsed(strm)
                z_streamp strm;
       ##### -> {
                    struct inflate_state FAR *state;
                    if (inflateStateCheck(strm)) return (unsigned long)-1;
                    state = (struct inflate_state FAR *)strm->state;
                    return (unsigned long)(state->next - state->codes);
                }


Top 10 Lines:

     Line      Count

      107      85311
      625      85253
      400      85252
      280       2480
      121         28
      146         28
      160          1
      200          1
     1279          1

Execution Summary:

       22   Executable lines in this file
       22   Lines executed
   100.00   Percent of the file executed

   258355   Total number of line executions
 11743.41   Average executions per line


*** File /home/chaos/git_reposity/zlib/deflate.c:
                /* deflate.c -- compress data using the deflation algorithm
                 * Copyright (C) 1995-2017 Jean-loup Gailly and Mark Adler
                 * For conditions of distribution and use, see copyright notice in zlib.h
                 */
                
                /*
                 *  ALGORITHM
                 *
                 *      The "deflation" process depends on being able to identify portions
                 *      of the input text which are identical to earlier input (within a
                 *      sliding window trailing behind the input currently being processed).
                 *
                 *      The most straightforward technique turns out to be the fastest for
                 *      most input files: try all possible matches and select the longest.
                 *      The key feature of this algorithm is that insertions into the string
                 *      dictionary are very simple and thus fast, and deletions are avoided
                 *      completely. Insertions are performed at each input character, whereas
                 *      string matches are performed only when the previous match ends. So it
                 *      is preferable to spend more time in matches to allow very fast string
                 *      insertions and avoid deletions. The matching algorithm for small
                 *      strings is inspired from that of Rabin & Karp. A brute force approach
                 *      is used to find longer strings when a small match has been found.
                 *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
                 *      (by Leonid Broukhis).
                 *         A previous version of this file used a more sophisticated algorithm
                 *      (by Fiala and Greene) which is guaranteed to run in linear amortized
                 *      time, but has a larger average cost, uses more memory and is patented.
                 *      However the F&G algorithm may be faster for some highly redundant
                 *      files if the parameter max_chain_length (described below) is too large.
                 *
                 *  ACKNOWLEDGEMENTS
                 *
                 *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
                 *      I found it in 'freeze' written by Leonid Broukhis.
                 *      Thanks to many people for bug reports and testing.
                 *
                 *  REFERENCES
                 *
                 *      Deutsch, L.P.,"DEFLATE Compressed Data Format Specification".
                 *      Available in http://tools.ietf.org/html/rfc1951
                 *
                 *      A description of the Rabin and Karp algorithm is given in the book
                 *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
                 *
                 *      Fiala,E.R., and Greene,D.H.
                 *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
                 *
                 */
                
                /* @(#) $Id$ */
                
                #include "deflate.h"
                
                const char deflate_copyright[] =
                   " deflate 1.2.11 Copyright 1995-2017 Jean-loup Gailly and Mark Adler ";
                /*
                  If you use the zlib library in a product, an acknowledgment is welcome
                  in the documentation of your product. If for some reason you cannot
                  include such an acknowledgment, I would appreciate that you keep this
                  copyright string in the executable of your product.
                 */
                
                /* ===========================================================================
                 *  Function prototypes.
                 */
                typedef enum {
                    need_more,      /* block not completed, need more input or more output */
                    block_done,     /* block flush performed */
                    finish_started, /* finish started, need only more output at next deflate */
                    finish_done     /* finish done, accept no more input or output */
                } block_state;
                
                typedef block_state (*compress_func) OF((deflate_state *s, int flush));
                /* Compression function. Returns the block state after the call. */
                
                local int deflateStateCheck      OF((z_streamp strm));
                local void slide_hash     OF((deflate_state *s));
                local void fill_window    OF((deflate_state *s));
                local block_state deflate_stored OF((deflate_state *s, int flush));
                local block_state deflate_fast   OF((deflate_state *s, int flush));
                #ifndef FASTEST
                local block_state deflate_slow   OF((deflate_state *s, int flush));
                #endif
                local block_state deflate_rle    OF((deflate_state *s, int flush));
                local block_state deflate_huff   OF((deflate_state *s, int flush));
                local void lm_init        OF((deflate_state *s));
                local void putShortMSB    OF((deflate_state *s, uInt b));
                local void flush_pending  OF((z_streamp strm));
                local unsigned read_buf   OF((z_streamp strm, Bytef *buf, unsigned size));
                #ifdef ASMV
                #  pragma message("Assembler code may have bugs -- use at your own risk")
                      void match_init OF((void)); /* asm code initialization */
                      uInt longest_match  OF((deflate_state *s, IPos cur_match));
                #else
                local uInt longest_match  OF((deflate_state *s, IPos cur_match));
                #endif
                
                #ifdef ZLIB_DEBUG
                local  void check_match OF((deflate_state *s, IPos start, IPos match,
                                            int length));
                #endif
                
                /* ===========================================================================
                 * Local data
                 */
                
                #define NIL 0
                /* Tail of hash chains */
                
                #ifndef TOO_FAR
                #  define TOO_FAR 4096
                #endif
                /* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
                
                /* Values for max_lazy_match, good_match and max_chain_length, depending on
                 * the desired pack level (0..9). The values given below have been tuned to
                 * exclude worst case performance for pathological files. Better values may be
                 * found for specific files.
                 */
                typedef struct config_s {
                   ush good_length; /* reduce lazy search above this match length */
                   ush max_lazy;    /* do not perform lazy search above this match length */
                   ush nice_length; /* quit search above this match length */
                   ush max_chain;
                   compress_func func;
                } config;
                
                #ifdef FASTEST
                local const config configuration_table[2] = {
                /*      good lazy nice chain */
                /* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
                /* 1 */ {4,    4,  8,    4, deflate_fast}}; /* max speed, no lazy matches */
                #else
                local const config configuration_table[10] = {
                /*      good lazy nice chain */
                /* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
                /* 1 */ {4,    4,  8,    4, deflate_fast}, /* max speed, no lazy matches */
                /* 2 */ {4,    5, 16,    8, deflate_fast},
                /* 3 */ {4,    6, 32,   32, deflate_fast},
                
                /* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */
                /* 5 */ {8,   16, 32,   32, deflate_slow},
                /* 6 */ {8,   16, 128, 128, deflate_slow},
                /* 7 */ {8,   32, 128, 256, deflate_slow},
                /* 8 */ {32, 128, 258, 1024, deflate_slow},
                /* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* max compression */
                #endif
                
                /* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
                 * For deflate_fast() (levels <= 3) good is ignored and lazy has a different
                 * meaning.
                 */
                
                /* rank Z_BLOCK between Z_NO_FLUSH and Z_PARTIAL_FLUSH */
                #define RANK(f) (((f) * 2) - ((f) > 4 ? 9 : 0))
                
                /* ===========================================================================
                 * Update a hash value with the given input byte
                 * IN  assertion: all calls to UPDATE_HASH are made with consecutive input
                 *    characters, so that a running hash key can be computed from the previous
                 *    key instead of complete recalculation each time.
                 */
                #define UPDATE_HASH(s,h,c) (h = (((h)<<s->hash_shift) ^ (c)) & s->hash_mask)
                
                
                /* ===========================================================================
                 * Insert string str in the dictionary and set match_head to the previous head
                 * of the hash chain (the most recent string with same hash key). Return
                 * the previous length of the hash chain.
                 * If this file is compiled with -DFASTEST, the compression level is forced
                 * to 1, and no hash chains are maintained.
                 * IN  assertion: all calls to INSERT_STRING are made with consecutive input
                 *    characters and the first MIN_MATCH bytes of str are valid (except for
                 *    the last MIN_MATCH-1 bytes of the input file).
                 */
                #ifdef FASTEST
                #define INSERT_STRING(s, str, match_head) \
                   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
                    match_head = s->head[s->ins_h], \
                    s->head[s->ins_h] = (Pos)(str))
                #else
                #define INSERT_STRING(s, str, match_head) \
                   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
                    match_head = s->prev[(str) & s->w_mask] = s->head[s->ins_h], \
                    s->head[s->ins_h] = (Pos)(str))
                #endif
                
                /* ===========================================================================
                 * Initialize the hash table (avoiding 64K overflow for 16 bit systems).
                 * prev[] will be initialized on the fly.
                 */
                #define CLEAR_HASH(s) \
                    s->head[s->hash_size-1] = NIL; \
                    zmemzero((Bytef *)s->head, (unsigned)(s->hash_size-1)*sizeof(*s->head));
                
                /* ===========================================================================
                 * Slide the hash table when sliding the window down (could be avoided with 32
                 * bit values at the expense of memory usage). We slide even when level == 0 to
                 * keep the hash table consistent if we switch back to level > 0 later.
                 */
                local void slide_hash(s)
                    deflate_state *s;
       21383 -> {
                    unsigned n, m;
                    Posf *p;
                    uInt wsize = s->w_size;
                
                    n = s->hash_size;
                    p = &s->head[n];
                    do {
                        m = *--p;
                        *p = (Pos)(m >= wsize ? m - wsize : NIL);
                    } while (--n);
                    n = wsize;
                #ifndef FASTEST
                    p = &s->prev[n];
                    do {
                        m = *--p;
                        *p = (Pos)(m >= wsize ? m - wsize : NIL);
                        /* If n is not on any hash chain, prev[n] is garbage but
                         * its value will never be used.
                         */
                    } while (--n);
                #endif
                }
                
                /* ========================================================================= */
                int ZEXPORT deflateInit_(strm, level, version, stream_size)
                    z_streamp strm;
                    int level;
                    const char *version;
                    int stream_size;
       ##### -> {
                    return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
                                         Z_DEFAULT_STRATEGY, version, stream_size);
                    /* To do: ignore strm->next_in if we use it as window */
                }
                
                /* ========================================================================= */
                int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
                                  version, stream_size)
                    z_streamp strm;
                    int  level;
                    int  method;
                    int  windowBits;
                    int  memLevel;
                    int  strategy;
                    const char *version;
                    int stream_size;
           1 -> {
                    deflate_state *s;
                    int wrap = 1;
                    static const char my_version[] = ZLIB_VERSION;
                
                    ushf *overlay;
                    /* We overlay pending_buf and d_buf+l_buf. This works since the average
                     * output size for (length,distance) codes is <= 24 bits.
                     */
                
                    if (version == Z_NULL || version[0] != my_version[0] ||
                        stream_size != sizeof(z_stream)) {
                        return Z_VERSION_ERROR;
                    }
                    if (strm == Z_NULL) return Z_STREAM_ERROR;
                
                    strm->msg = Z_NULL;
                    if (strm->zalloc == (alloc_func)0) {
                #ifdef Z_SOLO
                        return Z_STREAM_ERROR;
                #else
                        strm->zalloc = zcalloc;
                        strm->opaque = (voidpf)0;
                #endif
                    }
                    if (strm->zfree == (free_func)0)
                #ifdef Z_SOLO
                        return Z_STREAM_ERROR;
                #else
                        strm->zfree = zcfree;
                #endif
                
                #ifdef FASTEST
                    if (level != 0) level = 1;
                #else
                    if (level == Z_DEFAULT_COMPRESSION) level = 6;
                #endif
                
                    if (windowBits < 0) { /* suppress zlib wrapper */
                        wrap = 0;
                        windowBits = -windowBits;
                    }
                #ifdef GZIP
                    else if (windowBits > 15) {
                        wrap = 2;       /* write gzip wrapper instead */
                        windowBits -= 16;
                    }
                #endif
                    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
                        windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
                        strategy < 0 || strategy > Z_FIXED || (windowBits == 8 && wrap != 1)) {
                        return Z_STREAM_ERROR;
                    }
                    if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */
                    s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));
                    if (s == Z_NULL) return Z_MEM_ERROR;
                    strm->state = (struct internal_state FAR *)s;
                    s->strm = strm;
                    s->status = INIT_STATE;     /* to pass state test in deflateReset() */
                
                    s->wrap = wrap;
                    s->gzhead = Z_NULL;
                    s->w_bits = (uInt)windowBits;
                    s->w_size = 1 << s->w_bits;
                    s->w_mask = s->w_size - 1;
                
                    s->hash_bits = (uInt)memLevel + 7;
                    s->hash_size = 1 << s->hash_bits;
                    s->hash_mask = s->hash_size - 1;
                    s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);
                
                    s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));
                    s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));
                    s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));
                
                    s->high_water = 0;      /* nothing written to s->window yet */
                
                    s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */
                
                    overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
                    s->pending_buf = (uchf *) overlay;
                    s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);
                
                    if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
                        s->pending_buf == Z_NULL) {
                        s->status = FINISH_STATE;
                        strm->msg = ERR_MSG(Z_MEM_ERROR);
                        deflateEnd (strm);
                        return Z_MEM_ERROR;
                    }
                    s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
                    s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
                
                    s->level = level;
                    s->strategy = strategy;
                    s->method = (Byte)method;
                
                    return deflateReset(strm);
                }
                
                /* =========================================================================
                 * Check for a valid deflate stream state. Return 0 if ok, 1 if not.
                 */
                local int deflateStateCheck (strm)
                    z_streamp strm;
      111328 -> {
                    deflate_state *s;
                    if (strm == Z_NULL ||
                        strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)
                        return 1;
                    s = strm->state;
                    if (s == Z_NULL || s->strm != strm || (s->status != INIT_STATE &&
                #ifdef GZIP
                                                           s->status != GZIP_STATE &&
                #endif
                                                           s->status != EXTRA_STATE &&
                                                           s->status != NAME_STATE &&
                                                           s->status != COMMENT_STATE &&
                                                           s->status != HCRC_STATE &&
                                                           s->status != BUSY_STATE &&
                                                           s->status != FINISH_STATE))
                        return 1;
                    return 0;
                }
                
                /* ========================================================================= */
                int ZEXPORT deflateSetDictionary (strm, dictionary, dictLength)
                    z_streamp strm;
                    const Bytef *dictionary;
                    uInt  dictLength;
       ##### -> {
                    deflate_state *s;
                    uInt str, n;
                    int wrap;
                    unsigned avail;
                    z_const unsigned char *next;
                
                    if (deflateStateCheck(strm) || dictionary == Z_NULL)
                        return Z_STREAM_ERROR;
                    s = strm->state;
                    wrap = s->wrap;
                    if (wrap == 2 || (wrap == 1 && s->status != INIT_STATE) || s->lookahead)
                        return Z_STREAM_ERROR;
                
                    /* when using zlib wrappers, compute Adler-32 for provided dictionary */
                    if (wrap == 1)
                        strm->adler = adler32(strm->adler, dictionary, dictLength);
                    s->wrap = 0;                    /* avoid computing Adler-32 in read_buf */
                
                    /* if dictionary would fill window, just replace the history */
                    if (dictLength >= s->w_size) {
                        if (wrap == 0) {            /* already empty otherwise */
                            CLEAR_HASH(s);
                            s->strstart = 0;
                            s->block_start = 0L;
                            s->insert = 0;
                        }
                        dictionary += dictLength - s->w_size;  /* use the tail */
                        dictLength = s->w_size;
                    }
                
                    /* insert dictionary into window and hash */
                    avail = strm->avail_in;
                    next = strm->next_in;
                    strm->avail_in = dictLength;
                    strm->next_in = (z_const Bytef *)dictionary;
                    fill_window(s);
                    while (s->lookahead >= MIN_MATCH) {
                        str = s->strstart;
                        n = s->lookahead - (MIN_MATCH-1);
                        do {
                            UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);
                #ifndef FASTEST
                            s->prev[str & s->w_mask] = s->head[s->ins_h];
                #endif
                            s->head[s->ins_h] = (Pos)str;
                            str++;
                        } while (--n);
                        s->strstart = str;
                        s->lookahead = MIN_MATCH-1;
                        fill_window(s);
                    }
                    s->strstart += s->lookahead;
                    s->block_start = (long)s->strstart;
                    s->insert = s->lookahead;
                    s->lookahead = 0;
                    s->match_length = s->prev_length = MIN_MATCH-1;
                    s->match_available = 0;
                    strm->next_in = next;
                    strm->avail_in = avail;
                    s->wrap = wrap;
                    return Z_OK;
                }
                
                /* ========================================================================= */
                int ZEXPORT deflateGetDictionary (strm, dictionary, dictLength)
                    z_streamp strm;
                    Bytef *dictionary;
                    uInt  *dictLength;
       ##### -> {
                    deflate_state *s;
                    uInt len;
                
                    if (deflateStateCheck(strm))
                        return Z_STREAM_ERROR;
                    s = strm->state;
                    len = s->strstart + s->lookahead;
                    if (len > s->w_size)
                        len = s->w_size;
                    if (dictionary != Z_NULL && len)
                        zmemcpy(dictionary, s->window + s->strstart + s->lookahead - len, len);
                    if (dictLength != Z_NULL)
                        *dictLength = len;
                    return Z_OK;
                }
                
                /* ========================================================================= */
                int ZEXPORT deflateResetKeep (strm)
                    z_streamp strm;
           2 -> {
                    deflate_state *s;
                
                    if (deflateStateCheck(strm)) {
                        return Z_STREAM_ERROR;
                    }
                
                    strm->total_in = strm->total_out = 0;
                    strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */
                    strm->data_type = Z_UNKNOWN;
                
                    s = (deflate_state *)strm->state;
                    s->pending = 0;
                    s->pending_out = s->pending_buf;
                
                    if (s->wrap < 0) {
                        s->wrap = -s->wrap; /* was made negative by deflate(..., Z_FINISH); */
                    }
                    s->status =
                #ifdef GZIP
                        s->wrap == 2 ? GZIP_STATE :
                #endif
                        s->wrap ? INIT_STATE : BUSY_STATE;
                    strm->adler =
                #ifdef GZIP
                        s->wrap == 2 ? crc32(0L, Z_NULL, 0) :
                #endif
                        adler32(0L, Z_NULL, 0);
                    s->last_flush = Z_NO_FLUSH;
                
                    _tr_init(s);
                
                    return Z_OK;
                }
                
                /* ========================================================================= */
                int ZEXPORT deflateReset (strm)
                    z_streamp strm;
           2 -> {
                    int ret;
                
                    ret = deflateResetKeep(strm);
                    if (ret == Z_OK)
                        lm_init(strm->state);
                    return ret;
                }
                
                /* ========================================================================= */
                int ZEXPORT deflateSetHeader (strm, head)
                    z_streamp strm;
                    gz_headerp head;
       ##### -> {
                    if (deflateStateCheck(strm) || strm->state->wrap != 2)
                        return Z_STREAM_ERROR;
                    strm->state->gzhead = head;
                    return Z_OK;
                }
                
                /* ========================================================================= */
                int ZEXPORT deflatePending (strm, pending, bits)
                    unsigned *pending;
                    int *bits;
                    z_streamp strm;
       ##### -> {
                    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
                    if (pending != Z_NULL)
                        *pending = strm->state->pending;
                    if (bits != Z_NULL)
                        *bits = strm->state->bi_valid;
                    return Z_OK;
                }
                
                /* ========================================================================= */
                int ZEXPORT deflatePrime (strm, bits, value)
                    z_streamp strm;
                    int bits;
                    int value;
       ##### -> {
                    deflate_state *s;
                    int put;
                
                    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
                    s = strm->state;
                    if ((Bytef *)(s->d_buf) < s->pending_out + ((Buf_size + 7) >> 3))
                        return Z_BUF_ERROR;
                    do {
                        put = Buf_size - s->bi_valid;
                        if (put > bits)
                            put = bits;
                        s->bi_buf |= (ush)((value & ((1 << put) - 1)) << s->bi_valid);
                        s->bi_valid += put;
                        _tr_flush_bits(s);
                        value >>= put;
                        bits -= put;
                    } while (bits);
                    return Z_OK;
                }
                
                /* ========================================================================= */
                int ZEXPORT deflateParams(strm, level, strategy)
                    z_streamp strm;
                    int level;
                    int strategy;
       ##### -> {
                    deflate_state *s;
                    compress_func func;
                
                    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
                    s = strm->state;
                
                #ifdef FASTEST
                    if (level != 0) level = 1;
                #else
                    if (level == Z_DEFAULT_COMPRESSION) level = 6;
                #endif
                    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
                        return Z_STREAM_ERROR;
                    }
                    func = configuration_table[s->level].func;
                
                    if ((strategy != s->strategy || func != configuration_table[level].func) &&
                        s->high_water) {
                        /* Flush the last buffer: */
                        int err = deflate(strm, Z_BLOCK);
                        if (err == Z_STREAM_ERROR)
                            return err;
                        if (strm->avail_out == 0)
                            return Z_BUF_ERROR;
                    }
                    if (s->level != level) {
                        if (s->level == 0 && s->matches != 0) {
                            if (s->matches == 1)
                                slide_hash(s);
                            else
                                CLEAR_HASH(s);
                            s->matches = 0;
                        }
                        s->level = level;
                        s->max_lazy_match   = configuration_table[level].max_lazy;
                        s->good_match       = configuration_table[level].good_length;
                        s->nice_match       = configuration_table[level].nice_length;
                        s->max_chain_length = configuration_table[level].max_chain;
                    }
                    s->strategy = strategy;
                    return Z_OK;
                }
                
                /* ========================================================================= */
                int ZEXPORT deflateTune(strm, good_length, max_lazy, nice_length, max_chain)
                    z_streamp strm;
                    int good_length;
                    int max_lazy;
                    int nice_length;
                    int max_chain;
       ##### -> {
                    deflate_state *s;
                
                    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
                    s = strm->state;
                    s->good_match = (uInt)good_length;
                    s->max_lazy_match = (uInt)max_lazy;
                    s->nice_match = nice_length;
                    s->max_chain_length = (uInt)max_chain;
                    return Z_OK;
                }
                
                /* =========================================================================
                 * For the default windowBits of 15 and memLevel of 8, this function returns
                 * a close to exact, as well as small, upper bound on the compressed size.
                 * They are coded as constants here for a reason--if the #define's are
                 * changed, then this function needs to be changed as well.  The return
                 * value for 15 and 8 only works for those exact settings.
                 *
                 * For any setting other than those defaults for windowBits and memLevel,
                 * the value returned is a conservative worst case for the maximum expansion
                 * resulting from using fixed blocks instead of stored blocks, which deflate
                 * can emit on compressed data for some combinations of the parameters.
                 *
                 * This function could be more sophisticated to provide closer upper bounds for
                 * every combination of windowBits and memLevel.  But even the conservative
                 * upper bound of about 14% expansion does not seem onerous for output buffer
                 * allocation.
                 */
                uLong ZEXPORT deflateBound(strm, sourceLen)
                    z_streamp strm;
                    uLong sourceLen;
       ##### -> {
                    deflate_state *s;
                    uLong complen, wraplen;
                
                    /* conservative upper bound for compressed data */
                    complen = sourceLen +
                              ((sourceLen + 7) >> 3) + ((sourceLen + 63) >> 6) + 5;
                
                    /* if can't get parameters, return conservative bound plus zlib wrapper */
                    if (deflateStateCheck(strm))
                        return complen + 6;
                
                    /* compute wrapper length */
                    s = strm->state;
                    switch (s->wrap) {
                    case 0:                                 /* raw deflate */
                        wraplen = 0;
                        break;
                    case 1:                                 /* zlib wrapper */
                        wraplen = 6 + (s->strstart ? 4 : 0);
                        break;
                #ifdef GZIP
                    case 2:                                 /* gzip wrapper */
                        wraplen = 18;
                        if (s->gzhead != Z_NULL) {          /* user-supplied gzip header */
                            Bytef *str;
                            if (s->gzhead->extra != Z_NULL)
                                wraplen += 2 + s->gzhead->extra_len;
                            str = s->gzhead->name;
                            if (str != Z_NULL)
                                do {
                                    wraplen++;
                                } while (*str++);
                            str = s->gzhead->comment;
                            if (str != Z_NULL)
                                do {
                                    wraplen++;
                                } while (*str++);
                            if (s->gzhead->hcrc)
                                wraplen += 2;
                        }
                        break;
                #endif
                    default:                                /* for compiler happiness */
                        wraplen = 6;
                    }
                
                    /* if not default parameters, return conservative bound */
                    if (s->w_bits != 15 || s->hash_bits != 8 + 7)
                        return complen + wraplen;
                
                    /* default settings: return tight bound for that case */
                    return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +
                           (sourceLen >> 25) + 13 - 6 + wraplen;
                }
                
                /* =========================================================================
                 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
                 * IN assertion: the stream state is correct and there is enough room in
                 * pending_buf.
                 */
                local void putShortMSB (s, b)
                    deflate_state *s;
                    uInt b;
       ##### -> {
                    put_byte(s, (Byte)(b >> 8));
                    put_byte(s, (Byte)(b & 0xff));
                }
                
                /* =========================================================================
                 * Flush as much pending output as possible. All deflate() output, except for
                 * some deflate_stored() output, goes through this function so some
                 * applications may wish to modify it to avoid allocating a large
                 * strm->next_out buffer and copying into it. (See also read_buf()).
                 */
                local void flush_pending(strm)
                    z_streamp strm;
       25788 -> {
                    unsigned len;
                    deflate_state *s = strm->state;
                
                    _tr_flush_bits(s);
                    len = s->pending;
                    if (len > strm->avail_out) len = strm->avail_out;
                    if (len == 0) return;
                
                    zmemcpy(strm->next_out, s->pending_out, len);
                    strm->next_out  += len;
                    s->pending_out  += len;
                    strm->total_out += len;
                    strm->avail_out -= len;
                    s->pending      -= len;
                    if (s->pending == 0) {
                        s->pending_out = s->pending_buf;
                    }
                }
                
                /* ===========================================================================
                 * Update the header CRC with the bytes s->pending_buf[beg..s->pending - 1].
                 */
                #define HCRC_UPDATE(beg) \
                    do { \
                        if (s->gzhead->hcrc && s->pending > (beg)) \
                            strm->adler = crc32(strm->adler, s->pending_buf + (beg), \
                                                s->pending - (beg)); \
                    } while (0)
                
                /* ========================================================================= */
                int ZEXPORT deflate (strm, flush)
                    z_streamp strm;
                    int flush;
      111325 -> {
                    int old_flush; /* value of flush param for previous deflate call */
                    deflate_state *s;
                
                    if (deflateStateCheck(strm) || flush > Z_BLOCK || flush < 0) {
                        return Z_STREAM_ERROR;
                    }
                    s = strm->state;
                
                    if (strm->next_out == Z_NULL ||
                        (strm->avail_in != 0 && strm->next_in == Z_NULL) ||
                        (s->status == FINISH_STATE && flush != Z_FINISH)) {
                        ERR_RETURN(strm, Z_STREAM_ERROR);
                    }
                    if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);
                
                    old_flush = s->last_flush;
                    s->last_flush = flush;
                
                    /* Flush as much pending output as possible */
                    if (s->pending != 0) {
                        flush_pending(strm);
                        if (strm->avail_out == 0) {
                            /* Since avail_out is 0, deflate will be called again with
                             * more output space, but possibly with both pending and
                             * avail_in equal to zero. There won't be anything to do,
                             * but this is not an error situation so make sure we
                             * return OK instead of BUF_ERROR at next call of deflate:
                             */
                            s->last_flush = -1;
                            return Z_OK;
                        }
                
                    /* Make sure there is something to do and avoid duplicate consecutive
                     * flushes. For repeated and useless calls with Z_FINISH, we keep
                     * returning Z_STREAM_END instead of Z_BUF_ERROR.
                     */
                    } else if (strm->avail_in == 0 && RANK(flush) <= RANK(old_flush) &&
                               flush != Z_FINISH) {
                        ERR_RETURN(strm, Z_BUF_ERROR);
                    }
                
                    /* User must not provide more input after the first FINISH: */
                    if (s->status == FINISH_STATE && strm->avail_in != 0) {
                        ERR_RETURN(strm, Z_BUF_ERROR);
                    }
                
                    /* Write the header */
                    if (s->status == INIT_STATE) {
                        /* zlib header */
                        uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;
                        uInt level_flags;
                
                        if (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2)
                            level_flags = 0;
                        else if (s->level < 6)
                            level_flags = 1;
                        else if (s->level == 6)
                            level_flags = 2;
                        else
                            level_flags = 3;
                        header |= (level_flags << 6);
                        if (s->strstart != 0) header |= PRESET_DICT;
                        header += 31 - (header % 31);
                
                        putShortMSB(s, header);
                
                        /* Save the adler32 of the preset dictionary: */
                        if (s->strstart != 0) {
                            putShortMSB(s, (uInt)(strm->adler >> 16));
                            putShortMSB(s, (uInt)(strm->adler & 0xffff));
                        }
                        strm->adler = adler32(0L, Z_NULL, 0);
                        s->status = BUSY_STATE;
                
                        /* Compression must start with an empty pending buffer */
                        flush_pending(strm);
                        if (s->pending != 0) {
                            s->last_flush = -1;
                            return Z_OK;
                        }
                    }
                #ifdef GZIP
                    if (s->status == GZIP_STATE) {
                        /* gzip header */
                        strm->adler = crc32(0L, Z_NULL, 0);
                        put_byte(s, 31);
                        put_byte(s, 139);
                        put_byte(s, 8);
                        if (s->gzhead == Z_NULL) {
                            put_byte(s, 0);
                            put_byte(s, 0);
                            put_byte(s, 0);
                            put_byte(s, 0);
                            put_byte(s, 0);
                            put_byte(s, s->level == 9 ? 2 :
                                     (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
                                      4 : 0));
                            put_byte(s, OS_CODE);
                            s->status = BUSY_STATE;
                
                            /* Compression must start with an empty pending buffer */
                            flush_pending(strm);
                            if (s->pending != 0) {
                                s->last_flush = -1;
                                return Z_OK;
                            }
                        }
                        else {
                            put_byte(s, (s->gzhead->text ? 1 : 0) +
                                     (s->gzhead->hcrc ? 2 : 0) +
                                     (s->gzhead->extra == Z_NULL ? 0 : 4) +
                                     (s->gzhead->name == Z_NULL ? 0 : 8) +
                                     (s->gzhead->comment == Z_NULL ? 0 : 16)
                                     );
                            put_byte(s, (Byte)(s->gzhead->time & 0xff));
                            put_byte(s, (Byte)((s->gzhead->time >> 8) & 0xff));
                            put_byte(s, (Byte)((s->gzhead->time >> 16) & 0xff));
                            put_byte(s, (Byte)((s->gzhead->time >> 24) & 0xff));
                            put_byte(s, s->level == 9 ? 2 :
                                     (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
                                      4 : 0));
                            put_byte(s, s->gzhead->os & 0xff);
                            if (s->gzhead->extra != Z_NULL) {
                                put_byte(s, s->gzhead->extra_len & 0xff);
                                put_byte(s, (s->gzhead->extra_len >> 8) & 0xff);
                            }
                            if (s->gzhead->hcrc)
                                strm->adler = crc32(strm->adler, s->pending_buf,
                                                    s->pending);
                            s->gzindex = 0;
                            s->status = EXTRA_STATE;
                        }
                    }
                    if (s->status == EXTRA_STATE) {
                        if (s->gzhead->extra != Z_NULL) {
                            ulg beg = s->pending;   /* start of bytes to update crc */
                            uInt left = (s->gzhead->extra_len & 0xffff) - s->gzindex;
                            while (s->pending + left > s->pending_buf_size) {
                                uInt copy = s->pending_buf_size - s->pending;
                                zmemcpy(s->pending_buf + s->pending,
                                        s->gzhead->extra + s->gzindex, copy);
                                s->pending = s->pending_buf_size;
                                HCRC_UPDATE(beg);
                                s->gzindex += copy;
                                flush_pending(strm);
                                if (s->pending != 0) {
                                    s->last_flush = -1;
                                    return Z_OK;
                                }
                                beg = 0;
                                left -= copy;
                            }
                            zmemcpy(s->pending_buf + s->pending,
                                    s->gzhead->extra + s->gzindex, left);
                            s->pending += left;
                            HCRC_UPDATE(beg);
                            s->gzindex = 0;
                        }
                        s->status = NAME_STATE;
                    }
                    if (s->status == NAME_STATE) {
                        if (s->gzhead->name != Z_NULL) {
                            ulg beg = s->pending;   /* start of bytes to update crc */
                            int val;
                            do {
                                if (s->pending == s->pending_buf_size) {
                                    HCRC_UPDATE(beg);
                                    flush_pending(strm);
                                    if (s->pending != 0) {
                                        s->last_flush = -1;
                                        return Z_OK;
                                    }
                                    beg = 0;
                                }
                                val = s->gzhead->name[s->gzindex++];
                                put_byte(s, val);
                            } while (val != 0);
                            HCRC_UPDATE(beg);
                            s->gzindex = 0;
                        }
                        s->status = COMMENT_STATE;
                    }
                    if (s->status == COMMENT_STATE) {
                        if (s->gzhead->comment != Z_NULL) {
                            ulg beg = s->pending;   /* start of bytes to update crc */
                            int val;
                            do {
                                if (s->pending == s->pending_buf_size) {
                                    HCRC_UPDATE(beg);
                                    flush_pending(strm);
                                    if (s->pending != 0) {
                                        s->last_flush = -1;
                                        return Z_OK;
                                    }
                                    beg = 0;
                                }
                                val = s->gzhead->comment[s->gzindex++];
                                put_byte(s, val);
                            } while (val != 0);
                            HCRC_UPDATE(beg);
                        }
                        s->status = HCRC_STATE;
                    }
                    if (s->status == HCRC_STATE) {
                        if (s->gzhead->hcrc) {
                            if (s->pending + 2 > s->pending_buf_size) {
                                flush_pending(strm);
                                if (s->pending != 0) {
                                    s->last_flush = -1;
                                    return Z_OK;
                                }
                            }
                            put_byte(s, (Byte)(strm->adler & 0xff));
                            put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
                            strm->adler = crc32(0L, Z_NULL, 0);
                        }
                        s->status = BUSY_STATE;
                
                        /* Compression must start with an empty pending buffer */
                        flush_pending(strm);
                        if (s->pending != 0) {
                            s->last_flush = -1;
                            return Z_OK;
                        }
                    }
                #endif
                
                    /* Start a new block or continue the current one.
                     */
                    if (strm->avail_in != 0 || s->lookahead != 0 ||
                        (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
                        block_state bstate;
                
                        bstate = s->level == 0 ? deflate_stored(s, flush) :
                                 s->strategy == Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :
                                 s->strategy == Z_RLE ? deflate_rle(s, flush) :
                                 (*(configuration_table[s->level].func))(s, flush);
                
                        if (bstate == finish_started || bstate == finish_done) {
                            s->status = FINISH_STATE;
                        }
                        if (bstate == need_more || bstate == finish_started) {
                            if (strm->avail_out == 0) {
                                s->last_flush = -1; /* avoid BUF_ERROR next call, see above */
                            }
                            return Z_OK;
                            /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
                             * of deflate should use the same flush parameter to make sure
                             * that the flush is complete. So we don't have to output an
                             * empty block here, this will be done at next call. This also
                             * ensures that for a very small output buffer, we emit at most
                             * one empty block.
                             */
                        }
                        if (bstate == block_done) {
                            if (flush == Z_PARTIAL_FLUSH) {
                                _tr_align(s);
                            } else if (flush != Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */
                                _tr_stored_block(s, (char*)0, 0L, 0);
                                /* For a full flush, this empty block will be recognized
                                 * as a special marker by inflate_sync().
                                 */
                                if (flush == Z_FULL_FLUSH) {
                                    CLEAR_HASH(s);             /* forget history */
                                    if (s->lookahead == 0) {
                                        s->strstart = 0;
                                        s->block_start = 0L;
                                        s->insert = 0;
                                    }
                                }
                            }
                            flush_pending(strm);
                            if (strm->avail_out == 0) {
                              s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
                              return Z_OK;
                            }
                        }
                    }
                
                    if (flush != Z_FINISH) return Z_OK;
                    if (s->wrap <= 0) return Z_STREAM_END;
                
                    /* Write the trailer */
                #ifdef GZIP
                    if (s->wrap == 2) {
                        put_byte(s, (Byte)(strm->adler & 0xff));
                        put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
                        put_byte(s, (Byte)((strm->adler >> 16) & 0xff));
                        put_byte(s, (Byte)((strm->adler >> 24) & 0xff));
                        put_byte(s, (Byte)(strm->total_in & 0xff));
                        put_byte(s, (Byte)((strm->total_in >> 8) & 0xff));
                        put_byte(s, (Byte)((strm->total_in >> 16) & 0xff));
                        put_byte(s, (Byte)((strm->total_in >> 24) & 0xff));
                    }
                    else
                #endif
                    {
                        putShortMSB(s, (uInt)(strm->adler >> 16));
                        putShortMSB(s, (uInt)(strm->adler & 0xffff));
                    }
                    flush_pending(strm);
                    /* If avail_out is zero, the application will call deflate again
                     * to flush the rest.
                     */
                    if (s->wrap > 0) s->wrap = -s->wrap; /* write the trailer only once! */
                    return s->pending != 0 ? Z_OK : Z_STREAM_END;
                }
                
                /* ========================================================================= */
                int ZEXPORT deflateEnd (strm)
                    z_streamp strm;
           1 -> {
                    int status;
                
                    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
                
                    status = strm->state->status;
                
                    /* Deallocate in reverse order of allocations: */
                    TRY_FREE(strm, strm->state->pending_buf);
                    TRY_FREE(strm, strm->state->head);
                    TRY_FREE(strm, strm->state->prev);
                    TRY_FREE(strm, strm->state->window);
                
                    ZFREE(strm, strm->state);
                    strm->state = Z_NULL;
                
                    return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
                }
                
                /* =========================================================================
                 * Copy the source state to the destination state.
                 * To simplify the source, this is not supported for 16-bit MSDOS (which
                 * doesn't have enough memory anyway to duplicate compression states).
                 */
                int ZEXPORT deflateCopy (dest, source)
                    z_streamp dest;
                    z_streamp source;
       ##### -> {
                #ifdef MAXSEG_64K
                    return Z_STREAM_ERROR;
                #else
                    deflate_state *ds;
                    deflate_state *ss;
                    ushf *overlay;
                
                
                    if (deflateStateCheck(source) || dest == Z_NULL) {
                        return Z_STREAM_ERROR;
                    }
                
                    ss = source->state;
                
                    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));
                
                    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));
                    if (ds == Z_NULL) return Z_MEM_ERROR;
                    dest->state = (struct internal_state FAR *) ds;
                    zmemcpy((voidpf)ds, (voidpf)ss, sizeof(deflate_state));
                    ds->strm = dest;
                
                    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));
                    ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));
                    ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));
                    overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);
                    ds->pending_buf = (uchf *) overlay;
                
                    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||
                        ds->pending_buf == Z_NULL) {
                        deflateEnd (dest);
                        return Z_MEM_ERROR;
                    }
                    /* following zmemcpy do not work for 16-bit MSDOS */
                    zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));
                    zmemcpy((voidpf)ds->prev, (voidpf)ss->prev, ds->w_size * sizeof(Pos));
                    zmemcpy((voidpf)ds->head, (voidpf)ss->head, ds->hash_size * sizeof(Pos));
                    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);
                
                    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);
                    ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);
                    ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;
                
                    ds->l_desc.dyn_tree = ds->dyn_ltree;
                    ds->d_desc.dyn_tree = ds->dyn_dtree;
                    ds->bl_desc.dyn_tree = ds->bl_tree;
                
                    return Z_OK;
                #endif /* MAXSEG_64K */
                }
                
                /* ===========================================================================
                 * Read a new buffer from the current input stream, update the adler32
                 * and total number of bytes read.  All deflate() input goes through
                 * this function so some applications may wish to modify it to avoid
                 * allocating a large strm->next_in buffer and copying from it.
                 * (See also flush_pending()).
                 */
                local unsigned read_buf(strm, buf, size)
                    z_streamp strm;
                    Bytef *buf;
                    unsigned size;
       85538 -> {
                    unsigned len = strm->avail_in;
                
                    if (len > size) len = size;
                    if (len == 0) return 0;
                
                    strm->avail_in  -= len;
                
                    zmemcpy(buf, strm->next_in, len);
                    if (strm->state->wrap == 1) {
                        strm->adler = adler32(strm->adler, buf, len);
                    }
                #ifdef GZIP
                    else if (strm->state->wrap == 2) {
                        strm->adler = crc32(strm->adler, buf, len);
                    }
                #endif
                    strm->next_in  += len;
                    strm->total_in += len;
                
                    return len;
                }
                
                /* ===========================================================================
                 * Initialize the "longest match" routines for a new zlib stream
                 */
                local void lm_init (s)
                    deflate_state *s;
           2 -> {
                    s->window_size = (ulg)2L*s->w_size;
                
                    CLEAR_HASH(s);
                
                    /* Set the default configuration parameters:
                     */
                    s->max_lazy_match   = configuration_table[s->level].max_lazy;
                    s->good_match       = configuration_table[s->level].good_length;
                    s->nice_match       = configuration_table[s->level].nice_length;
                    s->max_chain_length = configuration_table[s->level].max_chain;
                
                    s->strstart = 0;
                    s->block_start = 0L;
                    s->lookahead = 0;
                    s->insert = 0;
                    s->match_length = s->prev_length = MIN_MATCH-1;
                    s->match_available = 0;
                    s->ins_h = 0;
                #ifndef FASTEST
                #ifdef ASMV
                    match_init(); /* initialize the asm code */
                #endif
                #endif
                }
                
                #ifndef FASTEST
                /* ===========================================================================
                 * Set match_start to the longest match starting at the given string and
                 * return its length. Matches shorter or equal to prev_length are discarded,
                 * in which case the result is equal to prev_length and match_start is
                 * garbage.
                 * IN assertions: cur_match is the head of the hash chain for the current
                 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
                 * OUT assertion: the match length is not greater than s->lookahead.
                 */
                #ifndef ASMV
                /* For 80x86 and 680x0, an optimized version will be provided in match.asm or
                 * match.S. The code will be functionally equivalent.
                 */
                local uInt longest_match(s, cur_match)
                    deflate_state *s;
                    IPos cur_match;                             /* current match */
   135725603 -> {
                    unsigned chain_length = s->max_chain_length;/* max hash chain length */
                    register Bytef *scan = s->window + s->strstart; /* current string */
                    register Bytef *match;                      /* matched string */
                    register int len;                           /* length of current match */
                    int best_len = (int)s->prev_length;         /* best match length so far */
                    int nice_match = s->nice_match;             /* stop if match long enough */
                    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
                        s->strstart - (IPos)MAX_DIST(s) : NIL;
                    /* Stop when cur_match becomes <= limit. To simplify the code,
                     * we prevent matches with the string of window index 0.
                     */
                    Posf *prev = s->prev;
                    uInt wmask = s->w_mask;
                
                #ifdef UNALIGNED_OK
                    /* Compare two bytes at a time. Note: this is not always beneficial.
                     * Try with and without -DUNALIGNED_OK to check.
                     */
                    register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;
                    register ush scan_start = *(ushf*)scan;
                    register ush scan_end   = *(ushf*)(scan+best_len-1);
                #else
                    register Bytef *strend = s->window + s->strstart + MAX_MATCH;
                    register Byte scan_end1  = scan[best_len-1];
                    register Byte scan_end   = scan[best_len];
                #endif
                
                    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
                     * It is easy to get rid of this optimization if necessary.
                     */
                    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
                
                    /* Do not waste too much time if we already have a good match: */
                    if (s->prev_length >= s->good_match) {
                        chain_length >>= 2;
                    }
                    /* Do not look for matches beyond the end of the input. This is necessary
                     * to make deflate deterministic.
                     */
                    if ((uInt)nice_match > s->lookahead) nice_match = (int)s->lookahead;
                
                    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
                
                    do {
                        Assert(cur_match < s->strstart, "no future");
                        match = s->window + cur_match;
                
                        /* Skip to next match if the match length cannot increase
                         * or if the match length is less than 2.  Note that the checks below
                         * for insufficient lookahead only occur occasionally for performance
                         * reasons.  Therefore uninitialized memory will be accessed, and
                         * conditional jumps will be made that depend on those values.
                         * However the length of the match is limited to the lookahead, so
                         * the output of deflate is not affected by the uninitialized values.
                         */
                #if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
                        /* This code assumes sizeof(unsigned short) == 2. Do not use
                         * UNALIGNED_OK if your compiler uses a different size.
                         */
                        if (*(ushf*)(match+best_len-1) != scan_end ||
                            *(ushf*)match != scan_start) continue;
                
                        /* It is not necessary to compare scan[2] and match[2] since they are
                         * always equal when the other bytes match, given that the hash keys
                         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
                         * strstart+3, +5, ... up to strstart+257. We check for insufficient
                         * lookahead only every 4th comparison; the 128th check will be made
                         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
                         * necessary to put more guard bytes at the end of the window, or
                         * to check more often for insufficient lookahead.
                         */
                        Assert(scan[2] == match[2], "scan[2]?");
                        scan++, match++;
                        do {
                        } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                                 scan < strend);
                        /* The funny "do {}" generates better code on most compilers */
                
                        /* Here, scan <= window+strstart+257 */
                        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
                        if (*scan == *match) scan++;
                
                        len = (MAX_MATCH - 1) - (int)(strend-scan);
                        scan = strend - (MAX_MATCH-1);
                
                #else /* UNALIGNED_OK */
                
                        if (match[best_len]   != scan_end  ||
                            match[best_len-1] != scan_end1 ||
                            *match            != *scan     ||
                            *++match          != scan[1])      continue;
                
                        /* The check at best_len-1 can be removed because it will be made
                         * again later. (This heuristic is not always a win.)
                         * It is not necessary to compare scan[2] and match[2] since they
                         * are always equal when the other bytes match, given that
                         * the hash keys are equal and that HASH_BITS >= 8.
                         */
                        scan += 2, match++;
                        Assert(*scan == *match, "match[2]?");
                
                        /* We check for insufficient lookahead only every 8th comparison;
                         * the 256th check will be made at strstart+258.
                         */
                        do {
                        } while (*++scan == *++match && *++scan == *++match &&
                                 *++scan == *++match && *++scan == *++match &&
                                 *++scan == *++match && *++scan == *++match &&
                                 *++scan == *++match && *++scan == *++match &&
                                 scan < strend);
                
                        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
                
                        len = MAX_MATCH - (int)(strend - scan);
                        scan = strend - MAX_MATCH;
                
                #endif /* UNALIGNED_OK */
                
                        if (len > best_len) {
                            s->match_start = cur_match;
                            best_len = len;
                            if (len >= nice_match) break;
                #ifdef UNALIGNED_OK
                            scan_end = *(ushf*)(scan+best_len-1);
                #else
                            scan_end1  = scan[best_len-1];
                            scan_end   = scan[best_len];
                #endif
                        }
                    } while ((cur_match = prev[cur_match & wmask]) > limit
                             && --chain_length != 0);
                
                    if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
                    return s->lookahead;
                }
                #endif /* ASMV */
                
                #else /* FASTEST */
                
                /* ---------------------------------------------------------------------------
                 * Optimized version for FASTEST only
                 */
                local uInt longest_match(s, cur_match)
                    deflate_state *s;
                    IPos cur_match;                             /* current match */
                {
                    register Bytef *scan = s->window + s->strstart; /* current string */
                    register Bytef *match;                       /* matched string */
                    register int len;                           /* length of current match */
                    register Bytef *strend = s->window + s->strstart + MAX_MATCH;
                
                    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
                     * It is easy to get rid of this optimization if necessary.
                     */
                    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
                
                    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
                
                    Assert(cur_match < s->strstart, "no future");
                
                    match = s->window + cur_match;
                
                    /* Return failure if the match length is less than 2:
                     */
                    if (match[0] != scan[0] || match[1] != scan[1]) return MIN_MATCH-1;
                
                    /* The check at best_len-1 can be removed because it will be made
                     * again later. (This heuristic is not always a win.)
                     * It is not necessary to compare scan[2] and match[2] since they
                     * are always equal when the other bytes match, given that
                     * the hash keys are equal and that HASH_BITS >= 8.
                     */
                    scan += 2, match += 2;
                    Assert(*scan == *match, "match[2]?");
                
                    /* We check for insufficient lookahead only every 8th comparison;
                     * the 256th check will be made at strstart+258.
                     */
                    do {
                    } while (*++scan == *++match && *++scan == *++match &&
                             *++scan == *++match && *++scan == *++match &&
                             *++scan == *++match && *++scan == *++match &&
                             *++scan == *++match && *++scan == *++match &&
                             scan < strend);
                
                    Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
                
                    len = MAX_MATCH - (int)(strend - scan);
                
                    if (len < MIN_MATCH) return MIN_MATCH - 1;
                
                    s->match_start = cur_match;
                    return (uInt)len <= s->lookahead ? (uInt)len : s->lookahead;
                }
                
                #endif /* FASTEST */
                
                #ifdef ZLIB_DEBUG
                
                #define EQUAL 0
                /* result of memcmp for equal strings */
                
                /* ===========================================================================
                 * Check that the match at match_start is indeed a match.
                 */
                local void check_match(s, start, match, length)
                    deflate_state *s;
                    IPos start, match;
                    int length;
    61613127 -> {
                    /* check that the match is indeed a match */
                    if (zmemcmp(s->window + match,
                                s->window + start, length) != EQUAL) {
                        fprintf(stderr, " start %u, match %u, length %d\n",
                                start, match, length);
                        do {
                            fprintf(stderr, "%c%c", s->window[match++], s->window[start++]);
                        } while (--length != 0);
                        z_error("invalid match");
                    }
                    if (z_verbose > 1) {
                        fprintf(stderr,"\\[%d,%d]", start-match, length);
                        do { putc(s->window[start++], stderr); } while (--length != 0);
                    }
                }
                #else
                #  define check_match(s, start, match, length)
                #endif /* ZLIB_DEBUG */
                
                /* ===========================================================================
                 * Fill the window when the lookahead becomes insufficient.
                 * Updates strstart and lookahead.
                 *
                 * IN assertion: lookahead < MIN_LOOKAHEAD
                 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
                 *    At least one byte has been read, or avail_in == 0; reads are
                 *    performed for at least two bytes (required for the zip translate_eol
                 *    option -- not supported here).
                 */
                local void fill_window(s)
                    deflate_state *s;
      171137 -> {
                    unsigned n;
                    unsigned more;    /* Amount of free space at the end of the window. */
                    uInt wsize = s->w_size;
                
                    Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");
                
                    do {
                        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);
                
                        /* Deal with !@#$% 64K limit: */
                        if (sizeof(int) <= 2) {
                            if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
                                more = wsize;
                
                            } else if (more == (unsigned)(-1)) {
                                /* Very unlikely, but possible on 16 bit machine if
                                 * strstart == 0 && lookahead == 1 (input done a byte at time)
                                 */
                                more--;
                            }
                        }
                
                        /* If the window is almost full and there is insufficient lookahead,
                         * move the upper half to the lower one to make room in the upper half.
                         */
                        if (s->strstart >= wsize+MAX_DIST(s)) {
                
                            zmemcpy(s->window, s->window+wsize, (unsigned)wsize - more);
                            s->match_start -= wsize;
                            s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
                            s->block_start -= (long) wsize;
                            slide_hash(s);
                            more += wsize;
                        }
                        if (s->strm->avail_in == 0) break;
                
                        /* If there was no sliding:
                         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
                         *    more == window_size - lookahead - strstart
                         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
                         * => more >= window_size - 2*WSIZE + 2
                         * In the BIG_MEM or MMAP case (not yet supported),
                         *   window_size == input_size + MIN_LOOKAHEAD  &&
                         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
                         * Otherwise, window_size == 2*WSIZE so more >= 2.
                         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
                         */
                        Assert(more >= 2, "more < 2");
                
                        n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);
                        s->lookahead += n;
                
                        /* Initialize the hash value now that we have some input: */
                        if (s->lookahead + s->insert >= MIN_MATCH) {
                            uInt str = s->strstart - s->insert;
                            s->ins_h = s->window[str];
                            UPDATE_HASH(s, s->ins_h, s->window[str + 1]);
                #if MIN_MATCH != 3
                            Call UPDATE_HASH() MIN_MATCH-3 more times
                #endif
                            while (s->insert) {
                                UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);
                #ifndef FASTEST
                                s->prev[str & s->w_mask] = s->head[s->ins_h];
                #endif
                                s->head[s->ins_h] = (Pos)str;
                                str++;
                                s->insert--;
                                if (s->lookahead + s->insert < MIN_MATCH)
                                    break;
                            }
                        }
                        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
                         * but this is not important since only literal bytes will be emitted.
                         */
                
                    } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);
                
                    /* If the WIN_INIT bytes after the end of the current data have never been
                     * written, then zero those bytes in order to avoid memory check reports of
                     * the use of uninitialized (or uninitialised as Julian writes) bytes by
                     * the longest match routines.  Update the high water mark for the next
                     * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
                     * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
                     */
                    if (s->high_water < s->window_size) {
                        ulg curr = s->strstart + (ulg)(s->lookahead);
                        ulg init;
                
                        if (s->high_water < curr) {
                            /* Previous high water mark below current data -- zero WIN_INIT
                             * bytes or up to end of window, whichever is less.
                             */
                            init = s->window_size - curr;
                            if (init > WIN_INIT)
                                init = WIN_INIT;
                            zmemzero(s->window + curr, (unsigned)init);
                            s->high_water = curr + init;
                        }
                        else if (s->high_water < (ulg)curr + WIN_INIT) {
                            /* High water mark at or above current data, but below current data
                             * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
                             * to end of window, whichever is less.
                             */
                            init = (ulg)curr + WIN_INIT - s->high_water;
                            if (init > s->window_size - s->high_water)
                                init = s->window_size - s->high_water;
                            zmemzero(s->window + s->high_water, (unsigned)init);
                            s->high_water += init;
                        }
                    }
                
                    Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
                           "not enough room for search");
                }
                
                /* ===========================================================================
                 * Flush the current block, with given end-of-file flag.
                 * IN assertion: strstart is set to the end of the current match.
                 */
                #define FLUSH_BLOCK_ONLY(s, last) { \
                   _tr_flush_block(s, (s->block_start >= 0L ? \
                                   (charf *)&s->window[(unsigned)s->block_start] : \
                                   (charf *)Z_NULL), \
                                (ulg)((long)s->strstart - s->block_start), \
                                (last)); \
                   s->block_start = s->strstart; \
                   flush_pending(s->strm); \
                   Tracev((stderr,"[FLUSH]")); \
                }
                
                /* Same but force premature exit if necessary. */
                #define FLUSH_BLOCK(s, last) { \
                   FLUSH_BLOCK_ONLY(s, last); \
                   if (s->strm->avail_out == 0) return (last) ? finish_started : need_more; \
                }
                
                /* Maximum stored block length in deflate format (not including header). */
                #define MAX_STORED 65535
                
                /* Minimum of a and b. */
                #define MIN(a, b) ((a) > (b) ? (b) : (a))
                
                /* ===========================================================================
                 * Copy without compression as much as possible from the input stream, return
                 * the current block state.
                 *
                 * In case deflateParams() is used to later switch to a non-zero compression
                 * level, s->matches (otherwise unused when storing) keeps track of the number
                 * of hash table slides to perform. If s->matches is 1, then one hash table
                 * slide will be done when switching. If s->matches is 2, the maximum value
                 * allowed here, then the hash table will be cleared, since two or more slides
                 * is the same as a clear.
                 *
                 * deflate_stored() is written to minimize the number of times an input byte is
                 * copied. It is most efficient with large input and output buffers, which
                 * maximizes the opportunites to have a single copy from next_in to next_out.
                 */
                local block_state deflate_stored(s, flush)
                    deflate_state *s;
                    int flush;
       ##### -> {
                    /* Smallest worthy block size when not flushing or finishing. By default
                     * this is 32K. This can be as small as 507 bytes for memLevel == 1. For
                     * large input and output buffers, the stored block size will be larger.
                     */
                    unsigned min_block = MIN(s->pending_buf_size - 5, s->w_size);
                
                    /* Copy as many min_block or larger stored blocks directly to next_out as
                     * possible. If flushing, copy the remaining available input to next_out as
                     * stored blocks, if there is enough space.
                     */
                    unsigned len, left, have, last = 0;
                    unsigned used = s->strm->avail_in;
                    do {
                        /* Set len to the maximum size block that we can copy directly with the
                         * available input data and output space. Set left to how much of that
                         * would be copied from what's left in the window.
                         */
                        len = MAX_STORED;       /* maximum deflate stored block length */
                        have = (s->bi_valid + 42) >> 3;         /* number of header bytes */
                        if (s->strm->avail_out < have)          /* need room for header */
                            break;
                            /* maximum stored block length that will fit in avail_out: */
                        have = s->strm->avail_out - have;
                        left = s->strstart - s->block_start;    /* bytes left in window */
                        if (len > (ulg)left + s->strm->avail_in)
                            len = left + s->strm->avail_in;     /* limit len to the input */
                        if (len > have)
                            len = have;                         /* limit len to the output */
                
                        /* If the stored block would be less than min_block in length, or if
                         * unable to copy all of the available input when flushing, then try
                         * copying to the window and the pending buffer instead. Also don't
                         * write an empty block when flushing -- deflate() does that.
                         */
                        if (len < min_block && ((len == 0 && flush != Z_FINISH) ||
                                                flush == Z_NO_FLUSH ||
                                                len != left + s->strm->avail_in))
                            break;
                
                        /* Make a dummy stored block in pending to get the header bytes,
                         * including any pending bits. This also updates the debugging counts.
                         */
                        last = flush == Z_FINISH && len == left + s->strm->avail_in ? 1 : 0;
                        _tr_stored_block(s, (char *)0, 0L, last);
                
                        /* Replace the lengths in the dummy stored block with len. */
                        s->pending_buf[s->pending - 4] = len;
                        s->pending_buf[s->pending - 3] = len >> 8;
                        s->pending_buf[s->pending - 2] = ~len;
                        s->pending_buf[s->pending - 1] = ~len >> 8;
                
                        /* Write the stored block header bytes. */
                        flush_pending(s->strm);
                
                #ifdef ZLIB_DEBUG
                        /* Update debugging counts for the data about to be copied. */
                        s->compressed_len += len << 3;
                        s->bits_sent += len << 3;
                #endif
                
                        /* Copy uncompressed bytes from the window to next_out. */
                        if (left) {
                            if (left > len)
                                left = len;
                            zmemcpy(s->strm->next_out, s->window + s->block_start, left);
                            s->strm->next_out += left;
                            s->strm->avail_out -= left;
                            s->strm->total_out += left;
                            s->block_start += left;
                            len -= left;
                        }
                
                        /* Copy uncompressed bytes directly from next_in to next_out, updating
                         * the check value.
                         */
                        if (len) {
                            read_buf(s->strm, s->strm->next_out, len);
                            s->strm->next_out += len;
                            s->strm->avail_out -= len;
                            s->strm->total_out += len;
                        }
                    } while (last == 0);
                
                    /* Update the sliding window with the last s->w_size bytes of the copied
                     * data, or append all of the copied data to the existing window if less
                     * than s->w_size bytes were copied. Also update the number of bytes to
                     * insert in the hash tables, in the event that deflateParams() switches to
                     * a non-zero compression level.
                     */
                    used -= s->strm->avail_in;      /* number of input bytes directly copied */
                    if (used) {
                        /* If any input was used, then no unused input remains in the window,
                         * therefore s->block_start == s->strstart.
                         */
                        if (used >= s->w_size) {    /* supplant the previous history */
                            s->matches = 2;         /* clear hash */
                            zmemcpy(s->window, s->strm->next_in - s->w_size, s->w_size);
                            s->strstart = s->w_size;
                        }
                        else {
                            if (s->window_size - s->strstart <= used) {
                                /* Slide the window down. */
                                s->strstart -= s->w_size;
                                zmemcpy(s->window, s->window + s->w_size, s->strstart);
                                if (s->matches < 2)
                                    s->matches++;   /* add a pending slide_hash() */
                            }
                            zmemcpy(s->window + s->strstart, s->strm->next_in - used, used);
                            s->strstart += used;
                        }
                        s->block_start = s->strstart;
                        s->insert += MIN(used, s->w_size - s->insert);
                    }
                    if (s->high_water < s->strstart)
                        s->high_water = s->strstart;
                
                    /* If the last block was written to next_out, then done. */
                    if (last)
                        return finish_done;
                
                    /* If flushing and all input has been consumed, then done. */
                    if (flush != Z_NO_FLUSH && flush != Z_FINISH &&
                        s->strm->avail_in == 0 && (long)s->strstart == s->block_start)
                        return block_done;
                
                    /* Fill the window with any remaining input. */
                    have = s->window_size - s->strstart - 1;
                    if (s->strm->avail_in > have && s->block_start >= (long)s->w_size) {
                        /* Slide the window down. */
                        s->block_start -= s->w_size;
                        s->strstart -= s->w_size;
                        zmemcpy(s->window, s->window + s->w_size, s->strstart);
                        if (s->matches < 2)
                            s->matches++;           /* add a pending slide_hash() */
                        have += s->w_size;          /* more space now */
                    }
                    if (have > s->strm->avail_in)
                        have = s->strm->avail_in;
                    if (have) {
                        read_buf(s->strm, s->window + s->strstart, have);
                        s->strstart += have;
                    }
                    if (s->high_water < s->strstart)
                        s->high_water = s->strstart;
                
                    /* There was not enough avail_out to write a complete worthy or flushed
                     * stored block to next_out. Write a stored block to pending instead, if we
                     * have enough input for a worthy block, or if flushing and there is enough
                     * room for the remaining input as a stored block in the pending buffer.
                     */
                    have = (s->bi_valid + 42) >> 3;         /* number of header bytes */
                        /* maximum stored block length that will fit in pending: */
                    have = MIN(s->pending_buf_size - have, MAX_STORED);
                    min_block = MIN(have, s->w_size);
                    left = s->strstart - s->block_start;
                    if (left >= min_block ||
                        ((left || flush == Z_FINISH) && flush != Z_NO_FLUSH &&
                         s->strm->avail_in == 0 && left <= have)) {
                        len = MIN(left, have);
                        last = flush == Z_FINISH && s->strm->avail_in == 0 &&
                               len == left ? 1 : 0;
                        _tr_stored_block(s, (charf *)s->window + s->block_start, len, last);
                        s->block_start += len;
                        flush_pending(s->strm);
                    }
                
                    /* We've done all we can with the available input and output. */
                    return last ? finish_started : need_more;
                }
                
                /* ===========================================================================
                 * Compress as much as possible from the input stream, return the current
                 * block state.
                 * This function does not perform lazy evaluation of matches and inserts
                 * new strings in the dictionary only for unmatched strings or for short
                 * matches. It is used only for the fast compression options.
                 */
                local block_state deflate_fast(s, flush)
                    deflate_state *s;
                    int flush;
       ##### -> {
                    IPos hash_head;       /* head of the hash chain */
                    int bflush;           /* set if current block must be flushed */
                
                    for (;;) {
                        /* Make sure that we always have enough lookahead, except
                         * at the end of the input file. We need MAX_MATCH bytes
                         * for the next match, plus MIN_MATCH bytes to insert the
                         * string following the next match.
                         */
                        if (s->lookahead < MIN_LOOKAHEAD) {
                            fill_window(s);
                            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
                                return need_more;
                            }
                            if (s->lookahead == 0) break; /* flush the current block */
                        }
                
                        /* Insert the string window[strstart .. strstart+2] in the
                         * dictionary, and set hash_head to the head of the hash chain:
                         */
                        hash_head = NIL;
                        if (s->lookahead >= MIN_MATCH) {
                            INSERT_STRING(s, s->strstart, hash_head);
                        }
                
                        /* Find the longest match, discarding those <= prev_length.
                         * At this point we have always match_length < MIN_MATCH
                         */
                        if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {
                            /* To simplify the code, we prevent matches with the string
                             * of window index 0 (in particular we have to avoid a match
                             * of the string with itself at the start of the input file).
                             */
                            s->match_length = longest_match (s, hash_head);
                            /* longest_match() sets match_start */
                        }
                        if (s->match_length >= MIN_MATCH) {
                            check_match(s, s->strstart, s->match_start, s->match_length);
                
                            _tr_tally_dist(s, s->strstart - s->match_start,
                                           s->match_length - MIN_MATCH, bflush);
                
                            s->lookahead -= s->match_length;
                
                            /* Insert new strings in the hash table only if the match length
                             * is not too large. This saves time but degrades compression.
                             */
                #ifndef FASTEST
                            if (s->match_length <= s->max_insert_length &&
                                s->lookahead >= MIN_MATCH) {
                                s->match_length--; /* string at strstart already in table */
                                do {
                                    s->strstart++;
                                    INSERT_STRING(s, s->strstart, hash_head);
                                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are
                                     * always MIN_MATCH bytes ahead.
                                     */
                                } while (--s->match_length != 0);
                                s->strstart++;
                            } else
                #endif
                            {
                                s->strstart += s->match_length;
                                s->match_length = 0;
                                s->ins_h = s->window[s->strstart];
                                UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
                #if MIN_MATCH != 3
                                Call UPDATE_HASH() MIN_MATCH-3 more times
                #endif
                                /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
                                 * matter since it will be recomputed at next deflate call.
                                 */
                            }
                        } else {
                            /* No match, output a literal byte */
                            Tracevv((stderr,"%c", s->window[s->strstart]));
                            _tr_tally_lit (s, s->window[s->strstart], bflush);
                            s->lookahead--;
                            s->strstart++;
                        }
                        if (bflush) FLUSH_BLOCK(s, 0);
                    }
                    s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;
                    if (flush == Z_FINISH) {
                        FLUSH_BLOCK(s, 1);
                        return finish_done;
                    }
                    if (s->last_lit)
                        FLUSH_BLOCK(s, 0);
                    return block_done;
                }
                
                #ifndef FASTEST
                /* ===========================================================================
                 * Same as above, but achieves better compression. We use a lazy
                 * evaluation for matches: a match is finally adopted only if there is
                 * no better match at the next window position.
                 */
                local block_state deflate_slow(s, flush)
                    deflate_state *s;
                    int flush;
       91191 -> {
                    IPos hash_head;          /* head of hash chain */
                    int bflush;              /* set if current block must be flushed */
                
                    /* Process the input block. */
                    for (;;) {
                        /* Make sure that we always have enough lookahead, except
                         * at the end of the input file. We need MAX_MATCH bytes
                         * for the next match, plus MIN_MATCH bytes to insert the
                         * string following the next match.
                         */
                        if (s->lookahead < MIN_LOOKAHEAD) {
                            fill_window(s);
                            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
                                return need_more;
                            }
                            if (s->lookahead == 0) break; /* flush the current block */
                        }
                
                        /* Insert the string window[strstart .. strstart+2] in the
                         * dictionary, and set hash_head to the head of the hash chain:
                         */
                        hash_head = NIL;
                        if (s->lookahead >= MIN_MATCH) {
                            INSERT_STRING(s, s->strstart, hash_head);
                        }
                
                        /* Find the longest match, discarding those <= prev_length.
                         */
                        s->prev_length = s->match_length, s->prev_match = s->match_start;
                        s->match_length = MIN_MATCH-1;
                
                        if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
                            s->strstart - hash_head <= MAX_DIST(s)) {
                            /* To simplify the code, we prevent matches with the string
                             * of window index 0 (in particular we have to avoid a match
                             * of the string with itself at the start of the input file).
                             */
                            s->match_length = longest_match (s, hash_head);
                            /* longest_match() sets match_start */
                
                            if (s->match_length <= 5 && (s->strategy == Z_FILTERED
                #if TOO_FAR <= 32767
                                || (s->match_length == MIN_MATCH &&
                                    s->strstart - s->match_start > TOO_FAR)
                #endif
                                )) {
                
                                /* If prev_match is also MIN_MATCH, match_start is garbage
                                 * but we will ignore the current match anyway.
                                 */
                                s->match_length = MIN_MATCH-1;
                            }
                        }
                        /* If there was a match at the previous step and the current
                         * match is not better, output the previous match:
                         */
                        if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {
                            uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;
                            /* Do not insert strings in hash table beyond this. */
                
                            check_match(s, s->strstart-1, s->prev_match, s->prev_length);
                
                            _tr_tally_dist(s, s->strstart -1 - s->prev_match,
                                           s->prev_length - MIN_MATCH, bflush);
                
                            /* Insert in hash table all strings up to the end of the match.
                             * strstart-1 and strstart are already inserted. If there is not
                             * enough lookahead, the last two strings are not inserted in
                             * the hash table.
                             */
                            s->lookahead -= s->prev_length-1;
                            s->prev_length -= 2;
                            do {
                                if (++s->strstart <= max_insert) {
                                    INSERT_STRING(s, s->strstart, hash_head);
                                }
                            } while (--s->prev_length != 0);
                            s->match_available = 0;
                            s->match_length = MIN_MATCH-1;
                            s->strstart++;
                
                            if (bflush) FLUSH_BLOCK(s, 0);
                
                        } else if (s->match_available) {
                            /* If there was no match at the previous position, output a
                             * single literal. If there was a match but the current match
                             * is longer, truncate the previous match to a single literal.
                             */
                            Tracevv((stderr,"%c", s->window[s->strstart-1]));
                            _tr_tally_lit(s, s->window[s->strstart-1], bflush);
                            if (bflush) {
                                FLUSH_BLOCK_ONLY(s, 0);
                            }
                            s->strstart++;
                            s->lookahead--;
                            if (s->strm->avail_out == 0) return need_more;
                        } else {
                            /* There is no previous match to compare with, wait for
                             * the next step to decide.
                             */
                            s->match_available = 1;
                            s->strstart++;
                            s->lookahead--;
                        }
                    }
                    Assert (flush != Z_NO_FLUSH, "no flush?");
                    if (s->match_available) {
                        Tracevv((stderr,"%c", s->window[s->strstart-1]));
                        _tr_tally_lit(s, s->window[s->strstart-1], bflush);
                        s->match_available = 0;
                    }
                    s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;
                    if (flush == Z_FINISH) {
                        FLUSH_BLOCK(s, 1);
                        return finish_done;
                    }
                    if (s->last_lit)
                        FLUSH_BLOCK(s, 0);
                    return block_done;
                }
                #endif /* FASTEST */
                
                /* ===========================================================================
                 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
                 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
                 * deflate switches away from Z_RLE.)
                 */
                local block_state deflate_rle(s, flush)
                    deflate_state *s;
                    int flush;
       ##### -> {
                    int bflush;             /* set if current block must be flushed */
                    uInt prev;              /* byte at distance one to match */
                    Bytef *scan, *strend;   /* scan goes up to strend for length of run */
                
                    for (;;) {
                        /* Make sure that we always have enough lookahead, except
                         * at the end of the input file. We need MAX_MATCH bytes
                         * for the longest run, plus one for the unrolled loop.
                         */
                        if (s->lookahead <= MAX_MATCH) {
                            fill_window(s);
                            if (s->lookahead <= MAX_MATCH && flush == Z_NO_FLUSH) {
                                return need_more;
                            }
                            if (s->lookahead == 0) break; /* flush the current block */
                        }
                
                        /* See how many times the previous byte repeats */
                        s->match_length = 0;
                        if (s->lookahead >= MIN_MATCH && s->strstart > 0) {
                            scan = s->window + s->strstart - 1;
                            prev = *scan;
                            if (prev == *++scan && prev == *++scan && prev == *++scan) {
                                strend = s->window + s->strstart + MAX_MATCH;
                                do {
                                } while (prev == *++scan && prev == *++scan &&
                                         prev == *++scan && prev == *++scan &&
                                         prev == *++scan && prev == *++scan &&
                                         prev == *++scan && prev == *++scan &&
                                         scan < strend);
                                s->match_length = MAX_MATCH - (uInt)(strend - scan);
                                if (s->match_length > s->lookahead)
                                    s->match_length = s->lookahead;
                            }
                            Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
                        }
                
                        /* Emit match if have run of MIN_MATCH or longer, else emit literal */
                        if (s->match_length >= MIN_MATCH) {
                            check_match(s, s->strstart, s->strstart - 1, s->match_length);
                
                            _tr_tally_dist(s, 1, s->match_length - MIN_MATCH, bflush);
                
                            s->lookahead -= s->match_length;
                            s->strstart += s->match_length;
                            s->match_length = 0;
                        } else {
                            /* No match, output a literal byte */
                            Tracevv((stderr,"%c", s->window[s->strstart]));
                            _tr_tally_lit (s, s->window[s->strstart], bflush);
                            s->lookahead--;
                            s->strstart++;
                        }
                        if (bflush) FLUSH_BLOCK(s, 0);
                    }
                    s->insert = 0;
                    if (flush == Z_FINISH) {
                        FLUSH_BLOCK(s, 1);
                        return finish_done;
                    }
                    if (s->last_lit)
                        FLUSH_BLOCK(s, 0);
                    return block_done;
                }
                
                /* ===========================================================================
                 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
                 * (It will be regenerated if this run of deflate switches away from Huffman.)
                 */
                local block_state deflate_huff(s, flush)
                    deflate_state *s;
                    int flush;
       ##### -> {
                    int bflush;             /* set if current block must be flushed */
                
                    for (;;) {
                        /* Make sure that we have a literal to write. */
                        if (s->lookahead == 0) {
                            fill_window(s);
                            if (s->lookahead == 0) {
                                if (flush == Z_NO_FLUSH)
                                    return need_more;
                                break;      /* flush the current block */
                            }
                        }
                
                        /* Output a literal byte */
                        s->match_length = 0;
                        Tracevv((stderr,"%c", s->window[s->strstart]));
                        _tr_tally_lit (s, s->window[s->strstart], bflush);
                        s->lookahead--;
                        s->strstart++;
                        if (bflush) FLUSH_BLOCK(s, 0);
                    }
                    s->insert = 0;
                    if (flush == Z_FINISH) {
                        FLUSH_BLOCK(s, 1);
                        return finish_done;
                    }
                    if (s->last_lit)
                        FLUSH_BLOCK(s, 0);
                    return block_done;
                }


Top 10 Lines:

     Line      Count

     1239  135725603
     1452   61613127
     1484     171137
      355     111328
      766     111325
     1929      91191
     1168      85538
      732      25788
      203      21383
      469          2

Execution Summary:

       29   Executable lines in this file
       29   Lines executed
   100.00   Percent of the file executed

197956428   Total number of line executions
6826083.72   Average executions per line


*** File /home/chaos/git_reposity/zlib/gzwrite.c:
                /* gzwrite.c -- zlib functions for writing gzip files
                 * Copyright (C) 2004-2017 Mark Adler
                 * For conditions of distribution and use, see copyright notice in zlib.h
                 */
                
                #include "gzguts.h"
                
                /* Local functions */
                local int gz_init OF((gz_statep));
                local int gz_comp OF((gz_statep, int));
                local int gz_zero OF((gz_statep, z_off64_t));
                local z_size_t gz_write OF((gz_statep, voidpc, z_size_t));
                
                /* Initialize state for writing a gzip file.  Mark initialization by setting
                   state->size to non-zero.  Return -1 on a memory allocation failure, or 0 on
                   success. */
                local int gz_init(state)
                    gz_statep state;
           1 -> {
                    int ret;
                    z_streamp strm = &(state->strm);
                
                    /* allocate input buffer (double size for gzprintf) */
                    state->in = (unsigned char *)malloc(state->want << 1);
                    if (state->in == NULL) {
                        gz_error(state, Z_MEM_ERROR, "out of memory");
                        return -1;
                    }
                
                    /* only need output buffer and deflate state if compressing */
                    if (!state->direct) {
                        /* allocate output buffer */
                        state->out = (unsigned char *)malloc(state->want);
                        if (state->out == NULL) {
                            free(state->in);
                            gz_error(state, Z_MEM_ERROR, "out of memory");
                            return -1;
                        }
                
                        /* allocate deflate memory, set up for gzip compression */
                        strm->zalloc = Z_NULL;
                        strm->zfree = Z_NULL;
                        strm->opaque = Z_NULL;
                        ret = deflateInit2(strm, state->level, Z_DEFLATED,
                                           MAX_WBITS + 16, DEF_MEM_LEVEL, state->strategy);
                        if (ret != Z_OK) {
                            free(state->out);
                            free(state->in);
                            gz_error(state, Z_MEM_ERROR, "out of memory");
                            return -1;
                        }
                        strm->next_in = NULL;
                    }
                
                    /* mark state as initialized */
                    state->size = state->want;
                
                    /* initialize write buffer if compressing */
                    if (!state->direct) {
                        strm->avail_out = state->size;
                        strm->next_out = state->out;
                        state->x.next = strm->next_out;
                    }
                    return 0;
                }
                
                /* Compress whatever is at avail_in and next_in and write to the output file.
                   Return -1 if there is an error writing to the output file or if gz_init()
                   fails to allocate memory, otherwise 0.  flush is assumed to be a valid
                   deflate() flush value.  If flush is Z_FINISH, then the deflate() state is
                   reset to start a new gzip stream.  If gz->direct is true, then simply write
                   to the output file without compressing, and ignore flush. */
                local int gz_comp(state, flush)
                    gz_statep state;
                    int flush;
       85538 -> {
                    int ret, writ;
                    unsigned have, put, max = ((unsigned)-1 >> 2) + 1;
                    z_streamp strm = &(state->strm);
                
                    /* allocate memory if this is the first time through */
                    if (state->size == 0 && gz_init(state) == -1)
                        return -1;
                
                    /* write directly if requested */
                    if (state->direct) {
                        while (strm->avail_in) {
                            put = strm->avail_in > max ? max : strm->avail_in;
                            writ = write(state->fd, strm->next_in, put);
                            if (writ < 0) {
                                gz_error(state, Z_ERRNO, zstrerror());
                                return -1;
                            }
                            strm->avail_in -= (unsigned)writ;
                            strm->next_in += writ;
                        }
                        return 0;
                    }
                
                    /* run deflate() on provided input until it produces no more output */
                    ret = Z_OK;
                    do {
                        /* write out current buffer contents if full, or if flushing, but if
                           doing Z_FINISH then don't write until we get to Z_STREAM_END */
                        if (strm->avail_out == 0 || (flush != Z_NO_FLUSH &&
                            (flush != Z_FINISH || ret == Z_STREAM_END))) {
                            while (strm->next_out > state->x.next) {
                                put = strm->next_out - state->x.next > (int)max ? max :
                                      (unsigned)(strm->next_out - state->x.next);
                                writ = write(state->fd, state->x.next, put);
                                if (writ < 0) {
                                    gz_error(state, Z_ERRNO, zstrerror());
                                    return -1;
                                }
                                state->x.next += writ;
                            }
                            if (strm->avail_out == 0) {
                                strm->avail_out = state->size;
                                strm->next_out = state->out;
                                state->x.next = state->out;
                            }
                        }
                
                        /* compress */
                        have = strm->avail_out;
                        ret = deflate(strm, flush);
                        if (ret == Z_STREAM_ERROR) {
                            gz_error(state, Z_STREAM_ERROR,
                                      "internal error: deflate stream corrupt");
                            return -1;
                        }
                        have -= strm->avail_out;
                    } while (have);
                
                    /* if that completed a deflate stream, allow another to start */
                    if (flush == Z_FINISH)
                        deflateReset(strm);
                
                    /* all done, no errors */
                    return 0;
                }
                
                /* Compress len zeros to output.  Return -1 on a write error or memory
                   allocation failure by gz_comp(), or 0 on success. */
                local int gz_zero(state, len)
                    gz_statep state;
                    z_off64_t len;
       ##### -> {
                    int first;
                    unsigned n;
                    z_streamp strm = &(state->strm);
                
                    /* consume whatever's left in the input buffer */
                    if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)
                        return -1;
                
                    /* compress len zeros (len guaranteed > 0) */
                    first = 1;
                    while (len) {
                        n = GT_OFF(state->size) || (z_off64_t)state->size > len ?
                            (unsigned)len : state->size;
                        if (first) {
                            memset(state->in, 0, n);
                            first = 0;
                        }
                        strm->avail_in = n;
                        strm->next_in = state->in;
                        state->x.pos += n;
                        if (gz_comp(state, Z_NO_FLUSH) == -1)
                            return -1;
                        len -= n;
                    }
                    return 0;
                }
                
                /* Write len bytes from buf to file.  Return the number of bytes written.  If
                   the returned value is less than len, then there was an error. */
                local z_size_t gz_write(state, buf, len)
                    gz_statep state;
                    voidpc buf;
                    z_size_t len;
    21039740 -> {
                    z_size_t put = len;
                
                    /* if len is zero, avoid unnecessary operations */
                    if (len == 0)
                        return 0;
                
                    /* allocate memory if this is the first time through */
                    if (state->size == 0 && gz_init(state) == -1)
                        return 0;
                
                    /* check for seek request */
                    if (state->seek) {
                        state->seek = 0;
                        if (gz_zero(state, state->skip) == -1)
                            return 0;
                    }
                
                    /* for small len, copy to input buffer, otherwise compress directly */
                    if (len < state->size) {
                        /* copy to input buffer, compress when full */
                        do {
                            unsigned have, copy;
                
                            if (state->strm.avail_in == 0)
                                state->strm.next_in = state->in;
                            have = (unsigned)((state->strm.next_in + state->strm.avail_in) -
                                              state->in);
                            copy = state->size - have;
                            if (copy > len)
                                copy = len;
                            memcpy(state->in + have, buf, copy);
                            state->strm.avail_in += copy;
                            state->x.pos += copy;
                            buf = (const char *)buf + copy;
                            len -= copy;
                            if (len && gz_comp(state, Z_NO_FLUSH) == -1)
                                return 0;
                        } while (len);
                    }
                    else {
                        /* consume whatever's left in the input buffer */
                        if (state->strm.avail_in && gz_comp(state, Z_NO_FLUSH) == -1)
                            return 0;
                
                        /* directly compress user buffer to file */
                        state->strm.next_in = (z_const Bytef *)buf;
                        do {
                            unsigned n = (unsigned)-1;
                            if (n > len)
                                n = len;
                            state->strm.avail_in = n;
                            state->x.pos += n;
                            if (gz_comp(state, Z_NO_FLUSH) == -1)
                                return 0;
                            len -= n;
                        } while (len);
                    }
                
                    /* input was all buffered or compressed */
                    return put;
                }
                
                /* -- see zlib.h -- */
                int ZEXPORT gzwrite(file, buf, len)
                    gzFile file;
                    voidpc buf;
                    unsigned len;
       ##### -> {
                    gz_statep state;
                
                    /* get internal structure */
                    if (file == NULL)
                        return 0;
                    state = (gz_statep)file;
                
                    /* check that we're writing and that there's no error */
                    if (state->mode != GZ_WRITE || state->err != Z_OK)
                        return 0;
                
                    /* since an int is returned, make sure len fits in one, otherwise return
                       with an error (this avoids a flaw in the interface) */
                    if ((int)len < 0) {
                        gz_error(state, Z_DATA_ERROR, "requested length does not fit in int");
                        return 0;
                    }
                
                    /* write len bytes from buf (the return value will fit in an int) */
                    return (int)gz_write(state, buf, len);
                }
                
                /* -- see zlib.h -- */
                z_size_t ZEXPORT gzfwrite(buf, size, nitems, file)
                    voidpc buf;
                    z_size_t size;
                    z_size_t nitems;
                    gzFile file;
       ##### -> {
                    z_size_t len;
                    gz_statep state;
                
                    /* get internal structure */
                    if (file == NULL)
                        return 0;
                    state = (gz_statep)file;
                
                    /* check that we're writing and that there's no error */
                    if (state->mode != GZ_WRITE || state->err != Z_OK)
                        return 0;
                
                    /* compute bytes to read -- error on overflow */
                    len = nitems * size;
                    if (size && len / size != nitems) {
                        gz_error(state, Z_STREAM_ERROR, "request does not fit in a size_t");
                        return 0;
                    }
                
                    /* write len bytes to buf, return the number of full items written */
                    return len ? gz_write(state, buf, len) / size : 0;
                }
                
                /* -- see zlib.h -- */
                int ZEXPORT gzputc(file, c)
                    gzFile file;
                    int c;
       ##### -> {
                    unsigned have;
                    unsigned char buf[1];
                    gz_statep state;
                    z_streamp strm;
                
                    /* get internal structure */
                    if (file == NULL)
                        return -1;
                    state = (gz_statep)file;
                    strm = &(state->strm);
                
                    /* check that we're writing and that there's no error */
                    if (state->mode != GZ_WRITE || state->err != Z_OK)
                        return -1;
                
                    /* check for seek request */
                    if (state->seek) {
                        state->seek = 0;
                        if (gz_zero(state, state->skip) == -1)
                            return -1;
                    }
                
                    /* try writing to input buffer for speed (state->size == 0 if buffer not
                       initialized) */
                    if (state->size) {
                        if (strm->avail_in == 0)
                            strm->next_in = state->in;
                        have = (unsigned)((strm->next_in + strm->avail_in) - state->in);
                        if (have < state->size) {
                            state->in[have] = (unsigned char)c;
                            strm->avail_in++;
                            state->x.pos++;
                            return c & 0xff;
                        }
                    }
                
                    /* no room in buffer or not initialized, use gz_write() */
                    buf[0] = (unsigned char)c;
                    if (gz_write(state, buf, 1) != 1)
                        return -1;
                    return c & 0xff;
                }
                
                /* -- see zlib.h -- */
                int ZEXPORT gzputs(file, str)
                    gzFile file;
                    const char *str;
    21039740 -> {
                    int ret;
                    z_size_t len;
                    gz_statep state;
                
                    /* get internal structure */
                    if (file == NULL)
                        return -1;
                    state = (gz_statep)file;
                
                    /* check that we're writing and that there's no error */
                    if (state->mode != GZ_WRITE || state->err != Z_OK)
                        return -1;
                
                    /* write string */
                    len = strlen(str);
                    ret = gz_write(state, str, len);
                    return ret == 0 && len != 0 ? -1 : ret;
                }
                
                #if defined(STDC) || defined(Z_HAVE_STDARG_H)
                #include <stdarg.h>
                
                /* -- see zlib.h -- */
                int ZEXPORTVA gzvprintf(gzFile file, const char *format, va_list va)
       ##### -> {
                    int len;
                    unsigned left;
                    char *next;
                    gz_statep state;
                    z_streamp strm;
                
                    /* get internal structure */
                    if (file == NULL)
                        return Z_STREAM_ERROR;
                    state = (gz_statep)file;
                    strm = &(state->strm);
                
                    /* check that we're writing and that there's no error */
                    if (state->mode != GZ_WRITE || state->err != Z_OK)
                        return Z_STREAM_ERROR;
                
                    /* make sure we have some buffer space */
                    if (state->size == 0 && gz_init(state) == -1)
                        return state->err;
                
                    /* check for seek request */
                    if (state->seek) {
                        state->seek = 0;
                        if (gz_zero(state, state->skip) == -1)
                            return state->err;
                    }
                
                    /* do the printf() into the input buffer, put length in len -- the input
                       buffer is double-sized just for this function, so there is guaranteed to
                       be state->size bytes available after the current contents */
                    if (strm->avail_in == 0)
                        strm->next_in = state->in;
                    next = (char *)(state->in + (strm->next_in - state->in) + strm->avail_in);
                    next[state->size - 1] = 0;
                #ifdef NO_vsnprintf
                #  ifdef HAS_vsprintf_void
                    (void)vsprintf(next, format, va);
                    for (len = 0; len < state->size; len++)
                        if (next[len] == 0) break;
                #  else
                    len = vsprintf(next, format, va);
                #  endif
                #else
                #  ifdef HAS_vsnprintf_void
                    (void)vsnprintf(next, state->size, format, va);
                    len = strlen(next);
                #  else
                    len = vsnprintf(next, state->size, format, va);
                #  endif
                #endif
                
                    /* check that printf() results fit in buffer */
                    if (len == 0 || (unsigned)len >= state->size || next[state->size - 1] != 0)
                        return 0;
                
                    /* update buffer and position, compress first half if past that */
                    strm->avail_in += (unsigned)len;
                    state->x.pos += len;
                    if (strm->avail_in >= state->size) {
                        left = strm->avail_in - state->size;
                        strm->avail_in = state->size;
                        if (gz_comp(state, Z_NO_FLUSH) == -1)
                            return state->err;
                        memcpy(state->in, state->in + state->size, left);
                        strm->next_in = state->in;
                        strm->avail_in = left;
                    }
                    return len;
                }
                
                int ZEXPORTVA gzprintf(gzFile file, const char *format, ...)
       ##### -> {
                    va_list va;
                    int ret;
                
                    va_start(va, format);
                    ret = gzvprintf(file, format, va);
                    va_end(va);
                    return ret;
                }
                
                #else /* !STDC && !Z_HAVE_STDARG_H */
                
                /* -- see zlib.h -- */
                int ZEXPORTVA gzprintf (file, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
                                       a11, a12, a13, a14, a15, a16, a17, a18, a19, a20)
                    gzFile file;
                    const char *format;
                    int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
                        a11, a12, a13, a14, a15, a16, a17, a18, a19, a20;
                {
                    unsigned len, left;
                    char *next;
                    gz_statep state;
                    z_streamp strm;
                
                    /* get internal structure */
                    if (file == NULL)
                        return Z_STREAM_ERROR;
                    state = (gz_statep)file;
                    strm = &(state->strm);
                
                    /* check that can really pass pointer in ints */
                    if (sizeof(int) != sizeof(void *))
                        return Z_STREAM_ERROR;
                
                    /* check that we're writing and that there's no error */
                    if (state->mode != GZ_WRITE || state->err != Z_OK)
                        return Z_STREAM_ERROR;
                
                    /* make sure we have some buffer space */
                    if (state->size == 0 && gz_init(state) == -1)
                        return state->error;
                
                    /* check for seek request */
                    if (state->seek) {
                        state->seek = 0;
                        if (gz_zero(state, state->skip) == -1)
                            return state->error;
                    }
                
                    /* do the printf() into the input buffer, put length in len -- the input
                       buffer is double-sized just for this function, so there is guaranteed to
                       be state->size bytes available after the current contents */
                    if (strm->avail_in == 0)
                        strm->next_in = state->in;
                    next = (char *)(strm->next_in + strm->avail_in);
                    next[state->size - 1] = 0;
                #ifdef NO_snprintf
                #  ifdef HAS_sprintf_void
                    sprintf(next, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12,
                            a13, a14, a15, a16, a17, a18, a19, a20);
                    for (len = 0; len < size; len++)
                        if (next[len] == 0)
                            break;
                #  else
                    len = sprintf(next, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11,
                                  a12, a13, a14, a15, a16, a17, a18, a19, a20);
                #  endif
                #else
                #  ifdef HAS_snprintf_void
                    snprintf(next, state->size, format, a1, a2, a3, a4, a5, a6, a7, a8, a9,
                             a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
                    len = strlen(next);
                #  else
                    len = snprintf(next, state->size, format, a1, a2, a3, a4, a5, a6, a7, a8,
                                   a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
                #  endif
                #endif
                
                    /* check that printf() results fit in buffer */
                    if (len == 0 || len >= state->size || next[state->size - 1] != 0)
                        return 0;
                
                    /* update buffer and position, compress first half if past that */
                    strm->avail_in += len;
                    state->x.pos += len;
                    if (strm->avail_in >= state->size) {
                        left = strm->avail_in - state->size;
                        strm->avail_in = state->size;
                        if (gz_comp(state, Z_NO_FLUSH) == -1)
                            return state->err;
                        memcpy(state->in, state->in + state->size, left);
                        strm->next_in = state->in;
                        strm->avail_in = left;
                    }
                    return (int)len;
                }
                
                #endif
                
                /* -- see zlib.h -- */
                int ZEXPORT gzflush(file, flush)
                    gzFile file;
                    int flush;
       ##### -> {
                    gz_statep state;
                
                    /* get internal structure */
                    if (file == NULL)
                        return Z_STREAM_ERROR;
                    state = (gz_statep)file;
                
                    /* check that we're writing and that there's no error */
                    if (state->mode != GZ_WRITE || state->err != Z_OK)
                        return Z_STREAM_ERROR;
                
                    /* check flush parameter */
                    if (flush < 0 || flush > Z_FINISH)
                        return Z_STREAM_ERROR;
                
                    /* check for seek request */
                    if (state->seek) {
                        state->seek = 0;
                        if (gz_zero(state, state->skip) == -1)
                            return state->err;
                    }
                
                    /* compress remaining data with requested flush */
                    (void)gz_comp(state, flush);
                    return state->err;
                }
                
                /* -- see zlib.h -- */
                int ZEXPORT gzsetparams(file, level, strategy)
                    gzFile file;
                    int level;
                    int strategy;
       ##### -> {
                    gz_statep state;
                    z_streamp strm;
                
                    /* get internal structure */
                    if (file == NULL)
                        return Z_STREAM_ERROR;
                    state = (gz_statep)file;
                    strm = &(state->strm);
                
                    /* check that we're writing and that there's no error */
                    if (state->mode != GZ_WRITE || state->err != Z_OK)
                        return Z_STREAM_ERROR;
                
                    /* if no change is requested, then do nothing */
                    if (level == state->level && strategy == state->strategy)
                        return Z_OK;
                
                    /* check for seek request */
                    if (state->seek) {
                        state->seek = 0;
                        if (gz_zero(state, state->skip) == -1)
                            return state->err;
                    }
                
                    /* change compression parameters for subsequent input */
                    if (state->size) {
                        /* flush previous input with previous parameters before changing */
                        if (strm->avail_in && gz_comp(state, Z_BLOCK) == -1)
                            return state->err;
                        deflateParams(strm, level, strategy);
                    }
                    state->level = level;
                    state->strategy = strategy;
                    return Z_OK;
                }
                
                /* -- see zlib.h -- */
                int ZEXPORT gzclose_w(file)
                    gzFile file;
           1 -> {
                    int ret = Z_OK;
                    gz_statep state;
                
                    /* get internal structure */
                    if (file == NULL)
                        return Z_STREAM_ERROR;
                    state = (gz_statep)file;
                
                    /* check that we're writing */
                    if (state->mode != GZ_WRITE)
                        return Z_STREAM_ERROR;
                
                    /* check for seek request */
                    if (state->seek) {
                        state->seek = 0;
                        if (gz_zero(state, state->skip) == -1)
                            ret = state->err;
                    }
                
                    /* flush, free memory, and close file */
                    if (gz_comp(state, Z_FINISH) == -1)
                        ret = state->err;
                    if (state->size) {
                        if (!state->direct) {
                            (void)deflateEnd(&(state->strm));
                            free(state->out);
                        }
                        free(state->in);
                    }
                    gz_error(state, Z_OK, NULL);
                    free(state->path);
                    if (close(state->fd) == -1)
                        ret = Z_ERRNO;
                    free(state);
                    return ret;
                }


Top 10 Lines:

     Line      Count

      182   21039740
      355   21039740
       76      85538
       19          1
      629          1

Execution Summary:

       13   Executable lines in this file
       13   Lines executed
   100.00   Percent of the file executed

 42165020   Total number of line executions
3243463.08   Average executions per line


*** File /home/chaos/git_reposity/zlib/gzread.c:
                /* gzread.c -- zlib functions for reading gzip files
                 * Copyright (C) 2004, 2005, 2010, 2011, 2012, 2013, 2016 Mark Adler
                 * For conditions of distribution and use, see copyright notice in zlib.h
                 */
                
                #include "gzguts.h"
                
                /* Local functions */
                local int gz_load OF((gz_statep, unsigned char *, unsigned, unsigned *));
                local int gz_avail OF((gz_statep));
                local int gz_look OF((gz_statep));
                local int gz_decomp OF((gz_statep));
                local int gz_fetch OF((gz_statep));
                local int gz_skip OF((gz_statep, z_off64_t));
                local z_size_t gz_read OF((gz_statep, voidp, z_size_t));
                
                /* Use read() to load a buffer -- return -1 on error, otherwise 0.  Read from
                   state->fd, and update state->eof, state->err, and state->msg as appropriate.
                   This function needs to loop on read(), since read() is not guaranteed to
                   read the number of bytes requested, depending on the type of descriptor. */
                local int gz_load(state, buf, len, have)
                    gz_statep state;
                    unsigned char *buf;
                    unsigned len;
                    unsigned *have;
       33408 -> {
                    int ret;
                    unsigned get, max = ((unsigned)-1 >> 2) + 1;
                
                    *have = 0;
                    do {
                        get = len - *have;
                        if (get > max)
                            get = max;
                        ret = read(state->fd, buf + *have, get);
                        if (ret <= 0)
                            break;
                        *have += (unsigned)ret;
                    } while (*have < len);
                    if (ret < 0) {
                        gz_error(state, Z_ERRNO, zstrerror());
                        return -1;
                    }
                    if (ret == 0)
                        state->eof = 1;
                    return 0;
                }
                
                /* Load up input buffer and set eof flag if last data loaded -- return -1 on
                   error, 0 otherwise.  Note that the eof flag is set when the end of the input
                   file is reached, even though there may be unused data in the buffer.  Once
                   that data has been used, no more attempts will be made to read the file.
                   If strm->avail_in != 0, then the current data is moved to the beginning of
                   the input buffer, and then the remainder of the buffer is loaded with the
                   available data from the input file. */
                local int gz_avail(state)
                    gz_statep state;
       33409 -> {
                    unsigned got;
                    z_streamp strm = &(state->strm);
                
                    if (state->err != Z_OK && state->err != Z_BUF_ERROR)
                        return -1;
                    if (state->eof == 0) {
                        if (strm->avail_in) {       /* copy what's there to the start */
                            unsigned char *p = state->in;
                            unsigned const char *q = strm->next_in;
                            unsigned n = strm->avail_in;
                            do {
                                *p++ = *q++;
                            } while (--n);
                        }
                        if (gz_load(state, state->in + strm->avail_in,
                                    state->size - strm->avail_in, &got) == -1)
                            return -1;
                        strm->avail_in += got;
                        strm->next_in = state->in;
                    }
                    return 0;
                }
                
                /* Look for gzip header, set up for inflate or copy.  state->x.have must be 0.
                   If this is the first time in, allocate required memory.  state->how will be
                   left unchanged if there is no more input data available, will be set to COPY
                   if there is no gzip header and direct copying will be performed, or it will
                   be set to GZIP for decompression.  If direct copying, then leftover input
                   data from the input buffer will be copied to the output buffer.  In that
                   case, all further file reads will be directly to either the output buffer or
                   a user buffer.  If decompressing, the inflate state will be initialized.
                   gz_look() will return 0 on success or -1 on failure. */
                local int gz_look(state)
                    gz_statep state;
          28 -> {
                    z_streamp strm = &(state->strm);
                
                    /* allocate read buffers and inflate memory */
                    if (state->size == 0) {
                        /* allocate buffers */
                        state->in = (unsigned char *)malloc(state->want);
                        state->out = (unsigned char *)malloc(state->want << 1);
                        if (state->in == NULL || state->out == NULL) {
                            free(state->out);
                            free(state->in);
                            gz_error(state, Z_MEM_ERROR, "out of memory");
                            return -1;
                        }
                        state->size = state->want;
                
                        /* allocate inflate memory */
                        state->strm.zalloc = Z_NULL;
                        state->strm.zfree = Z_NULL;
                        state->strm.opaque = Z_NULL;
                        state->strm.avail_in = 0;
                        state->strm.next_in = Z_NULL;
                        if (inflateInit2(&(state->strm), 15 + 16) != Z_OK) {    /* gunzip */
                            free(state->out);
                            free(state->in);
                            state->size = 0;
                            gz_error(state, Z_MEM_ERROR, "out of memory");
                            return -1;
                        }
                    }
                
                    /* get at least the magic bytes in the input buffer */
                    if (strm->avail_in < 2) {
                        if (gz_avail(state) == -1)
                            return -1;
                        if (strm->avail_in == 0)
                            return 0;
                    }
                
                    /* look for gzip magic bytes -- if there, do gzip decoding (note: there is
                       a logical dilemma here when considering the case of a partially written
                       gzip file, to wit, if a single 31 byte is written, then we cannot tell
                       whether this is a single-byte file, or just a partially written gzip
                       file -- for here we assume that if a gzip file is being written, then
                       the header will be written in a single operation, so that reading a
                       single byte is sufficient indication that it is not a gzip file) */
                    if (strm->avail_in > 1 &&
                            strm->next_in[0] == 31 && strm->next_in[1] == 139) {
                        inflateReset(strm);
                        state->how = GZIP;
                        state->direct = 0;
                        return 0;
                    }
                
                    /* no gzip header -- if we were decoding gzip before, then this is trailing
                       garbage.  Ignore the trailing garbage and finish. */
                    if (state->direct == 0) {
                        strm->avail_in = 0;
                        state->eof = 1;
                        state->x.have = 0;
                        return 0;
                    }
                
                    /* doing raw i/o, copy any leftover input to output -- this assumes that
                       the output buffer is larger than the input buffer, which also assures
                       space for gzungetc() */
                    state->x.next = state->out;
                    if (strm->avail_in) {
                        memcpy(state->x.next, strm->next_in, strm->avail_in);
                        state->x.have = strm->avail_in;
                        strm->avail_in = 0;
                    }
                    state->how = COPY;
                    state->direct = 1;
                    return 0;
                }
                
                /* Decompress from input to the provided next_out and avail_out in the state.
                   On return, state->x.have and state->x.next point to the just decompressed
                   data.  If the gzip stream completes, state->how is reset to LOOK to look for
                   the next gzip stream or raw data, once state->x.have is depleted.  Returns 0
                   on success, -1 on failure. */
                local int gz_decomp(state)
                    gz_statep state;
       51884 -> {
                    int ret = Z_OK;
                    unsigned had;
                    z_streamp strm = &(state->strm);
                
                    /* fill output buffer up to end of deflate stream */
                    had = strm->avail_out;
                    do {
                        /* get more input for inflate() */
                        if (strm->avail_in == 0 && gz_avail(state) == -1)
                            return -1;
                        if (strm->avail_in == 0) {
                            gz_error(state, Z_BUF_ERROR, "unexpected end of file");
                            break;
                        }
                
                        /* decompress and handle errors */
                        ret = inflate(strm, Z_NO_FLUSH);
                        if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {
                            gz_error(state, Z_STREAM_ERROR,
                                     "internal error: inflate stream corrupt");
                            return -1;
                        }
                        if (ret == Z_MEM_ERROR) {
                            gz_error(state, Z_MEM_ERROR, "out of memory");
                            return -1;
                        }
                        if (ret == Z_DATA_ERROR) {              /* deflate stream invalid */
                            gz_error(state, Z_DATA_ERROR,
                                     strm->msg == NULL ? "compressed data error" : strm->msg);
                            return -1;
                        }
                    } while (strm->avail_out && ret != Z_STREAM_END);
                
                    /* update available output */
                    state->x.have = had - strm->avail_out;
                    state->x.next = strm->next_out - state->x.have;
                
                    /* if the gzip stream completed successfully, look for another */
                    if (ret == Z_STREAM_END)
                        state->how = LOOK;
                
                    /* good decompression */
                    return 0;
                }
                
                /* Fetch data and put it in the output buffer.  Assumes state->x.have is 0.
                   Data is either copied from the input file or decompressed from the input
                   file depending on state->how.  If state->how is LOOK, then a gzip header is
                   looked for to determine whether to copy or decompress.  Returns -1 on error,
                   otherwise 0.  gz_fetch() will leave state->how as COPY or GZIP unless the
                   end of the input file has been reached and all data has been processed.  */
                local int gz_fetch(state)
                    gz_statep state;
       51885 -> {
                    z_streamp strm = &(state->strm);
                
                    do {
                        switch(state->how) {
                        case LOOK:      /* -> LOOK, COPY (only if never GZIP), or GZIP */
                            if (gz_look(state) == -1)
                                return -1;
                            if (state->how == LOOK)
                                return 0;
                            break;
                        case COPY:      /* -> COPY */
                            if (gz_load(state, state->out, state->size << 1, &(state->x.have))
                                    == -1)
                                return -1;
                            state->x.next = state->out;
                            return 0;
                        case GZIP:      /* -> GZIP or LOOK (if end of gzip stream) */
                            strm->avail_out = state->size << 1;
                            strm->next_out = state->out;
                            if (gz_decomp(state) == -1)
                                return -1;
                        }
                    } while (state->x.have == 0 && (!state->eof || strm->avail_in));
                    return 0;
                }
                
                /* Skip len uncompressed bytes of output.  Return -1 on error, 0 on success. */
                local int gz_skip(state, len)
                    gz_statep state;
                    z_off64_t len;
       ##### -> {
                    unsigned n;
                
                    /* skip over len bytes or reach end-of-file, whichever comes first */
                    while (len)
                        /* skip over whatever is in output buffer */
                        if (state->x.have) {
                            n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > len ?
                                (unsigned)len : state->x.have;
                            state->x.have -= n;
                            state->x.next += n;
                            state->x.pos += n;
                            len -= n;
                        }
                
                        /* output buffer empty -- return if we're at the end of the input */
                        else if (state->eof && state->strm.avail_in == 0)
                            break;
                
                        /* need more data to skip -- load up output buffer */
                        else {
                            /* get more output, looking for header if required */
                            if (gz_fetch(state) == -1)
                                return -1;
                        }
                    return 0;
                }
                
                /* Read len bytes into buf from file, or less than len up to the end of the
                   input.  Return the number of bytes read.  If zero is returned, either the
                   end of file was reached, or there was an error.  state->err must be
                   consulted in that case to determine which. */
                local z_size_t gz_read(state, buf, len)
                    gz_statep state;
                    voidp buf;
                    z_size_t len;
       ##### -> {
                    z_size_t got;
                    unsigned n;
                
                    /* if len is zero, avoid unnecessary operations */
                    if (len == 0)
                        return 0;
                
                    /* process a skip request */
                    if (state->seek) {
                        state->seek = 0;
                        if (gz_skip(state, state->skip) == -1)
                            return 0;
                    }
                
                    /* get len bytes to buf, or less than len if at the end */
                    got = 0;
                    do {
                        /* set n to the maximum amount of len that fits in an unsigned int */
                        n = -1;
                        if (n > len)
                            n = len;
                
                        /* first just try copying data from the output buffer */
                        if (state->x.have) {
                            if (state->x.have < n)
                                n = state->x.have;
                            memcpy(buf, state->x.next, n);
                            state->x.next += n;
                            state->x.have -= n;
                        }
                
                        /* output buffer empty -- return if we're at the end of the input */
                        else if (state->eof && state->strm.avail_in == 0) {
                            state->past = 1;        /* tried to read past end */
                            break;
                        }
                
                        /* need output data -- for small len or new stream load up our output
                           buffer */
                        else if (state->how == LOOK || n < (state->size << 1)) {
                            /* get more output, looking for header if required */
                            if (gz_fetch(state) == -1)
                                return 0;
                            continue;       /* no progress yet -- go back to copy above */
                            /* the copy above assures that we will leave with space in the
                               output buffer, allowing at least one gzungetc() to succeed */
                        }
                
                        /* large len -- read directly into user buffer */
                        else if (state->how == COPY) {      /* read directly */
                            if (gz_load(state, (unsigned char *)buf, n, &n) == -1)
                                return 0;
                        }
                
                        /* large len -- decompress directly into user buffer */
                        else {  /* state->how == GZIP */
                            state->strm.avail_out = n;
                            state->strm.next_out = (unsigned char *)buf;
                            if (gz_decomp(state) == -1)
                                return 0;
                            n = state->x.have;
                            state->x.have = 0;
                        }
                
                        /* update progress */
                        len -= n;
                        buf = (char *)buf + n;
                        got += n;
                        state->x.pos += n;
                    } while (len);
                
                    /* return number of bytes read into user buffer */
                    return got;
                }
                
                /* -- see zlib.h -- */
                int ZEXPORT gzread(file, buf, len)
                    gzFile file;
                    voidp buf;
                    unsigned len;
       ##### -> {
                    gz_statep state;
                
                    /* get internal structure */
                    if (file == NULL)
                        return -1;
                    state = (gz_statep)file;
                
                    /* check that we're reading and that there's no (serious) error */
                    if (state->mode != GZ_READ ||
                            (state->err != Z_OK && state->err != Z_BUF_ERROR))
                        return -1;
                
                    /* since an int is returned, make sure len fits in one, otherwise return
                       with an error (this avoids a flaw in the interface) */
                    if ((int)len < 0) {
                        gz_error(state, Z_STREAM_ERROR, "request does not fit in an int");
                        return -1;
                    }
                
                    /* read len or fewer bytes to buf */
                    len = gz_read(state, buf, len);
                
                    /* check for an error */
                    if (len == 0 && state->err != Z_OK && state->err != Z_BUF_ERROR)
                        return -1;
                
                    /* return the number of bytes read (this is assured to fit in an int) */
                    return (int)len;
                }
                
                /* -- see zlib.h -- */
                z_size_t ZEXPORT gzfread(buf, size, nitems, file)
                    voidp buf;
                    z_size_t size;
                    z_size_t nitems;
                    gzFile file;
       ##### -> {
                    z_size_t len;
                    gz_statep state;
                
                    /* get internal structure */
                    if (file == NULL)
                        return 0;
                    state = (gz_statep)file;
                
                    /* check that we're reading and that there's no (serious) error */
                    if (state->mode != GZ_READ ||
                            (state->err != Z_OK && state->err != Z_BUF_ERROR))
                        return 0;
                
                    /* compute bytes to read -- error on overflow */
                    len = nitems * size;
                    if (size && len / size != nitems) {
                        gz_error(state, Z_STREAM_ERROR, "request does not fit in a size_t");
                        return 0;
                    }
                
                    /* read len or fewer bytes to buf, return the number of full items read */
                    return len ? gz_read(state, buf, len) / size : 0;
                }
                
                /* -- see zlib.h -- */
                #ifdef Z_PREFIX_SET
                #  undef z_gzgetc
                #else
                #  undef gzgetc
                #endif
                int ZEXPORT gzgetc(file)
                    gzFile file;
       ##### -> {
                    int ret;
                    unsigned char buf[1];
                    gz_statep state;
                
                    /* get internal structure */
                    if (file == NULL)
                        return -1;
                    state = (gz_statep)file;
                
                    /* check that we're reading and that there's no (serious) error */
                    if (state->mode != GZ_READ ||
                        (state->err != Z_OK && state->err != Z_BUF_ERROR))
                        return -1;
                
                    /* try output buffer (no need to check for skip request) */
                    if (state->x.have) {
                        state->x.have--;
                        state->x.pos++;
                        return *(state->x.next)++;
                    }
                
                    /* nothing there -- try gz_read() */
                    ret = gz_read(state, buf, 1);
                    return ret < 1 ? -1 : buf[0];
                }
                
                int ZEXPORT gzgetc_(file)
                gzFile file;
       ##### -> {
                    return gzgetc(file);
                }
                
                /* -- see zlib.h -- */
                int ZEXPORT gzungetc(c, file)
                    int c;
                    gzFile file;
       ##### -> {
                    gz_statep state;
                
                    /* get internal structure */
                    if (file == NULL)
                        return -1;
                    state = (gz_statep)file;
                
                    /* check that we're reading and that there's no (serious) error */
                    if (state->mode != GZ_READ ||
                        (state->err != Z_OK && state->err != Z_BUF_ERROR))
                        return -1;
                
                    /* process a skip request */
                    if (state->seek) {
                        state->seek = 0;
                        if (gz_skip(state, state->skip) == -1)
                            return -1;
                    }
                
                    /* can't push EOF */
                    if (c < 0)
                        return -1;
                
                    /* if output buffer empty, put byte at end (allows more pushing) */
                    if (state->x.have == 0) {
                        state->x.have = 1;
                        state->x.next = state->out + (state->size << 1) - 1;
                        state->x.next[0] = (unsigned char)c;
                        state->x.pos--;
                        state->past = 0;
                        return c;
                    }
                
                    /* if no room, give up (must have already done a gzungetc()) */
                    if (state->x.have == (state->size << 1)) {
                        gz_error(state, Z_DATA_ERROR, "out of room to push characters");
                        return -1;
                    }
                
                    /* slide output data if needed and insert byte before existing data */
                    if (state->x.next == state->out) {
                        unsigned char *src = state->out + state->x.have;
                        unsigned char *dest = state->out + (state->size << 1);
                        while (src > state->out)
                            *--dest = *--src;
                        state->x.next = dest;
                    }
                    state->x.have++;
                    state->x.next--;
                    state->x.next[0] = (unsigned char)c;
                    state->x.pos--;
                    state->past = 0;
                    return c;
                }
                
                /* -- see zlib.h -- */
                char * ZEXPORT gzgets(file, buf, len)
                    gzFile file;
                    char *buf;
                    int len;
    32747757 -> {
                    unsigned left, n;
                    char *str;
                    unsigned char *eol;
                    gz_statep state;
                
                    /* check parameters and get internal structure */
                    if (file == NULL || buf == NULL || len < 1)
                        return NULL;
                    state = (gz_statep)file;
                
                    /* check that we're reading and that there's no (serious) error */
                    if (state->mode != GZ_READ ||
                        (state->err != Z_OK && state->err != Z_BUF_ERROR))
                        return NULL;
                
                    /* process a skip request */
                    if (state->seek) {
                        state->seek = 0;
                        if (gz_skip(state, state->skip) == -1)
                            return NULL;
                    }
                
                    /* copy output bytes up to new line or len - 1, whichever comes first --
                       append a terminating zero to the string (we don't check for a zero in
                       the contents, let the user worry about that) */
                    str = buf;
                    left = (unsigned)len - 1;
                    if (left) do {
                        /* assure that something is in the output buffer */
                        if (state->x.have == 0 && gz_fetch(state) == -1)
                            return NULL;                /* error */
                        if (state->x.have == 0) {       /* end of file */
                            state->past = 1;            /* read past end */
                            break;                      /* return what we have */
                        }
                
                        /* look for end-of-line in current output buffer */
                        n = state->x.have > left ? left : state->x.have;
                        eol = (unsigned char *)memchr(state->x.next, '\n', n);
                        if (eol != NULL)
                            n = (unsigned)(eol - state->x.next) + 1;
                
                        /* copy through end-of-line, or remainder if not found */
                        memcpy(buf, state->x.next, n);
                        state->x.have -= n;
                        state->x.next += n;
                        state->x.pos += n;
                        left -= n;
                        buf += n;
                    } while (left && eol == NULL);
                
                    /* return terminated string, or if nothing, end of file */
                    if (buf == str)
                        return NULL;
                    buf[0] = 0;
                    return str;
                }
                
                /* -- see zlib.h -- */
                int ZEXPORT gzdirect(file)
                    gzFile file;
       ##### -> {
                    gz_statep state;
                
                    /* get internal structure */
                    if (file == NULL)
                        return 0;
                    state = (gz_statep)file;
                
                    /* if the state is not known, but we can find out, then do so (this is
                       mainly for right after a gzopen() or gzdopen()) */
                    if (state->mode == GZ_READ && state->how == LOOK && state->x.have == 0)
                        (void)gz_look(state);
                
                    /* return 1 if transparent, 0 if processing a gzip stream */
                    return state->direct;
                }
                
                /* -- see zlib.h -- */
                int ZEXPORT gzclose_r(file)
                    gzFile file;
           1 -> {
                    int ret, err;
                    gz_statep state;
                
                    /* get internal structure */
                    if (file == NULL)
                        return Z_STREAM_ERROR;
                    state = (gz_statep)file;
                
                    /* check that we're reading */
                    if (state->mode != GZ_READ)
                        return Z_STREAM_ERROR;
                
                    /* free memory and close file */
                    if (state->size) {
                        inflateEnd(&(state->strm));
                        free(state->out);
                        free(state->in);
                    }
                    err = state->err == Z_BUF_ERROR ? Z_BUF_ERROR : Z_OK;
                    gz_error(state, Z_OK, NULL);
                    free(state->path);
                    ret = close(state->fd);
                    free(state);
                    return ret ? Z_ERRNO : err;
                }


Top 10 Lines:

     Line      Count

      547   32747757
      231      51885
      177      51884
       58      33409
       26      33408
       93         28
      629          1

Execution Summary:

       15   Executable lines in this file
       15   Lines executed
   100.00   Percent of the file executed

 32918372   Total number of line executions
2194558.13   Average executions per line


*** File /home/chaos/git_reposity/zlib/gzlib.c:
                /* gzlib.c -- zlib functions common to reading and writing gzip files
                 * Copyright (C) 2004-2017 Mark Adler
                 * For conditions of distribution and use, see copyright notice in zlib.h
                 */
                
                #include "gzguts.h"
                
                #if defined(_WIN32) && !defined(__BORLANDC__) && !defined(__MINGW32__)
                #  define LSEEK _lseeki64
                #else
                #if defined(_LARGEFILE64_SOURCE) && _LFS64_LARGEFILE-0
                #  define LSEEK lseek64
                #else
                #  define LSEEK lseek
                #endif
                #endif
                
                /* Local functions */
                local void gz_reset OF((gz_statep));
                local gzFile gz_open OF((const void *, int, const char *));
                
                #if defined UNDER_CE
                
                /* Map the Windows error number in ERROR to a locale-dependent error message
                   string and return a pointer to it.  Typically, the values for ERROR come
                   from GetLastError.
                
                   The string pointed to shall not be modified by the application, but may be
                   overwritten by a subsequent call to gz_strwinerror
                
                   The gz_strwinerror function does not change the current setting of
                   GetLastError. */
                char ZLIB_INTERNAL *gz_strwinerror (error)
                     DWORD error;
                {
                    static char buf[1024];
                
                    wchar_t *msgbuf;
                    DWORD lasterr = GetLastError();
                    DWORD chars = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM
                        | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                        NULL,
                        error,
                        0, /* Default language */
                        (LPVOID)&msgbuf,
                        0,
                        NULL);
                    if (chars != 0) {
                        /* If there is an \r\n appended, zap it.  */
                        if (chars >= 2
                            && msgbuf[chars - 2] == '\r' && msgbuf[chars - 1] == '\n') {
                            chars -= 2;
                            msgbuf[chars] = 0;
                        }
                
                        if (chars > sizeof (buf) - 1) {
                            chars = sizeof (buf) - 1;
                            msgbuf[chars] = 0;
                        }
                
                        wcstombs(buf, msgbuf, chars + 1);
                        LocalFree(msgbuf);
                    }
                    else {
                        sprintf(buf, "unknown win32 error (%ld)", error);
                    }
                
                    SetLastError(lasterr);
                    return buf;
                }
                
                #endif /* UNDER_CE */
                
                /* Reset gzip file state */
                local void gz_reset(state)
                    gz_statep state;
           2 -> {
                    state->x.have = 0;              /* no output data available */
                    if (state->mode == GZ_READ) {   /* for reading ... */
                        state->eof = 0;             /* not at end of file */
                        state->past = 0;            /* have not read past end yet */
                        state->how = LOOK;          /* look for gzip header */
                    }
                    state->seek = 0;                /* no seek request pending */
                    gz_error(state, Z_OK, NULL);    /* clear error */
                    state->x.pos = 0;               /* no uncompressed data yet */
                    state->strm.avail_in = 0;       /* no input data yet */
                }
                
                /* Open a gzip file either by name or file descriptor. */
                local gzFile gz_open(path, fd, mode)
                    const void *path;
                    int fd;
                    const char *mode;
           2 -> {
                    gz_statep state;
                    z_size_t len;
                    int oflag;
                #ifdef O_CLOEXEC
                    int cloexec = 0;
                #endif
                #ifdef O_EXCL
                    int exclusive = 0;
                #endif
                
                    /* check input */
                    if (path == NULL)
                        return NULL;
                
                    /* allocate gzFile structure to return */
                    state = (gz_statep)malloc(sizeof(gz_state));
                    if (state == NULL)
                        return NULL;
                    state->size = 0;            /* no buffers allocated yet */
                    state->want = GZBUFSIZE;    /* requested buffer size */
                    state->msg = NULL;          /* no error message yet */
                
                    /* interpret mode */
                    state->mode = GZ_NONE;
                    state->level = Z_DEFAULT_COMPRESSION;
                    state->strategy = Z_DEFAULT_STRATEGY;
                    state->direct = 0;
                    while (*mode) {
                        if (*mode >= '0' && *mode <= '9')
                            state->level = *mode - '0';
                        else
                            switch (*mode) {
                            case 'r':
                                state->mode = GZ_READ;
                                break;
                #ifndef NO_GZCOMPRESS
                            case 'w':
                                state->mode = GZ_WRITE;
                                break;
                            case 'a':
                                state->mode = GZ_APPEND;
                                break;
                #endif
                            case '+':       /* can't read and write at the same time */
                                free(state);
                                return NULL;
                            case 'b':       /* ignore -- will request binary anyway */
                                break;
                #ifdef O_CLOEXEC
                            case 'e':
                                cloexec = 1;
                                break;
                #endif
                #ifdef O_EXCL
                            case 'x':
                                exclusive = 1;
                                break;
                #endif
                            case 'f':
                                state->strategy = Z_FILTERED;
                                break;
                            case 'h':
                                state->strategy = Z_HUFFMAN_ONLY;
                                break;
                            case 'R':
                                state->strategy = Z_RLE;
                                break;
                            case 'F':
                                state->strategy = Z_FIXED;
                                break;
                            case 'T':
                                state->direct = 1;
                                break;
                            default:        /* could consider as an error, but just ignore */
                                ;
                            }
                        mode++;
                    }
                
                    /* must provide an "r", "w", or "a" */
                    if (state->mode == GZ_NONE) {
                        free(state);
                        return NULL;
                    }
                
                    /* can't force transparent read */
                    if (state->mode == GZ_READ) {
                        if (state->direct) {
                            free(state);
                            return NULL;
                        }
                        state->direct = 1;      /* for empty file */
                    }
                
                    /* save the path name for error messages */
                #ifdef WIDECHAR
                    if (fd == -2) {
                        len = wcstombs(NULL, path, 0);
                        if (len == (z_size_t)-1)
                            len = 0;
                    }
                    else
                #endif
                        len = strlen((const char *)path);
                    state->path = (char *)malloc(len + 1);
                    if (state->path == NULL) {
                        free(state);
                        return NULL;
                    }
                #ifdef WIDECHAR
                    if (fd == -2)
                        if (len)
                            wcstombs(state->path, path, len + 1);
                        else
                            *(state->path) = 0;
                    else
                #endif
                #if !defined(NO_snprintf) && !defined(NO_vsnprintf)
                        (void)snprintf(state->path, len + 1, "%s", (const char *)path);
                #else
                        strcpy(state->path, path);
                #endif
                
                    /* compute the flags for open() */
                    oflag =
                #ifdef O_LARGEFILE
                        O_LARGEFILE |
                #endif
                #ifdef O_BINARY
                        O_BINARY |
                #endif
                #ifdef O_CLOEXEC
                        (cloexec ? O_CLOEXEC : 0) |
                #endif
                        (state->mode == GZ_READ ?
                         O_RDONLY :
                         (O_WRONLY | O_CREAT |
                #ifdef O_EXCL
                          (exclusive ? O_EXCL : 0) |
                #endif
                          (state->mode == GZ_WRITE ?
                           O_TRUNC :
                           O_APPEND)));
                
                    /* open the file with the appropriate flags (or just use fd) */
                    state->fd = fd > -1 ? fd : (
                #ifdef WIDECHAR
                        fd == -2 ? _wopen(path, oflag, 0666) :
                #endif
                        open((const char *)path, oflag, 0666));
                    if (state->fd == -1) {
                        free(state->path);
                        free(state);
                        return NULL;
                    }
                    if (state->mode == GZ_APPEND) {
                        LSEEK(state->fd, 0, SEEK_END);  /* so gzoffset() is correct */
                        state->mode = GZ_WRITE;         /* simplify later checks */
                    }
                
                    /* save the current position for rewinding (only if reading) */
                    if (state->mode == GZ_READ) {
                        state->start = LSEEK(state->fd, 0, SEEK_CUR);
                        if (state->start == -1) state->start = 0;
                    }
                
                    /* initialize stream */
                    gz_reset(state);
                
                    /* return stream */
                    return (gzFile)state;
                }
                
                /* -- see zlib.h -- */
                gzFile ZEXPORT gzopen(path, mode)
                    const char *path;
                    const char *mode;
           2 -> {
                    return gz_open(path, -1, mode);
                }
                
                /* -- see zlib.h -- */
                gzFile ZEXPORT gzopen64(path, mode)
                    const char *path;
                    const char *mode;
       ##### -> {
                    return gz_open(path, -1, mode);
                }
                
                /* -- see zlib.h -- */
                gzFile ZEXPORT gzdopen(fd, mode)
                    int fd;
                    const char *mode;
       ##### -> {
                    char *path;         /* identifier for error messages */
                    gzFile gz;
                
                    if (fd == -1 || (path = (char *)malloc(7 + 3 * sizeof(int))) == NULL)
                        return NULL;
                #if !defined(NO_snprintf) && !defined(NO_vsnprintf)
                    (void)snprintf(path, 7 + 3 * sizeof(int), "<fd:%d>", fd);
                #else
                    sprintf(path, "<fd:%d>", fd);   /* for debugging */
                #endif
                    gz = gz_open(path, fd, mode);
                    free(path);
                    return gz;
                }
                
                /* -- see zlib.h -- */
                #ifdef WIDECHAR
                gzFile ZEXPORT gzopen_w(path, mode)
                    const wchar_t *path;
                    const char *mode;
                {
                    return gz_open(path, -2, mode);
                }
                #endif
                
                /* -- see zlib.h -- */
                int ZEXPORT gzbuffer(file, size)
                    gzFile file;
                    unsigned size;
       ##### -> {
                    gz_statep state;
                
                    /* get internal structure and check integrity */
                    if (file == NULL)
                        return -1;
                    state = (gz_statep)file;
                    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
                        return -1;
                
                    /* make sure we haven't already allocated memory */
                    if (state->size != 0)
                        return -1;
                
                    /* check and set requested size */
                    if ((size << 1) < size)
                        return -1;              /* need to be able to double it */
                    if (size < 2)
                        size = 2;               /* need two bytes to check magic header */
                    state->want = size;
                    return 0;
                }
                
                /* -- see zlib.h -- */
                int ZEXPORT gzrewind(file)
                    gzFile file;
       ##### -> {
                    gz_statep state;
                
                    /* get internal structure */
                    if (file == NULL)
                        return -1;
                    state = (gz_statep)file;
                
                    /* check that we're reading and that there's no error */
                    if (state->mode != GZ_READ ||
                            (state->err != Z_OK && state->err != Z_BUF_ERROR))
                        return -1;
                
                    /* back up and start over */
                    if (LSEEK(state->fd, state->start, SEEK_SET) == -1)
                        return -1;
                    gz_reset(state);
                    return 0;
                }
                
                /* -- see zlib.h -- */
                z_off64_t ZEXPORT gzseek64(file, offset, whence)
                    gzFile file;
                    z_off64_t offset;
                    int whence;
       ##### -> {
                    unsigned n;
                    z_off64_t ret;
                    gz_statep state;
                
                    /* get internal structure and check integrity */
                    if (file == NULL)
                        return -1;
                    state = (gz_statep)file;
                    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
                        return -1;
                
                    /* check that there's no error */
                    if (state->err != Z_OK && state->err != Z_BUF_ERROR)
                        return -1;
                
                    /* can only seek from start or relative to current position */
                    if (whence != SEEK_SET && whence != SEEK_CUR)
                        return -1;
                
                    /* normalize offset to a SEEK_CUR specification */
                    if (whence == SEEK_SET)
                        offset -= state->x.pos;
                    else if (state->seek)
                        offset += state->skip;
                    state->seek = 0;
                
                    /* if within raw area while reading, just go there */
                    if (state->mode == GZ_READ && state->how == COPY &&
                            state->x.pos + offset >= 0) {
                        ret = LSEEK(state->fd, offset - state->x.have, SEEK_CUR);
                        if (ret == -1)
                            return -1;
                        state->x.have = 0;
                        state->eof = 0;
                        state->past = 0;
                        state->seek = 0;
                        gz_error(state, Z_OK, NULL);
                        state->strm.avail_in = 0;
                        state->x.pos += offset;
                        return state->x.pos;
                    }
                
                    /* calculate skip amount, rewinding if needed for back seek when reading */
                    if (offset < 0) {
                        if (state->mode != GZ_READ)         /* writing -- can't go backwards */
                            return -1;
                        offset += state->x.pos;
                        if (offset < 0)                     /* before start of file! */
                            return -1;
                        if (gzrewind(file) == -1)           /* rewind, then skip to offset */
                            return -1;
                    }
                
                    /* if reading, skip what's in output buffer (one less gzgetc() check) */
                    if (state->mode == GZ_READ) {
                        n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > offset ?
                            (unsigned)offset : state->x.have;
                        state->x.have -= n;
                        state->x.next += n;
                        state->x.pos += n;
                        offset -= n;
                    }
                
                    /* request skip (if not zero) */
                    if (offset) {
                        state->seek = 1;
                        state->skip = offset;
                    }
                    return state->x.pos + offset;
                }
                
                /* -- see zlib.h -- */
                z_off_t ZEXPORT gzseek(file, offset, whence)
                    gzFile file;
                    z_off_t offset;
                    int whence;
       ##### -> {
                    z_off64_t ret;
                
                    ret = gzseek64(file, (z_off64_t)offset, whence);
                    return ret == (z_off_t)ret ? (z_off_t)ret : -1;
                }
                
                /* -- see zlib.h -- */
                z_off64_t ZEXPORT gztell64(file)
                    gzFile file;
       ##### -> {
                    gz_statep state;
                
                    /* get internal structure and check integrity */
                    if (file == NULL)
                        return -1;
                    state = (gz_statep)file;
                    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
                        return -1;
                
                    /* return position */
                    return state->x.pos + (state->seek ? state->skip : 0);
                }
                
                /* -- see zlib.h -- */
                z_off_t ZEXPORT gztell(file)
                    gzFile file;
       ##### -> {
                    z_off64_t ret;
                
                    ret = gztell64(file);
                    return ret == (z_off_t)ret ? (z_off_t)ret : -1;
                }
                
                /* -- see zlib.h -- */
                z_off64_t ZEXPORT gzoffset64(file)
                    gzFile file;
       ##### -> {
                    z_off64_t offset;
                    gz_statep state;
                
                    /* get internal structure and check integrity */
                    if (file == NULL)
                        return -1;
                    state = (gz_statep)file;
                    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
                        return -1;
                
                    /* compute and return effective offset in file */
                    offset = LSEEK(state->fd, 0, SEEK_CUR);
                    if (offset == -1)
                        return -1;
                    if (state->mode == GZ_READ)             /* reading */
                        offset -= state->strm.avail_in;     /* don't count buffered input */
                    return offset;
                }
                
                /* -- see zlib.h -- */
                z_off_t ZEXPORT gzoffset(file)
                    gzFile file;
       ##### -> {
                    z_off64_t ret;
                
                    ret = gzoffset64(file);
                    return ret == (z_off_t)ret ? (z_off_t)ret : -1;
                }
                
                /* -- see zlib.h -- */
                int ZEXPORT gzeof(file)
                    gzFile file;
       ##### -> {
                    gz_statep state;
                
                    /* get internal structure and check integrity */
                    if (file == NULL)
                        return 0;
                    state = (gz_statep)file;
                    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
                        return 0;
                
                    /* return end-of-file state */
                    return state->mode == GZ_READ ? state->past : 0;
                }
                
                /* -- see zlib.h -- */
                const char * ZEXPORT gzerror(file, errnum)
                    gzFile file;
                    int *errnum;
       ##### -> {
                    gz_statep state;
                
                    /* get internal structure and check integrity */
                    if (file == NULL)
                        return NULL;
                    state = (gz_statep)file;
                    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
                        return NULL;
                
                    /* return error information */
                    if (errnum != NULL)
                        *errnum = state->err;
                    return state->err == Z_MEM_ERROR ? "out of memory" :
                                                       (state->msg == NULL ? "" : state->msg);
                }
                
                /* -- see zlib.h -- */
                void ZEXPORT gzclearerr(file)
                    gzFile file;
       ##### -> {
                    gz_statep state;
                
                    /* get internal structure and check integrity */
                    if (file == NULL)
                        return;
                    state = (gz_statep)file;
                    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
                        return;
                
                    /* clear error and end-of-file */
                    if (state->mode == GZ_READ) {
                        state->eof = 0;
                        state->past = 0;
                    }
                    gz_error(state, Z_OK, NULL);
                }
                
                /* Create an error message in allocated memory and set state->err and
                   state->msg accordingly.  Free any previous error message already there.  Do
                   not try to free or allocate space if the error is Z_MEM_ERROR (out of
                   memory).  Simply save the error message as a static string.  If there is an
                   allocation failure constructing the error message, then convert the error to
                   out of memory. */
                void ZLIB_INTERNAL gz_error(state, err, msg)
                    gz_statep state;
                    int err;
                    const char *msg;
           4 -> {
                    /* free previously allocated message and clear */
                    if (state->msg != NULL) {
                        if (state->err != Z_MEM_ERROR)
                            free(state->msg);
                        state->msg = NULL;
                    }
                
                    /* if fatal, set state->x.have to 0 so that the gzgetc() macro fails */
                    if (err != Z_OK && err != Z_BUF_ERROR)
                        state->x.have = 0;
                
                    /* set error code, and if no message, then done */
                    state->err = err;
                    if (msg == NULL)
                        return;
                
                    /* for an out of memory error, return literal string when requested */
                    if (err == Z_MEM_ERROR)
                        return;
                
                    /* construct error message with path */
                    if ((state->msg = (char *)malloc(strlen(state->path) + strlen(msg) + 3)) ==
                            NULL) {
                        state->err = Z_MEM_ERROR;
                        return;
                    }
                #if !defined(NO_snprintf) && !defined(NO_vsnprintf)
                    (void)snprintf(state->msg, strlen(state->path) + strlen(msg) + 3,
                                   "%s%s%s", state->path, ": ", msg);
                #else
                    strcpy(state->msg, state->path);
                    strcat(state->msg, ": ");
                    strcat(state->msg, msg);
                #endif
                }
                
                #ifndef INT_MAX
                /* portably return maximum value for an int (when limits.h presumed not
                   available) -- we need to do this to cover cases where 2's complement not
                   used, since C standard permits 1's complement and sign-bit representations,
                   otherwise we could just use ((unsigned)-1) >> 1 */
                unsigned ZLIB_INTERNAL gz_intmax()
                {
                    unsigned p, q;
                
                    p = 1;
                    do {
                        q = p;
                        p <<= 1;
                        p++;
                    } while (p > q);
                    return q >> 1;
                }
                #endif


Top 10 Lines:

     Line      Count

      583          4
       77          2
       95          2
      273          2

Execution Summary:

       17   Executable lines in this file
       17   Lines executed
   100.00   Percent of the file executed

       10   Total number of line executions
     0.59   Average executions per line


*** File /home/chaos/projects/bgi_practice/fastq_gz_handler/FastqHandler.cpp:
                // FastqReader.cpp
                // Author : chaos
                // Date :   5/4/18.
                //
                
                #include <cstring>
                #include <iostream>
                #include <iomanip>
                #include "FastqHandler.h"
                
                #define DEFAULT_OUTPUT_PATH "/result.gz"
                
                using std::cout;
                using std::endl;
                //using std::FILE;
                
           1 -> FastqHandler::FastqHandler(const string &srcPath)
                    : _srcPath(srcPath)
                {
                    _outPath = getParrentPath(_srcPath) + DEFAULT_OUTPUT_PATH;
                    _fastqFile = gzopen(srcPath.c_str(), "rb");
                    _outFile = gzopen(_outPath.c_str(), "wb");
                
                    if (_fastqFile == NULL) {
                        fprintf(stderr, "gzopen source error \n");
                        exit(1);
                    }
                
                    if (_outFile == NULL) {
                        fprintf(stderr, "gzopen output file error \n");
                        exit(1);
                    }
                }
                
           1 -> FastqHandler::~FastqHandler()
                {
                    gzclose_r(_fastqFile);
                    gzclose_w(_outFile);
                }
                
                // filter fastq data from given file path with the specified standard
                void FastqHandler::filter(unsigned int standard_score, double standard_ratio)
           1 -> {
                    _filterStandard_score = standard_score;
                    _filterStandard_ratios = standard_ratio;
                
                    ulong count = 0, effectiveSum = 0;
                    dnaSeq curSeq;
                
                    while (gz_readSeq(curSeq)) {
                        ++count;
                        if (judgeTheSeq(curSeq)) {
                            ++effectiveSum;
                            gz_wrieSeq(curSeq);
                        }
                    }
                
                    // output the report
                    cout << "There are " << count << " DNASequence in the source." << endl;
                    cout << effectiveSum << " effective." << endl;
                    cout << std::setprecision (8) << "The radio is " << (double)effectiveSum/(double)count*100 << "%." << endl;
                    cout << "Here is the result : " << _outPath << endl;
                }
                
                // read a line from gz file.
                bool FastqHandler::gz_getline(string &str)
    32747757 -> {
                    char buff[MAX_LENGTH];
                    if (gzgets(_fastqFile, buff, MAX_LENGTH) != NULL) {
                        str = string(buff, strlen(buff));       // notice the newline character.
                        return true;
                    }
                    return false;
                }
                
                // read a dnaSeq from the source gzfile
                bool FastqHandler::gz_readSeq(dnaSeq &seq)
     8186940 -> {
                    string buffStr;
                    int index = 0;
                    try {
                        while (++index <= 4) {
                            if (!gz_getline(buffStr))
                                return false;
                
                            switch (index) {
                                case 1:
                                    strncpy(seq.id, buffStr.c_str(), buffStr.length()+1);
                                    break;
                                case 2:
                                    strncpy(seq.baseSeq, buffStr.c_str(), buffStr.length()+1);
                                    break;
                                case 3:
                                    break;
                                case 4:
                                    strncpy(seq.quality, buffStr.c_str(), buffStr.length()+1);
                                    break;
                            }
                        }
                
                        return true;
                    }
                    catch (...) {
                        cout << "error ocurred in gz_ReadSeq()." << endl;
                    }
                
                
                    return false;
                }
                
                // write a dnaSeq into the output gzfile
                bool FastqHandler::gz_wrieSeq(dnaSeq &seq)
     5259935 -> {
                    try {
                        gzputs(_outFile, seq.id);
                        gzputs (_outFile, seq.baseSeq);
                        gzputs(_outFile, "+\n");
                        gzputs(_outFile, seq.quality);
                
                        return true;
                    }
                    catch (...) {
                        cout << "error ocurred in gz_writeSeq()." << endl;
                    }
                
                
                    return false;
                }
                
                // judge the dnaSeq'effectiveness
     8186939 -> bool FastqHandler::judgeTheSeq(dnaSeq &seq) {
                    int seqNum = strlen(seq.quality)-1;
                    if (seqNum <= 0)
                        return false;
                
                    int effectNum = 0, score;
                
                    for (int i = 0; i < seqNum; ++i) {
                        score = seq.quality[i]-33;
                        if ( score > _filterStandard_score)
                            ++effectNum;
                    }
                
                    return (double)effectNum/seqNum*100 > _filterStandard_ratios;
                }
                
           1 -> string FastqHandler::getParrentPath(const string &path) {
                    size_t offset;
                    offset = path.find_last_of('/');
                    return path.substr(0, offset);
           2 -> }


Top 10 Lines:

     Line      Count

       67   32747757
       78    8186940
      131    8186939
      113    5259935
      151          2
       17          1
       35          1
       43          1
      147          1

Execution Summary:

        9   Executable lines in this file
        9   Lines executed
   100.00   Percent of the file executed

 54381577   Total number of line executions
6042397.44   Average executions per line


*** File /home/chaos/projects/bgi_practice/fastq_gz_handler/main.cpp:
                #include <iostream>
                #include <unistd.h>
                #include "FastqHandler.h"
                using std::cout;
                using std::endl;
                
       ##### -> int main(int argc, char** argv) {
                
                    bool bFailed = false;
                    unsigned int score;
                    double ratio;
                
                    try {
                        if (argc > 3) {
                            score = (unsigned int)atoi(argv[2]);
                            ratio = atof(argv[3]);
                
                            if (score <= 0 || score >= 41 || ratio <= 0 || ratio >100)
                                bFailed = true;
                        }
                        else
                            bFailed = true;
                
                    }
                    catch (...) {
                        bFailed = true;
                    }
                
                    if (bFailed) {
                        cout << "please check your input parameters\nthe format should be :\n   \
                                proc [fastq path] [filter score] [filter ratio]" << endl;
                        return 0;
                    }
                
                    FastqHandler fastqHandler (argv[1]);
                    fastqHandler.filter(score, ratio);
                
                    return 0;
           2 -> }

Top 10 Lines:

     Line      Count

       39          2

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

        2   Total number of line executions
     1.00   Average executions per line
